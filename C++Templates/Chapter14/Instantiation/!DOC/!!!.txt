//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje INSTANTIATION C++ TEMPLATES.
2. INSTANTIATION C++ TEMPLATES je proces kedy C++ pre dane C++ TEMPLATES a konkretne TEMPLATE ARGUMENTS generuje z C++ TEMPLATES VARIABLES, FUNCTIONS, CLASSES a METHODS.
3. C++ vykonava AUTOMATIC INSTANTIATION. To znamena, ze vzdy ked sa v CODE vyskytne pouzitie TEMPLATE s TEMPLATE ARGUMENTS tak pre toto pouzitie C++ vygeneruje CODE z danej TEMPLATE.
4. Pri AUTOMATIC INSTANTIATION musi mat C++ k dispozicii nielen TEMPLATE DECLARATION, ale aj TEMPLATE DEFINITION.
!!! 5. C++ moze vykonat INSTANTIATION aj vtedy ak danu TEMPLATE realne nebude volat. Typickym prikladom je OVERLOAD RESOLUTION, kde C++ moze vykonat INSTANTIATION pre vsetky posudzovane TEMPLATE FUNCTIONS a TEMPLATE METHODS, hoci napokon bude volana iba 1 z nich.
6. C++ vykonava 2 typy INSTANTIATIONS.
   A. PARTIAL INSTANTIATION.
   B. FULL INSTANTIATION.
7. Pre PARTIAL INSTANTIATION platia nasledujuce fakty.
   A. C++ moze vykonat iba INSTANTIATION CASTI TEMPLATE CODE, ak nepotrebuje INSTANTIATION celej TEMPLATE DEFINITION.
   B. PARTIAL INSTANTIATION sa vykonava napriklad pri definicii POINTER VARIABLE na TEMPLATE CLASS, kedy POINTER VARIABLE nepotrebuje DEFINITION TEMPLATE CLASS, ale staci jej iba DECLARATION TEMPLATE CLASS.
8. Pre FULL INSTANTIATION platia nasledujuce fakty.
   A. Pri FULL INSTANTIATION sa vykonava INSTANTIATION celej TEMPLATE BODY.
   B. FULL INSTANTIATION sa vykonava vzdy, ak je nutna INSTANTIATION celej TEMPLATE BODY. Typickym prikladom je definicia VALUE VARIABLE z TEMPLATE CLASS, ked VALUE VARIABLE potrebuje vediet velkost TEMPLATE CLASS a teda musi vykonat INSTANTIATION celej DEFINITION TEMPLATE CLASS.
9. Ak C++ pre TEMPLATE CLASS je vykonana FULL INSTANTIATION, platia nasledujuce fakty.
   A. Kazdy DECLARATION CLASS MEMBER je TEMPLATE CLASS INSTANTIATED.
   !!! B. DEFINITIONS CLASS MEMBERS vsak vo VACSINE PRIPADOV NIE SU INSTANTIATED. Su iba PARTIALLY INSTANTIATED.
   C. Ak ma TEMPLATE CLASS ANONYMOUS UNION, tak tento je VZDY INSTANTIATED.
   D. Ak ma TEMPLATE CLASS VIRTUAL METHODS, tak tieto MOZU, ale NEMUSIA byt INSTANTIATED. Zavisi to od implementacie daneho COMPILER.
10. DEFAULT TEMPLATE FUNCTION ARGUMENTS su INSTANTIATED IBA ak je dana TEMPLATE FUNCTION volana tak, ze su vyuzite DEFAULT TEMPLATE FUNCTION ARGUMENTS. Ak je volana tak, ze vsetky TEMPLATE FUNCTION ARGUMENTS su definovane EXPLICITNE, potom DEFAULT TEMPLATE FUNCTION ARGUMENTS NIE su INSTANTIATED.
11. DEFAULT MEMBER INITIALIZED NIE su INSTANTIATED, az kym nie su potrebne.
12. Ak ma TEMPLATE CLASS OVERLOADED OPERATOR [OPERATOR->], tak tento OPERATOR by mal vratit bud POINTER TYPE, alebo TYPE na ktory je mozne aplikovat dalsi OPERATOR [OPERATOR->]. No C++ tu ma vynimku a umoznuje definovat OPERATOR [OPERATOR->], ktory NEMA RETURN TYPE POINTER TYPE, alebo TYPE na ktory je mozne aplikovat dalsi OPERATOR [OPERATOR->].
13. C++ pri PARSINGU TEMPLATES vyhladava NAMES pomocou TWO PHASE LOOKUP. TWO PHASE LOOKUP pozostava z nasledujucich faz.
   A. FIRST PHASE.
   B. SECOND PHASE.
14. Pre FIRST PHASE TWO PHASE LOOKUP platia nasledujuce fakty.
   A. FIRST PHASE sa vykonava nad TEMPLATE CODE skor nez je tento CODE INSTANTIATED. Sluzi na co najskorsiu detekciu ERRORS v TEMPLATE CODE.
   B. C++ vykonava LOOKUP NON-DEPENDENT NAMES (NAMES, ktore NIE su zavisle na TEMPLATE PARAMETERS). C++ aplikuje bezne LOOKUP RULES ako aj RULES pre ARGUMENT DEPENDENT LOOKUP.
   !!! C. C++ vykonava LOOKUP aj pre UNQUALIFIED DEPENDENT NAMES (NAMES, ktore SU zavisle na TEMPLATE PARAMETERS a zaroven NEMAJU aplikovany SCOPE RESOLUTION OPERATOR [::] definujuci SCOPE). Prikladom takych NAMES su napriklad nazvy FUNCTIONS a METHODS, ktore maju ako PARAMETERS TEMPLATE PARAMETERS. Na tieto UNQUALIFIED DEPENDENT NAMES su aplikovane IBA bezne LOOKUP RULES, ale NIE ARGUMENT DEPENDENT LOOKUP, ktory je vykonany az v SECOND PHASE. Preto LOOKUP NIE JE povazovany za COMPLETE.
15. Pre SECOND PHASE TWO PHASE LOOKUP platia nasledujuce fakty.
   A. SECOND PHASE sa vykonava v case ked je TEMPALTE CODE INSTANTIATED. TEMPALTE CODE je INSTANTIATED v takzvanom POINT OF INSTANTIATION.
   B. C++ vykonava LOOKUP pre QUALIFIED DEPENDENT NAMES, pricom TEMPLATE PARAMETERS su nahradene za TEMPLATE ARGUMENTS.
   !!! C. C++ vykonava LOOKUP pre UNQUALIFIED DEPENDENT NAMES ARGUMENT DEPENDENT LOOKUP, ktory je dokoncenim LOOKUP z FIRST PHASE.
!!!!! 16. C++ vykonava TEMPLATE INSTANTIATION v takzvanych POINT OF INSTANTIATIONS. Pre POINT OF INSTANTIATION platia nasledujuce fakty.
   A. POINT OF INSTANTIATION je miesto v SOURCE CODE, kde C++ vklada TEMPLATE CODE pre ktory boli nahradene TEMPLATE PARAMETERS za TEMPLATE ARGUMENTS.
   B. POINT OF INSTANTIATION vznika vtedy, ak je TEMPLATE pouzita tak, ze su vsetky jej TEMPLATE PARAMETERS dosadene za TEMPLATE ARGUMENTS.
   !!!!! C. POINT OF INSTANTIATION NIE je na tom istom mieste v CODE, kde je TEMPLATE volana s TEMPLATE ARGUMENTS, pretoze ta moze byt volana vo vnutri FUNCTIONS, alebo METHODS. A tam nie je mozne vkladat TEMPLATE CODE TEMPLATE CLASSES, TEMPLATE VARIABLES, TEMPLATE FUNCTIONS ci TEMPLATE METHODS.
   !!! D. POINT OF INSTANTIATION pre TEMPLATE FUNCTIONS, TEMPLATE METHODS a TEMPLATE VARIABLES sa nachadza na NAMESPACE SCOPE vzdy PO FUNCTION ci METHOD, ktora vyvolala TEMPLATE INSTANTIATION.
   !!! E. POINT OF INSTANTIATION pre TEMPLATE CLASSES sa nachadza na NAMESPACE SCOPE vzdy PRED FUNCTION ci METHOD, ktora vyvolala TEMPLATE INSTANTIATION.
   F. Ak ma TRANSLATION UNIT viacero POINTS OF INSTANTIATION tej istej TEMPLATE s tymi istymi TEMPLATE ARGUMENTS, do uvahy sa berie iba prvy POINT OF INSTANTIATION.
17. C++ pri vkladani TEMPLATES do CODE pouziva INCLUSION MODEL, kedy TEMPLATE su DEFINED v HEADER FILES [.H] a tie su INCLUDED do TRANSLATION UNIT FILES [.CPP].
18. C++ sa sklada z 2 COMPONENTS.
   A. COMPILER. COMPILER vykonava kompilaciu TRANSLATION UNITS [.CPP] a generuje z nich OBJECT FILES, ktore obsahuju MACHINE CODE a SYMBOLIC ANNOTATIONS co su referencie na casti CODE v inych OBJECT FILES.
   B. LINKER. LINKER riesi SYMBOLIC ANNOTATIONS v OBJECT FILES a spaja ich dohromady, aby vytvori EXECUTABLE CODE.
19. Ak sa ta ista TEMPLATE CLASS nachadza vo viacerych TRANSLATION UNITS, nepredstavuje to problem, kedze CLASS neobsahuju ziaden BINARY CODE a tym padom mozu byt generovane nezavisle v kazdom TRANSLATION UNIT.
20. Ak sa ta ista TEMPLATE METHOD, TEMPLATE FUNCTION, TEMPLATE VARIABLE ci TEMPLATE STATIC DATA MEMBERS nachadza vo viacerych TRANSLATION UNITS, tak C++ COMPILER a C++ LINKER musia zabezpecit, aby sa pri INSTANTIATION tychto TEMPLATES v PROGRAME generovala iba 1 verzia BINARY CODE z tychto TEMPLATES.
21. C++ COMPILER a LINKER v zavislosti od IMPLEMENTATION mozu TEMPLATE INSTANTIATION vykonavat roznymi sposobmi. C++ COMPILER a LINKER mozu implementovat niektory z nasledujucich modelov TEMPLATE INSTANTIATION.
   A. GREEDY INSTANTIATION.
   B. QUERIED INSTANTIATION.
   C. ITERATED INSTANTIATION.
22. Pre GREEDY INSTANTIATION model platia nasledujuce fakty.
   A. TEMPLATE INSTANTIATION je vykonavany NEZAVISLE v KAZDOM TRANSLATION UNIT.
   B. Viacero TRANSLATION UNITS mozu mat vygenerovany BINARY CODE pre danu TEMPLATE a TEMPLATE ARGUMENTS.
   C. LINKER zoberie iba 1 INSTANTIATION a vsetky ostatne pri generovani EXECUTABLE CODE vyradi.
23. Pre QUERIED INSTANTIATION model platia nasledujuce fakty.
   A. TEMPLATE INSTANTIATIONS su ukladane do SHARED DATABASE.
   B. Ak sa v DATABASE nenachadza dana TEMPLATE INSTANTIATION, alebo je OBSOLETE pre zmeny v CODE, tak je vygenerovana nova TEMPLATE INSTANTIATION a BINARY CODE je vlozeny do DATABASE.
   C. Ak dana TEMPLATE INSTANTIATION sa v DATABASE uz nachadza, tak COMPILER nemusi robit nic.
   D. LINKER spaja jednotlive OBJECT FILES a TEMPLATE INSTANTIATIONS v DATABASE pri generovani EXECUTABLE CODE.
24. Pre ITERATED INSTANTIATION model platia nasledujuce fakty.
   A. COMPILER vykona COMPILATION vsetkych TRANSLATION UNITS, bez toho aby vykonaval akekolvek TEMPLATE INSTANTIATIONS.
   B. Vygenerovane OBJECT FILES su LINKED pomocou PRELINKER.
   C. PRELINKER spusti LINKER a detekuje vsetky ERRORS, ktore LINKER vygeneroval. Ak v tychto ERRORS najde ERROR sposobenu nevytvorenou TEMPLATE INSTANTIATION tak PRELINKER spusti COMPILATION TRANSLATION UNIT, kde sa SOURCE CODE danej TEMPLATE nachadza, aby vykonal TEMPLATE INSTANTIATION. Tento krok sa opakuje, az kym nie su vykonane vsetky potrebne TEMPLATE INSTANTIATIONS.
25. C++ umoznuje EXPLICIT INSTANTIATION TEMPLATES. Pre EXPLICIT INSTANTIATION platia nasledujuce fakty.
   A. EXPLICIT INSTANTIATION umoznuje C++ prinutit aby vygeneroval pre danu TEMPLATE a TEMPLATE ARGUMENTS BINARY CODE danej TEMPLATE, aj ked tato TEMPLATE NEMUSI byt v CODE NIKDE pouzita.
   B. EXPLICIT INSTANTIATION je mozne robit aj pre TEMPLATE CLASSES, TEMPLATE CLASS STATIC VARIABLES, TEMPLATE CLASS METHODS, TEMPLATE VARIABLES a TEMPLATE FUNCTIONS.
   !!! C. EXPLICIT INSTANTIATION NIE JE mozne vykonat, ak pre danu TEMPLATE a TEMPLATE ARGUMENTS existuje EXPLICIT (FULL) SPECIALIZATION, pretoze by v PROGRAME existovali 2 verzie CODE pre tu istu TEMPLATE a TEMPLATE ARGUMENTS a doslo by k naruseniu ONE DEFINITION RULE.
   !!! D. EXPLICIT INSTANTIATION TEMPLATE FUNCTION sa robi pomocou SYNTAXE [template RETURN_VALUE_TYPE TEMPLATE_FUNCTION_NAME<TEMPLATE_ARGUMENT_1,...TEMPLATE_ARGUMENT_N>(FUNCTION_ARGUMENT_TYPE_1,...,FUNCTION_ARGUMENT_TYPE_N)], kde VALUE 'RETURN_VALUE_TYPE' reprezentuje RETURN VALUE TYPE, VALUE 'TEMPLATE_FUNCTION_NAME' je nazov TEMPLATE FUNCTION, VALUE 'TEMPLATE_ARGUMENT_X' je TEMPLATE ARGUMENT a VALUE 'FUNCTION_ARGUMENT_TYPE_X' je TEMPLATE FUNCTION ARGUMENT. Pri EXPLICIT INSTANTIATION je mozne vyuzit aj ARGUMENT DEDUCTION. To znamena, ze napriklad pre FUNCTION [template<typename TType> void FUNCTION(TType Value)] je mozne pouzit pre EXPLICIT INSTANTIATION aj SYNTAX [template RETURN_TYPE FUNCTION<TEMPLATE_ARGUMENT_1,...,TEMPLATE_ARGUMENT_N>(FUNCTION_ARGUMENT_TYPE_1,...,FUNCTION_ARGUMENT_TYPE_N)], SYNTAX [template RETURN_TYPE FUNCTION<>(FUNCTION_ARGUMENT_TYPE_1,...,FUNCTION_ARGUMENT_TYPE_N)], alebo SYNTAX SYNTAX [template RETURN_TYPE FUNCTION(FUNCTION_ARGUMENT_TYPE_1,...,FUNCTION_ARGUMENT_TYPE_N)].
   E. EXPLICIT INSTANTIATION TEMPLATE CLASS sa robi pomocou SYNTAXE [template class TEMPLATE_CLASS_NAME<TEMPLATE_ARGUMENT_1,...TEMPLATE_ARGUMENT_N>], kde VALUE 'TEMPLATE_CLASS_NAME' je nazov TEMPLATE CLASS a VALUE 'TEMPLATE_ARGUMENT_X' je TEMPLATE ARGUMENT.
   F. EXPLICIT INSTANTIATION TEMPLATE METHOD sa robi pomocou SYNTAXE [template RETURN_VALUE_TYPE TEMPLATE_CLASS_NAME<TEMPLATE_ARGUMENT_1,...TEMPLATE_ARGUMENT_N>::TEMPLATE_METHOD_NAME(METHOD_ARGUMENT_TYPE_1,...,METHOD_ARGUMENT_TYPE_N)], kde VALUE 'RETURN_VALUE_TYPE' reprezentuje RETURN VALUE TYPE, VALUE 'TEMPLATE_CLASS_NAME' je nazov TEMPLATE CLASS, VALUE 'TEMPLATE_ARGUMENT_X' je TEMPLATE ARGUMENT, VALUE 'TEMPLATE_METHOD_NAME' je nazov TEMPLATE METHOD a VALUE 'METHOD_ARGUMENT_TYPE_X' je TEMPLATE METHOD ARGUMENT.
26. EXPLICIT INSTANTIATION je mozne pouzit na optimalizaciu C++ COMPILATION, aby C++ zbytocne vo viacerych TRANSLATION UNITS negeneroval BINARY CODE pre tu istu TEMPLATE s tymi istymi TEMPLATE ARGUMENTS. Optimalizaciu je mozne vykonat nasledujucou organizaciou CODE.
   A. Do HEADER FILE [.H] sa vlozi TEMPLATE DECLARATION, ale NIE TEMPLATE DEFINITION. Ak nejaky TRANSLATION UNIT [.CPP] vykona INCLUDE HEADER FILE, tak v tomto TRANSLATION UNIT [.CPP] C++ NEMOZE vykonat AUTOMATIC INSTANTIATION, pretoze mu chyba TEMPLATE DEFINITION.
   B. Do TRANSLATION UNIT [.CPP] sa vlozi TEMPLATE DEFINITION. TEMPLATE DEFINITION je iba v tomto jedinom TRANSLATION UNIT [.CPP] a teda iba tu moze dojst k INSTANTIATION.
   C. Do TRANSLATION UNIT [.CPP] sa vlozi EXPLICIT INSTANTIATION pre pozadovane TEMPLATE ARGUMENTS. Vdaka tomu C++ vygeneruje BINARY CODE pre danu TEMPLATE a TEMPLATE ARGUMENTS, pricom BINARY CODE je vygenerovany IBA v tomto jednom TRANSLATION UNIT [.CPP].
27. C++ podporuje okrem EXPLICIT INSTANTIATION aj EXPLICIT INSTANTIATION DECLARATION. Pre EXPLICIT INSTANTIATION DECLARATION platia nasledujuce fakty.
   A. EXPLICIT INSTANTIATION DECLARATION umoznuje pre danu TEMPLATE definovat EXPLICIT INSTANTIATION DECLARATION, ktora obsahuje TEMPLATE s dosadenymi TEMPLATE ARGUMENTS.
   !!! B. EXPLICIT INSTANTIATION DECLARATION prinuti COMPILER aby pre danu TEMPLATE a TEMPLATE ARGUMENTS NEGENROVAL BINARY CODE v KAZDOM TRANSLATION UNIT do ktoreho je EXPLICIT INSTANTIATION DECLARATION je vlozena. Ak sa CODE vyskytne pouzitie TEMPLATE a TEMPLATE ARGUMENTS, tak C++ NEGENERUJE v danom TRANSLATION UNIT BINARY CODE, ale predpoklada, ze v nejakom inom TRANSLATION UNIT bude vykonana EXPLICIT INSTANTIATION, ktora BINARY CORE pre danu TEMPLATE a TEMPLATE ARGUMENTS vygeneruje.
   C. EXPLICIT INSTANTIATION DECLARATION ma SYNTAX [extern EXPLICIT_INSTANTIATION], kde VALUE 'EXPLICIT_INSTANTIATION' obsahuje CODE EXPLICIT INSTANTIATION danej TEMPLATE.
   D. EXPLICIT INSTANTIATION DECLARATION pre optimalizaciu COMPILATION PROCESS, ked sa zbytocne pre danu TEMPLATE a TEMPLATE ARGUMENTS negeneruje BINARY CODE v kazdej TRANSLATION UNIT do ktore je TEMPLATE INCLUDED.
!!! 28. EXPLICIT INSTANTIATION DECLARATION v nasledujucich pripadoch NEZABRANI COMPILER aby v kazdej TRANSLATION UNIT do ktorej je TEMPLATE INCULDED negeneroval jej BINARY CODE.
   A. INLINE TEMPLATE FUNCTIONS mozu byt INSTANTIATED, aby mohli byt vlozene do CODE danej TRANSLATION UNIT.
   B. TEMPLATE VARIABLES s TYPE nastavenym na KEYWORD [auto], alebo KEYWORD [decltype(auto)] mozu byt INSTANTIATED.
   C. TEMPLATE FUNCTIONS s RETURN VALUE TYPE nastavenou na KEYWORD [auto], alebo KEYWORD [decltype(auto)] mozu byt INSTANTIATED.
   D. TEMPLATE VARIABLES, ktore su CONSTEXPR mozu byt INSTANTIATED, aby bola ziskana ich VALUE.
   E. TEMPLATE VARIABLES REFERENCE TYPES mozu byt INSTANTIATED, aby ENTITY na ktoru odkazuju mohla byt RESOLVED.
   F. TEMPLATE CLASSES a TEMPLATE ALIASES mozu byt INSTANTIATED, aby sa skontroloval RESULTING TYPE.
29. EXPLICIT INSTANTIATION DECLARATIONS sa pouzivaju nasledujucim sposobom.
   A. V HEADER FILE [.H] sa vlozi TEMPLATE DEFINITON. To znamena, ze TEMPLATE obsahuje nielen DECLARATION, ale aj DEFINITION.
   !!! B. V HEADER FILE [.H] sa pre konkretne TEMPLATE ARGUMENTS vlozia EXPLICIT INSTANTIATION DECLARATIONS. Tym sa zabrani COMPILER, aby pre tieto TEMPLATE s TEMPLATE ARGUMENTS generoval BINARY CODE v kazdom TRANSLATION UNIT do ktoreho je dany HEADER FILE INCLUDED.
   !!! C. V OSOBITNOM TRANSLATION UNIT [.CPP] sa spravi INCLUDE HEADER FILE [.H] do ktoreho sa vlozia EXPLICIT INSTANTIATIONS pre EXPLICIT INSTANTIATION DECLARATIONS, ktore su v HEADER FILE. COMPILER IBA v TOMTO TRANSLATION UNIT [.CPP] bude pre dane TEMPLATES a TEMPLATE ARGUMENTS generovat BINARY CODE.
   !!! D. Ked sa do TRANSLATION UNITS [.CPP] vlozi HEADER FILE [.H] pricom CODE pouzije TEMPLATE s TEMPLATE ARGUMENTS, ktore zodpovedaju niektorej z EXPLICIT INSTANTIATION DECLARATION, tak v tomto TRANSLATION UNITS [.CPP] sa uz NEGENRUJE BINARY CODE.
30. C++ podporuje CONSTEXPR IF. Pre CONSTEXPR IF platia nasledujuce fakty.
   A. CONSTEXPR IF ma SYNTAX [if constexpr (CONDITION) BRANCH_IF else BRANCH_ELSE], kde VALUE 'CONDITION' MUSI byt COMPILE TIME CONSTANT, VALUE 'BRANCH_IF' je BRANCH, ktora sa vykona ak je CONDITON TRUE a VALUE 'BRANCH_ELSE' je BRANCH, ktora sa vykona ak je CONDITON FALSE.
   !!! B. CONSTEXPR IF je vykonavana VZDY v COMPILE TIME.
   !!!!! C. Ta BRANCH, ktora sa NEVYKONA, pretoze nesplna CONDITION je DISCARDED. DISCARDED BRANCH je sice COMPILED, ale NIKDY NIE JE INSTANTIATED. To znamena, ze ak obsahuje TEMPLATE CODE, tak tento NIE JE INSTANTIATED. Podobne, ak obsahuje napriklad volanie NON-TEMPLATE FUNCTION tak LINKER NEVYZADUJE, aby tato FUNCTION bola DEFINED, kedze cela BRANCH je DISCARDED.
31. C++ STANDARD LIBRARY obsahuje velke mnozstvo TEMPLATES. Niektore TEMPLATES ako napriklad STRINGS sa typicky pouzivaju iba s niekolkymi CHARACTER TYPES. Pre tieto casto pouzivane TEMPLATES s TEMPLATE ARGUMENTS implementacie C++ STANDARD LIBRARY obsahuju EXPLICIT INSTANTIATION DECLARATIONS a v osobitnom TRANSLATION UNIT EXPLICIT INSTANTIATIONS, aby sa zrychlila COMPILATION.
//----------------------------------------------------------------------------------------------------------------------