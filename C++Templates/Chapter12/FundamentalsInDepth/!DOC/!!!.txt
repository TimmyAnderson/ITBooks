//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje zakladne vlastnosti C++ TEMPLATES.
2. Kazdy typ TEMPLATE moze byt definvany v nasledujucich SCOPES.
   A. NAMESPACE SCOPES.
   B. CLASS SCOPES.
3. C++ definuje na NAMESPACE SCOPE nasledujuce typy TEMPLATES.
   A. TEMPLATE CLASSES.
   B. TEMPLATE FUNCTIONS.
   C. TEMPLATE VARIABLES.
   D. TEMPLATE TYPE ALIASES.
4. C++ definuje na CLASS SCOPE nasledujuce typy TEMPLATES.
   A. TEMPLATE NESTED CLASSES.
   B. TEMPLATE METHODS.
   !!! C. TEMPLATE STATIC FIELDS.
   D. TEMPLATE TYPE ALIASES.
5. Ak su TEMPLATES definovane na urovni CLASS SCOPES pricom ich DEFINITION je OUT-OF CLASS a OUTER CLASS je tiez TEMPLATE CLASS, potom DEFINITION musi ako PRVY obsahovat CODE [template<TEMPLATE_PARAMETERS>] pre MOST OUTER TEMPLATE CLASS a nasledne CODE [template<TEMPLATE_PARAMETERS>] pre vsetky INNTER TEMPLATE CLASSES a ako POSLEDNY CODE [template<TEMPLATE_PARAMETERS>] pre samotnu INNTER TEMPLATE.
6. Pre UNIONS platia nasledujuce fakty.
   A. UNION v danom case drzi VALUE iba jedneho zo vsetkych FIELDS.
   B. SIZEOF UNION je rovny SIZEOF najvacsieho FIELD zo vsetkych FIELDS.
   !!! C. C++ podporuje aj TEMPLATE UNIONS.
   D. UNIONS mozu mat CONSTRUCTORS, DESTRUCTORS a METHODS.
   E. UNION MEMBERS mozu mat definovane ACCESS SPECIFIERS.
   F. UNIONS nemozu mat BASE CLASSES, ani VIRTUAL METHODS. Zaroven nemozu sluzit ako BASE CLASSES.
   G. UNIONS nemozu mat NON-STATIC FIELDS typu REFERENCES.
7. TEMPLATE FUNCTIONS mozu mat DEFAULT VALUES svojich PARAMETERS. V pripade, ze za PARAMETER s DEFAULT VALUE je dosadeny ARGUMENT, tak sa DEFAULT VALUE pre dany PARAMETER nevytvara.
8. MEMBERS definovane v TEMPLATE CLASS, ktore vsak same NEMAJU VLASTNE TEMPLATE PARAMETERS NIE su povazovane za TEMPLATES.
9. Pre VIRTUAL METHODS definovane v TEMPLATE CLASSES platia nasledujuce fakty.
   A. C++ umoznuje definovat VIRTUAL NON-TEMPLATE METHODS v TEMPLATE CLASSES.
   !!! B. C++ NEUMOZNUJE definovat VIRTUAL TEMPLATE METHODS v TEMPLATE CLASSES. Ak by toto obmedzenie neplatilo, C++ COMPILER by musel prebehnut najprv cely PROGRAM, zistit kolko VIRTUAL TEMPLATE METHODS v kazdej CLASS existuje, aby dokazal vytvorit spravnu velkost VIRTUAL METHODS TABLE, co by komplikovalo COMPILATION.
10. Pre TEMPLATE LINKAGE platia nasledujuce fakty.
   A. TEMPLATES MUSIA mat NAMES, ktore su UNIKATNE v ramci SCOPE v ktorych su definovane. Vynimkou su iba TEMPLATE FUNCTIONS a TEMPLATE METHODS, ktore moze byt OVERLOADED.
   B. TEMPLATES NESMU pouzivat C LINKAGE.
   C. TEMPLATES maju EXTERNAL LINKAGE. Jedinou vynimkou su TEMPLATE FUNCTIONS definovane na NAMESPACE SCOPE, ktore su oznacene pomocou KEYWORD [static], TEMPLATES, ktore patria do UNNAMED NAMESPACE (maju INTERNAL LINKAGE) a MEMBER TEMPLATES, ktore patria do UNNAMED CLASSES (nemaju ziaden LINKAGE).
   D. TEMPLATES NEMOZU byt definovane na FUNCTION SCOPE, alebo LOCAL SCOPE. Jedinou vynimkou su GENERIC LAMBDA FUNCTIONS, ktore mozu byt definovane aj na LOCAL SCOPE.
11. C++ rozlisuje TEMPLATES do nasledujucich kategorii.
   A. PRIMARY TEMPLATES.
   B. NON-PRIMARY TEMPLATES.
12. Pre PRIMARY TEMPLATES platia nasledujuce fakty.
   A. PRIMARY TEMPLATE ma definovane vsetky TEMPLATE PARAMETERS.
   B. PRIMARY TEMPLATE nie je pre ZIADEN TEMPLATE PARAMETER SPECIALIZED.
   !!! C. TEMPLATE FUNCTIONS su VZDY PRIMARY TEMPLATES.
13. Pre NON-PRIMARY TEMPLATES platia nasledujuce fakty.
   A. NON-PRIMARY TEMPLATE je TEMPLATE, ktora ma tak ako PRIMARY TEMPLATE definovane TEMPLATE PARAMETERS.
   !!! B. NON-PRIMARY TEMPLATE je odvodena z PRIMARY TEMPLATE pricom ma niektore TEMPLATE PARAMETERS SPECIALIZED.
   !!! C. TEMPLATE CLASSES mozu byt ako PRIMARY TEMPLATES, tak aj NON-PRIMARY TEMPLATES.
   !!!!! D. FULL SPECIALIZATION PRIMARY TEMPLATE NIE JE TEMPLATE. Je to bezna ENTITY (CLASS, VARIABLE).
14. C++ TEMPLATES podporuju nasledujuce TEMPLATE PARAMETERS.
   A. TYPE PARAMETERS.
   B. NON-TYPE PARAMETERS.
   C. TEMPLATE TEMPLATE PARAMETERS.
15. Pre TEMPLATE PARAMETERS platia nasledujuce fakty.
   A. TEMPLATE PARAMETERS su definovane v ramci KEYWORD [template<TEMPLATE_PARAMETERS>], kde VALUE 'TEMPLATE_PARAMETERS' predstavuje zoznam TEMPLATE PARAMETERS.
   B. Kazdy TEMPLATE PARAMETER moze obsahovat okrem typu (TYPE, NON-TYPE, TEMPLATE) aj TEMPLATE PARAMETER NAME, ktory sa pouzije na identifikaciu daneho TEMPLATE PARAMETER v CODE danej TEMPLATE.
   C. Kazdy TEMPLATE PARAMETER moze mat definovanu DEFAULT VALUE.
   D. TEMPLATE PARAMETERS mozu byt aj v ramci KEYWORD [template<>] pouzita az potom ako su definovane.
16. Pre TEMPLATE TYPE PARAMETERS platia nasledujuce fakty.
   A. TEMPLATE TYPE PARAMETER MUSI je definovany v ramci KEYWORD [template<>], pricom je oznaceny pomocou KEYWORD [typename].
   !!! B. TEMPLATE TYPE PARAMETERS NESMU mat v ramci TEMPLATE CODE pouzity ELABORATED TYPE SPECIFIER. Medzi ELABORATED TYPE SPECIFIERS patri KEYWORD [class], KEYWORD [struct], KEYWORD [union] a KEYWORD [enum].
17. Pre TEMPLATE NON-TYPE PARAMETERS platia nasledujuce fakty.
   A. VALUES TEMPLATE NON-TYPE PARAMETERS musi byt urcena este v COMPILE TIME.
   B. TEMPLATE NON-TYPE PARAMETERS mozu mat TYPES INTEGER TYPES, ENUM TYPES, POINTER TYPES, POINTER TO MEMBER TYPES, LVALUE REFERENCE TYPES, TYPE [nullptr_t] a TYPES deklarovane pomocou KEYWORD [auto], alebo KEYWORD [decltype(auto)].
   !!! C. Ak su TEMPLATE NON-TYPE PARAMETERS ARRAY TYPES, alebo FUNCTION TYPES, tak su automaticky DECAYED na POINTER TYPES.
   !!! D. TEMPLATE NON-TYPE PARAMETERS mozu mat pouzite MODIFIER [const] a MODIFIER [volatile], ale ich NAJLAVEJSI vyskyt je IGNOROVANY.
   !!! E. Ak TEMPLATE NON-TYPE PARAMETERS su NON-REFERENCE TYPE, tak su povazovane za PRVALUES. To znamena, ze ich VALUE nemoze byt modifikovana, ani nemoze byt ziskana ich ADRESA.
   !!! F. TEMPLATE NON-TYPE PARAMETERS NEMOZU byt TYPE RVALUE REFERENCE, iba LVALUE REFERENCE.
   !!!!! G. NON-TYPE TEMPLATE ARGUMENTS nesmu byt POINTERS a REFERENCES na STRING LITERALS, TEMPORARY VARIABLES, DATA MEMBERS a ine SUBOBJECTS, ak tieto OBJECTS NIE su definovane ako STATIC OBJECTS.
18. Pre TEMPLATE TEMPLATE PARAMETERS platia nasledujuce fakty.
   A. TEMPLATE TEMPLATE PARAMETERS su TEMPLATE PARAMETERS, ktore su same TEMPLATES.
   B. TEMPLATE TEMPLATE PARAMETERS su definovane v KEYWORD [template<>] pomocou SYNTAX [template<template<TEMPLATE_PARAMETERS> typename TYPE_1,....,>template<template<TEMPLATE_PARAMETERS> typename TYPE_N].
   !!! C. TEMPLATE TEMPLATE PARAMETERS spravidla nemaju pomenovane nazvy svojich TEMPLATE PARAMETERS, pretoze ich NIE JE mozne pouzit v TEMPLATE CODE iba v KEYWORD [template<>]. Jediny vyznam dat im NAME je vtedy ako TEMPLATE TEMPLATE PARAMETER vyuziva TEMPLATE PARAMETERS pri definovani dalsich svojich PARAMETERS v KEYWORD [template<>].
   D. TEMPLATE TEMPLATE PARAMETERS mozu mat DEFAULT VALUES.
   !!! E. Ako ARGUMENT pre TEMPLATE TEMPLATE PARAMETERS moze byt iba TEMPLATE CLASS, alebo TEMPLATE ALIAS.
   !!!!! F. TEMPLATE TEMPLATE PARAMETER NAME reprezentuje len SAMOTNU TEMPLATE, avsak NIE JEJ TEMPLATE PARAMETERS. Ak je definovany TEMPLATE TEMPLATE PARAMETER [template<typename,typename> typename TYPE], tak VALUE [TYPE] reprezentuje iba nazov SAMOTNEJ TEMPLATE [TYPE], ale nie TEMPLATE s TEMPLATE PARAMETERS [TYPE<PARAMETER_1,..,PARAMETER_N>]. TEMPLATE PARAMETERS treba explicitne doplnit.
19. C++ umoznuje vsetky typy TEMPLATE PARAMETERS zmenit na TEMPLATE PARAMETER PACK. Pre TEMPLATE PARAMETER PACK platia nasledujuce fakty.
   A. TEMPLATE PARAMETER PACK reprezentuje variabilny pocet TEMPLATE PARAMETERS daneho typu.
   B. TEMPLATE PARAMETER PACK pre TEMPLATE TYPE PARAMETERS sa definuje pomocou SYNTAXE [typename... PACK_NAME].
   C. TEMPLATE PARAMETER PACK pre TEMPLATE NON-TYPE PARAMETERS sa definuje pomocou SYNTAXE [TYPE... PACK_NAME].
   D. TEMPLATE PARAMETER PACK pre TEMPLATE TEMPLATE PARAMETERS sa definuje pomocou SYNTAXE [template<TEMPLATE_PARAMETERS>... PACK_NAME].
   !!! E. PRIMARY TEMPLATE CLASSES, TEMPLATE VARIABLES a TEMPLATE ALIASES mozu mat maximalne 1 TEMPLATE PARAMETER PACK, ktory zaroven musi byt ako POSLEDNY v zozname TEMPLATE PARAMETERS.
   !!!!! F. TEMPLATE FUNCTIONS, TEMPLATE METHODS, PARTIAL SPECIALIZATIONS TEMPLATE CLASSES a PARTIAL SPECIALIZATIONS TEMPLATE VARIABLES mozu mat VIACERO TEMPLATE PARAMETER PACKS, ak kazdy TEMPLATE PARAMETER (vratane TEMPLATE PARAMETER PACKS) ma DEFAULT VALUE, alebo moze byt DEDUCED z PROTOTYPE danej TEMPLATE FUNCTION, TEMPLATE METHOD, PARTIAL SPECIALIZATION TEMPLATE CLASS, alebo PARTIAL SPECIALIZATION TEMPLATE VARIABLE.
   G. TEMPLATE PARAMETER PACKS nemozu byt EXPANDED v KEYWORD [template<>] v ktorom su definovane.
20. TEMPLATE PARAMETERS mozu mat DEFAULT TEMPLATE ARGUMENTS. Pre DEFAULT TEMPLATE ARGUMENTS platia nasledujuce fakty.
   A. DEFAULT TEMPLATE ARGUMENTS mozu byt aplikovane na vsetky typy TEMPLATE PARAMETERS.
   !!! B. DEFAULT TEMPLATE ARGUMENTS NEMOZU byt aplikovane na TEMPLATE PARAMETER PACKS.
   C. Pre TEMPLATE CLASSES, TEMPLATE VARIABLES a TEMPLATE ALIASES ak ma TEMPLATE PARAMETER definovany DEFAULT TEMPLATE ARGUMENT, tak aj vsetky nasledujuce TEMPLATE PARAMETERS MUSIA mat definovane DEFAULT TEMPLATE ARGUMENTS.
   !!! D. Pre TEMPLATE FUNCTIONS a TEMPLATE METHODS nie je nutne, aby za TEMPLATE PARAMETER, ktory ma definovany DEFAULT TEMPLATE ARGUMENT mali vsetky nasledujuce TEMPLATE PARAMETERS definovane DEFAULT TEMPLATE ARGUMENTS ak je tieto TEMPLATE PARAMETERS mozu byt DEDUCED z TEMPLATE FUNCTION, alebo TEMPLATE METHOD PROTOTYPE.
   !!!!! E. TEMPLATES mozu byt VIACNASOBNE DECLARED, pricom pri kazdej DECLARATION je mozne doplnit dalsie TEMPLATE ARGUMENTS. Pri dalsej DECLARATION vsak uz definovane DEFAULT TEMPLATE ARGUMENTS NESMU byt ZOPAKOVANE.
   F. TEMPLATE CLASS PARTIAL SPECIALIZATIONS NESMU mat DEFAULT TEMPLATE ARGUMENTS.
   !!! G. CLASS MEMBERS, ktore su DEFINED OUT OF CLASS NESMU mat DEFAULT TEMPLATE ARGUMENTS.
   H. TEMPLATE CLASS FRIEND CLASS DECLARATIONS NESMU mat DEFAULT TEMPLATE ARGUMENTS.
   I. TEMPLATE CLASS FRIEND FUNCTION DECLARATIONS NESMU mat DEFAULT TEMPLATE ARGUMENTS, ale TEMPLATE CLASS FRIEND FUNCTION DEFINITIONS mozu mat DEFAULT TEMPLATE ARGUMENTS.
21. TEMPLATE PARAMETERS su za TEMPLATE ARGUMENTS subsituovane nasledujucim sposobom.
   A. EXPLICIT TEMPLATE ARGUMENTS. TEMPLATE ARGUMENTS su explicite definovane medzi znammi [<>].
   B. INJECTED CLASS NAME. V TEMPLATE CLASS v IN CLASS CODE je mozne sa na CURRENT TEMPLATE CLASS pomocou SYNTAXE [TEMPLATE_NAME] namiesto SYNTAXE [TEMPLATE_NAME<TEMPLATE_PARAMETERS>]. TEMPLATE PARAMETERS su subsitovane TEMPLATE ARGUMENTS TEMPLATE CLASS.
   C. DEFAULT TEMPLATE ARGUMENTS. Su definovane pri definicii TEMPLATE.
   D. ARGUMENT DEDUCTION. Pre TEMPLATE FUNCTIONS, TEMPLATE METHODS a TEMPLATE CLASSES mozu byt TEMPLATE ARGUMENTS DEDUCED bud z TEMPLATE FUNCTION a TEMPLATE METHOD PROTOTYPES a pri TEMPLATE CLASSES z INITIALIZERS.
22. TEMPLATE FUNCTION PARAMETERS mozu byt specifikovane nasledujucimi sposobmi.
   A. Pomocou EXPLICIT TEMPLATE ARGUMENTS.
   B. Pomocou DEFAULT TEMPLATE ARGUMENTS.
   C. Pomocou ARGUMENT DEDUCTION.
23. TEMPLATE FUNCTION PARAMETERS, ktore NEMOZU byt DEDUCED, pretoze nie su sucastou TEMPLATE FUNCTION PARAMETERS LIST by mali byt zadane v TEMPLATE PARAMETER LIST vzdy na zaciatku, aby mohli byt explicitne zadane a az za nimi by sa mali nachadza TEMPLATE PARAMETERS, ktore mozu byt DEDUCED.
24. Kedze TEMPLATE FUNCTIONS mozu byt OVERLOADED, v niektorych pripadoch ani explicitne zadanie vsetkych TEMPLATE PARAMETERS nemusi viest k jednoznacne identifikacii OVERLOADED TEMPLATE FUNCTION.
!!! 25. V pripade existencie viecerych OVERLOADED TEMPLATE FUNCTIONS ERROR pri substituovani TEMPLATE ARGUMENTS za TEMPLATE PARAMETERS nevedie ku COMPILATION ERROR, ak existuje ina verzia danej OVERLOADED TEMPLATE FUNCTION pri ktorej k ERROR pri substituovani nedojde. Tento princip sa nazyva SUBSTITUTION FAILURE IS NOT AN ERROR (SFINAE).
26. Pre TEMPLATE TYPE PARAMETERS mozu byt substituovane lubovolne TYPES, vratane TYPE [void], FUNCTION TYPES ci REFERENCE TYPES. Podmienkou je akurat to, ze CODE danej TEMPLATE musi byt pre dany TYPE ARGUMENT kompilovatelny.
27. TEMPLATE NON-TYPE PARAMETERS mozu byt substituovane za nasledujuce TEMPLATE ARGUMENTS.
   A. VALUE ineho TEMPLATE NON-TYPE PARAMETER, ktory ma identicky TYPE.
   B. COMPILE TIME CONSTANT rovnakeho TYPE ako TYPE TEMPLATE NON-TYPE PARAMETER. Pripustna je aj VALUE ineho TYPE, ak je konvertovatelna na TYPE TEMPLATE NON-TYPE PARAMETER BEZ vykonania NARROWING.
   C. ADDRESS EXTERNAL VARIABLE, ADDRESS FUNCTION, alebo CONSTANT EXPRESSION vracajucu ADDRESS EXTERNAL VARIABLE, alebo ADDRESS FUNCTION.
   F. REFERENCE na EXTERNAL VARIABLE, REFERENCE na FUNCTION, alebo CONSTANT EXPRESSION vracajucu REFERENCE na EXTERNAL VARIABLE, alebo REFERENCE na FUNCTION.
   G. POINTER TO MEMBER CONSTANT, alebo CONSTANT EXPRESSION vracajucu POINTER TO MEMBER CONSTANT.
   H. NULL POINTER CONSTANT.
!!!!! 28. Ako ARGUMENT pre TEMPLATE NON-TYPE PARAMETER NEMOZE byt pouzita ADDRESS na LOCAL VARIABLE. Je to preto, lebo tato ADDRESS je znama az v RUNTIME a NIE JE TO COMPILE TIME CONSTANT. No ADDRESS na STATIC VARIABLE, alebo FUNCTION je COMPILE (LINKING) TIME CONSTANT z moze byt pouzita ako ARGUMENT pre TEMPLATE NON-TYPE PARAMETER.
!!! 29. STRING LITERALS NEMOZU byt pouzite ako ARGUMENTS pre TEMPLATE NON-TYPE PARAMETERS. Ak maju byt pouzite, musia byt ulozene do NON-LOCAL VARIABLE a ta musi byt pouzita ako ARGUMENT pre TEMPLATE NON-TYPE PARAMETER.
30. Pre substituciu TEMPLATE TEMPLATE PARAMETERS za TEMPLATE TEMPLATE ARGUMENTS platia nasledujuce fakty.
   A. Za TEMPLATE TEMPLATE PARAMETERS mozu byt dosadene TEMPLATE CLASSES, TEMPLATE STRUCTURES, TEMPLATE UNIONS a TEMPLATE ALIASES.
   !!! B. TEMPLATE TEMPLATE ARGUMENTS je mozne substituovat za TEMPLATE TEMPLATE PARAMETERS, ak TEMPLATE TEMPLATE ARGUMENTS maju rovnaky POCET a TYPES (TYPE, NON-TYPE, TEMPLATE TEMPLATE) TEMPLATE PARAMETERS ako maju TEMPLATE TEMPLATE PARAMETERS.
   C. Ak TEMPLATE TEMPLATE PARAMETERS maju ako TEMPLATE PARAMETER TEMPLATE PARAMETER PACK, tak za dany TEMPLATE TEMPLATE PARAMETER je mozne dosadit TEMPLATE s lubovolnym poctom TEMPLATE PARAMETERS. Samozrejme, musi platit, ze ak TEMPLATE PARAMETER PACK reprezentuje TEMPLATE TYPE PARAMETERS, tak TEMPLATE pouzita ako ARGUMENT musi mat iba TEMPLATE TYPE PARAMETERS, a nie aj TEMPLATE NON-TYPE PARAMETERS, lebo tie nezodpovedaju TEMPLATE PARAMETER PACK pre TEMPLATE TYPE PARAMETERS.
31. Dve sady TEMPLATE ARGUMENTS su ekvivalentne	ak su VALUES jednotlivych ARGUMENTS identicke jeden po druhom v poradi v akom su deklarovane. Plati nasledovne.
   A. TEMPLATE TYPE ARGUMENTS su identicke, ak reprezentuju ten isty TYPE. V pripade, ze niektory z TYPES je ALIAS, tak sa namiesto ALIAS pouziva realny TYPE na urcenie ekvivalencie.
   B. TEMPLATE NON-TYPE ARGUMENTS su identicke ak maju rovnaky TYPE a rovnaku VALUE.
!!! 32. METHOD generovana TEMPLATE METHOD nie je NIKDY ekvivalentna s beznou NON-TEMPLATE FUNCTION a to ani ked ma zhodne meno. Z toho vyplyvaju nasledujuce zalezitosti.
   A. METHOD generovana z TEMPLATE METHOD NIKDY nevykonava OVERRIDING VIRTUAL METHODS.
   B. METHOD generovana z TEMPLATE METHOD NIKDY nereprezentuje COPY CONSTRUCTOR, MOVE CONSTRUCTOR, COPY OPERATOR [OPERATOR=] a MOVE OPERATOR [OPERATOR=].
33. Pre VARIADIC TEMPLATES platia nasledujuce fakty.
   A. VARIADIC TEMPLATE je TEMPLATE, ktora moze mat lubovolny pocet TEMPLATE PARAMETERS.
   B. TEMPLATE PARAMETERS vo VARIADIC TEMPLATES su reprezentovane pomocou TEMPLATE PARAMETER PACK.
   C. Zoznam ARGUMENTS, ktore subsituuju TEMPLATE PARAMETER PACK sa nazyvaju TEMPLATE ARGUMENT PACK.
   D. C++ umoznuje definovat VARIADIC TEMPLATE CLASS, VARIADIC TEMPLATE FUNCTION, VARIADIC TEMPLATE VARIABLE i VARIADIC TEMPLATE ALIAS.
   E. Kedze TEMPLATE PARAMETER PACK reprezentuje <0,N> TEMPLATE PARAMETERS, moze byt pouzity iba v tych LANGUAGE CONTEXTS, ktore umoznuju pouzitie TEMPLATE PARAMETER PACK ako napriklad OPERATOR [sizeof...()].
34. TEMPLATE PARAMETER PACK moze byt EXPANDED pomocou PACK EXPANSION. Pre PACK EXPANSION platia nasledujuce fakty.
   A. PACK EXPANSION sa vykonava pomocou OPERATOR [...], ktory je pouzity za TEMPLATE PARAMETER PACK.
   B. PACK EXPANSION si je mozne syntakticky predstavit ako rozklad TEMPLATE PARAMETER PACK na jednotlive PARAMETERS. To znamena, ze CODE [TEMPLATE_PARAMETER_PACK...] je mozne syntakticky interpretovat ako CODE [TEMPLATE_PARAMETER_1,TEMPLATE_PARAMETER_2,...,TEMPLATE_PARAMETER_N].
   !!! C. PACK EXPANSION nevykonava EXPANSION iba samotneho TEMPLATE PARAMETER PACK, ale celeho EXPRESSION, ktory je aplikovany na TEMPLATE PARAMETER PACK. To znamena, ze CODE [EXPRESSION(TEMPLATE_PARAMETER_PACK)...] sa interpretuje ako CODE [EXPRESSION(TEMPLATE_PARAMETER_1),EXPRESSION(TEMPLATE_PARAMETER_2),...,EXPRESSION(TEMPLATE_PARAMETER_N)].
   !!! D. K jednotlivym TEMPLATE PARAMETERS v TEMPLATE PARAMETER PACK nie je mozne pristupovat individualne, pretoze nemaju jednotlive NAMES. Pristup je mozny iba aplikovanim RECURSION.
35. PACK EXPANSION [...] je mozne vykonat v nasledujucich CONTEXTS.
   A. V definicii BASE CLASSES.
   B. V BASE CLASS INITIALIZERS v CONSTRUCTORS.
   C. V zozname CALL ARGUMENTS.
   D. V zozname INITIALIZERS [{}].
   E. V TEMPLATE PARAMETER LISTS pre TEMPLATE CLASSES, TEMPLATE FUNCTIONS a TEMPLATE ALIASES.
   F. V C++ ATTRIBUTES.
   G. Pri specifikacii ALIGNMENT danej DECLARATION.
   H. Pri specifikacii CAPTURE LIST v LAMBDA EXPRESSION.
   I. V PARAMETER LIST FUNCTION TYPE.
   J. V USING DECLARATIONS.
   K. Vo FOLD EXPRESSIONS.
36. FUNCTION PARAMETER PACK je TEMPLATE PARAMETER PACK, ktory sa aplikuje v TEMPLATE FUNCTIONS.
37. PACK EXPANSION [...] moze obsahovat EXPRESSION, ktora obsahuje MULTIPLE PARAMETER PACKS.
38. PACK EXPANSION [...] mozu byt NESTED. V takom pripade plati, ze pouzitie PACK EXPANSION [...] sa aplikuje IBA na NAJBLIZSI PACK EXPANSION.
!!!!! 39. PACK EXPANSION [...] nie je SYNTACTIC, ale SEMANTIC zalezitost. Ak je napriklad definovana TEMPLATE CLASS, ktora VARIADIC BASE CLASSES [class CLASS : public BASE_TYPES...], tak vytvorenie instancie tejto TEMPLATE CLASS pre 0 TEMPLATE PARAMETERS NIE JE interpretovane ako CODE [class CLASS : ] co by sposobilo COMPILATION ERROR, ale ako CODE [class CLASS], ktory je kompilovatelny.
40. C++ 17 podporuje FOLD EXPRESSIONS. Pre FOLD EXPRESSIONS platia nasledujuce fakty.
   A. FOLD EXPRESSIONS umonzuju volat pre TEMPLATE PARAMETER PACK BINARY OPERATORS.
   B. Pri FOLD EXPRESSIONS je TEMPLATE PARAMETER PACK rozlozeny na jednotlive PARAMETERS medzi ktore je aplikovany definovany BINARY OPERATOR.
   C. FOLD EXPRESSIONS podporuju BINARY OPERATORS [OPERATOR+], [OPERATOR-], [OPERATOR*], [OPERATOR/], [OPERATOR%], [OPERATOR^], [OPERATOR&], [OPERATOR|], [OPERATOR=], [OPERATOR<], [OPERATOR>], [OPERATOR<<], [OPERATOR>>], [OPERATOR+=], [OPERATOR-=], [OPERATOR*=], [OPERATOR/=], [OPERATOR%=], [OPERATOR^=], [OPERATOR&=], [OPERATOR|=], [OPERATOR<<=], [OPERATOR>>=], [OPERATOR==], [OPERATOR!=], [OPERATOR<=], [OPERATOR>=], [OPERATOR&&], [OPERATOR||], [OPERATOR,], [OPERATOR.*] a [OPERATOR->*].
   D. FOLD EXPRESSIONS umoznuju definovat aj INITIAL VALUES.
41. C++ 17 definuje nasledujuce FOLD EXPRESSIONS.
   A. UNARY LEFT PACK FOLD EXPRESSIONS.
   B. UNARY RIGHT PACK FOLD EXPRESSIONS.
   C. BINARY LEFT PACK FOLD EXPRESSIONS.
   D. BINARY RIGHT PACK FOLD EXPRESSIONS.
42. Pre UNARY LEFT PACK FOLD EXPRESSIONS platia nasledujuce fakty.
   A. UNARY LEFT PACK FOLD EXPRESSION ma SYNTAX [(... OPERATOR PACK)], kde VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS a VALUE 'PACK' je TEMPLATE PARAMETER PACK.
   B. UNARY LEFT PACK sa interpretuje ako CODE [((((PARAMETER_1 OPERATOR PARAMETER_2) OPERATOR PARAMETER_3) ...) OPERATOR PARAMETER_N)], kde VALUES 'PARAMETER_X' reprezentuju jednotlive PARAMETERS TEMPLATE PARAMETER PACK a VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS.
   !!! C. Ak je TEMPLATE PARAMETER PACK PRAZDNY tak FOLD EXPRESSION pre [OPERATOR&&] vracia VALUE [true], pre [OPERATOR||] vracia VALUE [false], pre [OPERATOR,] vracia VALUE [void()] a pre vsetky ostatne BINARY OPERATORS hodi COMPILER ERROR.
43. Pre UNARY RIGHT PACK FOLD EXPRESSIONS platia nasledujuce fakty.
   A. UNARY RIGHT PACK FOLD EXPRESSION ma SYNTAX [(PACK OPERATOR ...)], kde VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS a VALUE 'PACK' je TEMPLATE PARAMETER PACK.
   B. UNARY RIGHT PACK sa interpretuje ako CODE [(PARAMETER_1 OPERATOR (... OPERATOR (PARAMETER_N-2 OPERATOR (PARAMETER_N-1 OPERATOR PARAMETER_N))))], kde VALUES 'PARAMETER_X' reprezentuju jednotlive PARAMETERS TEMPLATE PARAMETER PACK a VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS.
   !!! C. Ak je TEMPLATE PARAMETER PACK PRAZDNY tak FOLD EXPRESSION pre [OPERATOR&&] vracia VALUE [true], pre [OPERATOR||] vracia VALUE [false], pre [OPERATOR,] vracia VALUE [void()] a pre vsetky ostatne BINARY OPERATORS hodi COMPILER ERROR.
44. Pre BINARY LEFT PACK FOLD EXPRESSIONS platia nasledujuce fakty.
   A. BINARY LEFT PACK FOLD EXPRESSION ma SYNTAX [(INIT ... OPERATOR PACK)], kde VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS, VALUE 'PACK' je TEMPLATE PARAMETER PACK a VALUE 'INIT' je INIT VALUE.
   B. BINARY LEFT PACK sa interpretuje ako CODE [(((((INIT OPERATOR PARAMETER_1) OPERATOR PARAMETER_2) OPERATOR PARAMETER_3) ...) OPERATOR PARAMETER_N)], kde VALUES 'PARAMETER_X' reprezentuju jednotlive PARAMETERS TEMPLATE PARAMETER PACK, VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS a VALUE 'INIT' je INIT VALUE.
   !!! C. Ak je TEMPLATE PARAMETER PACK PRAZDNY tak FOLD EXPRESSION vracia VALUE 'INIT'.
45. Pre BINARY RIGHT PACK FOLD EXPRESSIONS platia nasledujuce fakty.
   A. BINARY RIGHT PACK FOLD EXPRESSION ma SYNTAX [(PACK OPERATOR ... INIT)], kde VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS, VALUE 'PACK' je TEMPLATE PARAMETER PACK a VALUE 'INIT' je INIT VALUE.
   B. BINARY RIGHT PACK sa interpretuje ako CODE [(PARAMETER_1 OPERATOR (... OPERATOR (PARAMETER_N-2 OPERATOR (PARAMETER_N-1 OPERATOR (PARAMETER_N OPERATOR INIT)))))], kde VALUES 'PARAMETER_X' reprezentuju jednotlive PARAMETERS TEMPLATE PARAMETER PACK, VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS a VALUE 'INIT' je INIT VALUE.
   !!! C. Ak je TEMPLATE PARAMETER PACK PRAZDNY tak FOLD EXPRESSION vracia VALUE 'INIT'.
!!!!! 46. TEMPLATE PARAMETER PACK ARGUMENT v FOLD EXPRESSIONS moze obsahovat LUBOVOLNE EXPRESSIONS ako napriklad tieto EXPRESSIONS.
   A. Volanie FUNCTION pomocou CODE [... + FUNCTION(PACK)].
   B. Volanie OPERATOR pomocou CODE [... + (PACK+10)].
   C. Volanie CONSTRUCTOR pomocou CODE [... + CLASS(PACK)].
47. C++ umoznuje definovat FRIEND CLASSES pre TEMPLATE CLASSES. Platia nasledujuce fakty.
   A. FRIEND CLASS sa oznacuje pomocou CODE [friend class CLASS_NAME].
   B. V TEMPLATE CLASSES je mozne definovat ako FRIEND NON-TEMPLATE CLASSES i TEMPLATE CLASSES.
   !!! C. FRIEND NON-TEMPLATE CLASS a FRIEND TEMPLATE CLASS nemusia byt DECLARED predtym ako je dana CLASS definovana ako FRIEND.
   D. TEMPLATE CLASS moze definovat ako FRIEND aj samu seba s inymi TEMPLATE PARAMETERS.
   E. TEMPLATE CLASS moze definovat aj TEMPLATE TYPE PARAMETER ako FRIEND CLASS pomocou SYNTAX [friend TYPE_NAME]. Ak TEMPLATE TYPE PARAMETER nie je CLASS, tak FRIEND DECLARATION je ignorovana.
48. C++ umoznuje definovat FRIEND FUNCTIONS a FRIEND TEMPLATE FUNCTIONS pre CLASSES a TEMPLATE CLASSES nasledujucimi sposobmi.
   A. Pouzitim ZATVORIEK [<>].
   B. Nepouzitim ZATVORIEK [<>], pricom FUNCTION NAME NIE JE QUALIFIED pomocou SYNTAX [::].
   C. Nepouzitim ZATVORIEK [<>], pricom FUNCTION NAME JE QUALIFIED pomocou SYNTAX [::].
49. Pre definovanie FRIEND FUNCTIONS a FRIEND TEMPLATE FUNCTIONS pouzitim ZATVORIEK [<>] platia nasledujuce fakty.
   A. Touto SYNTAXOU je mozne definovat FRIENDS IBA pre TEMPLATE FUNCTIONS, ale NIE pre NON-TEMPLATE FUNCTIONS.
   !!! B. TEMPLATE FUNCTIONS MUSIA byt DECLARED predtym ako su oznacene za FRIENDS.
   !!! C. V ZATVORKACH [<>] NEMUSIA byt definovane tie TEMPLATE ARUMENTS, ktore mozu byt DEDUCED.
   D. V pripade, ze su vsetky TEMPLATE PARAMETERS DEDUCED, tak je nutne pouzit prazdne zatvorky [<>].
   !!! E. Takto definovane FRIEND TEMPLATE FUNCTIONS NEMOZU obsahovat DEFINITION TEMPLATE FUNCTIONS iba DECLARATIONS.
50. Pre definovanie FRIEND FUNCTIONS a FRIEND TEMPLATE FUNCTIONS nepouzitim ZATVORIEK [<>], pricom FUNCTION NAME NIE JE QUALIFIED pomocou SYNTAX [::] platia nasledujuce fakty.
   A. Touto SYNTAXOU je mozne definovat FRIENDS IBA pre NON-TEMPLATE FUNCTIONS, ale NIE pre TEMPLATE FUNCTIONS.
   B. Ak FRIEND NON-TEMPLATE FUNCTION nebola uz predtym DECLARED, tak FRIEND DECLARATION zaroven predstavuje prvu DECLARATION danej FUNCTION.
   !!! C. FRIEND NON-TEMPLATE FUNCTION moze obsahovat aj FUNCTION DEFINITION.
51. Pre definovanie FRIEND FUNCTIONS a FRIEND TEMPLATE FUNCTIONS nepouzitim ZATVORIEK [<>], pricom FUNCTION NAME JE QUALIFIED pomocou SYNTAX [::] platia nasledujuce fakty.
   A. Touto SYNTAXOU je mozne definovat FRIENDS pre NON-TEMPLATE FUNCTIONS AJ pre TEMPLATE FUNCTIONS.
   !!! B. NON-TEMPLATE FUNCTIONS a TEMPLATE FUNCTIONS MUSIA byt DECLARED predtym ako su oznacene za FRIENDS.
   !!! C. Ak FRIEND DECLARATION vyhovuje NON-TEMPLATE FUNCTION aj TEMPLATE FUNCTION, tak FRIEND sa aplikuje VZDY na NON-TEMPLATE FUNCTION.
   !!! D. FRIEND moze obsahovat iba NON-TEMPLATE FUNCTION a TEMPLATE FUNCTION DECLARATIONS, ale NIE DEFINITONS.
52. C++ umoznuje definovat FRIEND METHODS pre TEMPLATE CLASSES. Platia nasledujuce fakty.
   A. FRIEND METHOD sa definuje pomocou SYNTAXE [friend RETURN_TYPE TEMPLATE_CLASS_NAME::FUNCTION_NAME(FUNCTION_PROTOTYPE)].
   !!!!! B. CLASS, ktorej METHOD je oznacena za FRIEND musi byt DEFINED pred oznacenim CLASS METHOD za FRIEND. NESTACI ak je iba DECLARED.
53. C++ umoznuje v TEMPLATE CLASS definovat FRIEND NON-TEMPLATE FUNCTIONS, ktore mozu byt zaroven aj DEFINED priamo v BODY TEMPLATE CLASS.
54. C++ umoznuje definovat celu TEMPLATE ako FRIEND. Pre FRIEND TEMPLATES platia nasledujuce fakty.
   A. Ako FRIEND TEMPLATES je mozne definovat TEMPLATE CLASS, TEMPLATE FUNCTION a TEMPLATE METHOD.
   B. FRIEND TEMPLATE FUNCTIONS mozu obsahovat aj TEMPLATE FUNCTION DEFINITION, ak sa nepouziva zatvorkova SYNTAX [<>].
   C. Za FRIEND TEMPLATE su oznacovane vzdy len PRIMARY TEMPLATES a ich MEMBERS. Vsetky PARTIAL SPECIALIZATIONS a FULL SPECIALIZATIONS danej FRIEND TEMPLATE su automaticky povazovane za FRIENDS.
//----------------------------------------------------------------------------------------------------------------------