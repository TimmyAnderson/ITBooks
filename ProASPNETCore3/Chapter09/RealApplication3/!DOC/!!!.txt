//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje rozsirenie realnej APPLICATION v ASP.NET CORE o funkcionalitu SHOPPING CART.
2. SERVICES su v ASP.NET CORE COMPONENTS, ktore zjednodusuju CODE REUSABILITY. Pre SERVICES platia nasledujuce pravidla.
   A. SERVICE je C# CLASS, ktora implementuje SERVICE INTERFACE, alebo je DERIVED z SERVICE BASE CLASS.
   B. SERVICE INTERFACES a SERVICE BASE CLASSES mozu byt LUBOVOLNYMI C# INTERFACES, alebo C# CLASSES. To znaci, ze SERVICE INTERFACES a SERVICE BASE CLASSES nemusia byt iba INTERFACES a CLASSES, ktore definuje ASP.NET CORE, ale mozu to byt lubovolne CUSTOM INTERFACES a CUSTOM CLASSES.
   C. SERVICES musia byt zaregistrovane pomocou instancie, ktora implementuje INTERFACE [IServiceCollection].
3. SERVICES mozu byt registrovane v DEPENDENCY INJECTION FRAMEWORK, vdaka comu su SERVICES pristupne v rozlicnych castiach ASP.NET CORE PROGRAMU.
4. DEPENDENCY INJECTION je programatorska technika, ktora vychadza a nasledujucich principov.
   A. Kazda SHARED FUNCIONALITY v PROGRAME by mala byt definovana pomocou INTERFACES (eventualne BASE CLASSES), ktore definuju CONTRACT, ktory musi CLASS implementujuca dany INTERFACE (eventualne DERIVED CLASS) implementovat.
   B. CLASSES implementujuce SHARED FUNCIONALITY sa nazyvaju SERVICES.
   C. Kedze SERVICES implementuju specificku FUNCTIONALITY, ta je skryta v implementacii PROPERTIES a METHODS tychto SERVICES, INTERFACES (eventualne BASE CLASS) definuju iba CONTRACT, no ziadne IMPLEMENTATION DETAILS.
   C. DEPENDENCY INJECTION teda klasicky princip OOP - POLYMORPHISM.
   D. V ASP.NET CORE existuje DEPENDENCY INJECTION FRAMEWORK, ktory poskytuje mechanizmus zaregistrovat pre dany INTERFACE (eventualne BASE CLASS) SERVICE, ktory tento INTERFACE (eventualne BASE CLASS) implementuje.
   E. Jednou z velkych vyhod DEPENDENCY INJECTION FRAMEWORK v ASP.NET CORE je moznost vytavarat instancie SERVICES na poziadanie v rozlicnych castiach PROGRAMU.
   !!! F. DEPENDENCY INJECTION FRAMEWORK je podla definovaneho SCOPE daneho SERVICE bud vytvorit novu instanciu SERVICE, alebo vratit instanciu existujuceho SERVICE, ak je SERVICE zaregistrovany ako SINGLETON, alebo SCOPED.
   !!! G. Pri vytvarani novych instancii SERVICES, ak DEPENDENCY INJECTION FRAMEWORK zisti, ze CONSTRUCTOR daneho MAIN SERVICE obsahuje ako PARAMETERS instancie inych SERVICES, instancie tychto SERVICES vytvara REKURZIVNE, takze vytvorenie instancie MAIN SERVICE spusta vytvaranie instancii dalsich SERVICES, na ktorych je  MAIN SERVICE zavisly.
5. ASP.NET CORE podporuje vlastnu implementaciu DEPENDENCY INJECTION FRAMEWORK, ktoru ASP.NET CORE pouziva vzdy ked potrebuje vytvorit instancie CONTROLLERS ci instancie inych CLASSES, ktore ASP.NET CORE vytvara.
6. ASP.NET CORE implementuje DEPENDENCY INJECTION FRAMEWORK pomocou CLASS, ktora implementuje INTERFACE [IServiceCollection]. INTERFACE [IServiceCollection] ma nasledujuce MEMBERS.
   A. METHOD [IServiceCollection AddTransient<TService>()] umoznuje pridat TRANSIENT SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. Instancia TRANSIENT SERVICE je vytvorena vzdy ked je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie REFERENCE na SERVICE 'TService'.
   B. METHOD [IServiceCollection AddTransient<TService>(Func<IServiceProvider,TService> ImplementationFactory)] umoznuje pridat TRANSIENT SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. Instancia TRANSIENT SERVICE je vytvorena vzdy ked je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie REFERENCE na SERVICE 'TService'.
   C. METHOD [IServiceCollection AddTransient<TService,TImplementation>()] umoznuje pridat TRANSIENT SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. Instancia TRANSIENT SERVICE je vytvorena vzdy ked je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie REFERENCE na SERVICE 'TService'.
   D. METHOD [IServiceCollection AddTransient<TService,TImplementation>(Func<IServiceProvider,TImplementation> ImplementationFactory)] umoznuje pridat TRANSIENT SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. Instancia TRANSIENT SERVICE je vytvorena vzdy ked je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie REFERENCE na SERVICE 'TService'.
   E. METHOD [IServiceCollection AddTransient<TService>()] umoznuje pridat SCOPED SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SCOPED SERVICE iba raz pocas celeho trvania daneho SCOPE. To znaci, ze ak instancia SERVICE 'TService' v danom SCOPE este nebola vytvorena, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu SERVICE 'TService'. Ak vsak instancia SERVICE 'TService' v danom SCOPE uz bola vytvorena, DEPENDENCY INJECTION FRAMEWORK vracia existujuci instanciu a nova instancia sa uz NEVYTVARA. SCOPE typicky trva pocas spracovania 1 HTTP REQUEST.
   F. METHOD [IServiceCollection AddTransient<TService>(Func<IServiceProvider,TService> ImplementationFactory)] umoznuje pridat SCOPED SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SCOPED SERVICE iba raz pocas celeho trvania daneho SCOPE. To znaci, ze ak instancia SERVICE 'TService' v danom SCOPE este nebola vytvorena, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu SERVICE 'TService'. Ak vsak instancia SERVICE 'TService' v danom SCOPE uz bola vytvorena, DEPENDENCY INJECTION FRAMEWORK vracia existujuci instanciu a nova instancia sa uz NEVYTVARA. SCOPE typicky trva pocas spracovania 1 HTTP REQUEST.
   G. METHOD [IServiceCollection AddTransient<TService,TImplementation>()] umoznuje pridat SCOPED SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SCOPED SERVICE iba raz pocas celeho trvania daneho SCOPE. To znaci, ze ak instancia SERVICE 'TService' v danom SCOPE este nebola vytvorena, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu SERVICE 'TService'. Ak vsak instancia SERVICE 'TService' v danom SCOPE uz bola vytvorena, DEPENDENCY INJECTION FRAMEWORK vracia existujuci instanciu a nova instancia sa uz NEVYTVARA. SCOPE typicky trva pocas spracovania 1 HTTP REQUEST.
   H. METHOD [IServiceCollection AddTransient<TService,TImplementation>(Func<IServiceProvider,TImplementation> ImplementationFactory)] umoznuje pridat SCOPED SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SCOPED SERVICE iba raz pocas celeho trvania daneho SCOPE. To znaci, ze ak instancia SERVICE 'TService' v danom SCOPE este nebola vytvorena, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu SERVICE 'TService'. Ak vsak instancia SERVICE 'TService' v danom SCOPE uz bola vytvorena, DEPENDENCY INJECTION FRAMEWORK vracia existujuci instanciu a nova instancia sa uz NEVYTVARA. SCOPE typicky trva pocas spracovania 1 HTTP REQUEST.
   I. METHOD [IServiceCollection AddSingleton<TService>()] umoznuje pridat SINGLETON SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
   !!! J. METHOD [IServiceCollection AddSingleton<TService>(TService ImplementationInstance)] umoznuje pridat SINGLETON SERIVCE 'TService'. Instanciu SERVICE 'TService' DEPENDENCY INJECTION FRAMEWORK NEVYTVARA, ale vracia instanciu, ktora bola zaslana ako PARAMETER tejto METHOD. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
   K. METHOD [IServiceCollection AddSingleton<TService>(Func<IServiceProvider,TService> ImplementationFactory)] umoznuje pridat SINGLETON SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
   L. METHOD [IServiceCollection AddSingleton<TService,TImplementation>()] umoznuje pridat SINGLETON SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
   M. METHOD [IServiceCollection AddSingleton<TService,TImplementation>(Func<IServiceProvider,TImplementation> ImplementationFactory)] umoznuje pridat SINGLETON SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
7. DEPENDENCY INJECTION FRAMEWORK umoznuje definovat pre kazdy SERVICE jeho LIFESCOPE. DEPENDENCY INJECTION FRAMEWORK definuje nasledujuce LIFESCOPES.
   A. TRANSIENT LIFESCOPE znamena, ze NOVA instancia daneho SERVICE je vytvorena VZDY ked o nu USER DEPENDENCY INJECTION FRAMEWORK poziada.
   B. SCOPED LIFESCOPE znamena, ze SERVICE LIFETIME trva pocas trvania JEDNEHO SCOPE. To znaci, ze ak v ramci daneho SCOPE je DEPENDENCY INJECTION FRAMEWORK poziadany o SERVICE a tento este v danom SCOPE nebol vytvoreny, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu daneho SERVICE. Ak vsak v ramci toho isteho SCOPE je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie tejto SERVICE, tak je vratena UZ VYTVORENA instancia SERVICE. Ked sa SCOPE skonci, tak je SERVICE UVOLNENY a pre novy SCOPE sa vytvara nova instancia SERVICE. Prikladom jedneho SCOPE je spracovanie 1 HTTP REQUEST, ktory je spracovany v tom istom SCOPE.
   C. TRANSIENT LIFESCOPE znamena, ze NOVA instancia daneho SERVICE je vytvorena VZDY ked o nu USER DEPENDENCY INJECTION FRAMEWORK PRVYKRAT poziada. Pri nasledovnych poziadavkach o tento SERVICE uz nova instancia SERVICE NIE JE VYTVARANA a stale sa vracia uz vytvorena instancia daneho SERVICE.
8. ASP.NET CORE DEPENDENCY INJECTION FRAMEWORK podporuje SCOPES. Pre SCOPES platia nasledujuce fakty.
   A. SCOPE urcuje LIFETIME OBJECTS vytvaranych pomocou DEPENDENCY INJECTION FRAMEWORK.
   !!! B. Vsetky CLASSES zaregistrovane pomocou DEPENDENCY INJECTION FRAMEWORK, ktore boli zaregistrovane pomocou volania METHOD [IServiceCollection.AddScoped()] maju zivotvnost identicku so zivotnostou SCOPE. To znaci, ze pocas trvania SCOPE je pre kazdy TYPE zaregistrovany v DEPENDENCY INJECTION FRAMEWORK vytvorena iba 1 INSTANCIA daneho SERVICE, ktory je pocas celej doby SCOPE znova pouzity, bez toho, aby boli vytvarane nove instancie tohto SERVICE. Az po skonceni SCOPE je znova vytvarana nova instancia SERVICE.
   C. SCOPE je standardne nastaveny na spracovanie 1 HTTP REQUEST. To znaci, ze pre kazdu CLASS zaregistrovanu pomocou volania METHOD [IServiceCollection.AddScoped()] je vytvorena iba 1 INSTANCIA, ktora je pouzita pocas celeho spracovanie HTTP REQUEST na RESOLVING DEPENDENCY INJECTION.
   !!! D. ASP.NET umoznuje vytvarat aj CUSTOM SCOPES s vlastnym LIFETIME.
9. SERVICE INTERFACE [IHttpContextAccessor] poskytuje pristup k instancii TYPE [HttpContext]. SERVICE MUSI byt EXPLICITNE zaregistrovany v DEPENDENCY INJECTION FRAMEWORK pomocou CLASS [HttpContextAccessor].
10. COMMAND [dotnet ef migrations add XXX] vytvori novu MIGRATION 'XXX'.
11. COMMAND [dotnet ef database drop --force] odstrani DB.
12. COMMAND [dotnet ef database update] vytvori DB z MIGRATIONS.
13. DATA VALIDATION moze byt vykonavana nasledujucimi sposobmi.
   A. CLIENT VALIDATION je VALIDATION dat na urovni WEB BROWSER. Robi sa pomocou JAVA SCRIPT. Vyhodou je, ze pripade chyby zobrazi okamzite bez nutnosti vykonat HTTP REQUEST na SERVER. Nevyhodou je, ze v pripade, ze data boli po CLIENT VALIDATION zamerne modifikovane pred zaslanim HTTP REQUEST, tieto zmeny CLIENT VALIDATION NEODHADLI. Preto je CLIENT VALIDATION VZDY nutne povazovat iba za OPTIMIZATION FEATURE ku SERVER VALIDATION, ktora by mala byt vykonana VZDY bez ohladu na to ci sa CLIENT VALIDATION vykonala, alebo nie.
   B. SERVER VALIDATION je VALIDATION dat na urovni SERVERA. To znaci, ze DATA musia byt na SERVER zaslane, aby az tam boli VALIDATED. Vyhodou tejto metody je ze su skontrolovane data, ktore su realne odoslane na SERVER a teda VALIDATION je odolna voci zamernej modifikacii dat pri transfere. Nevyhodou je, ze takato VALIDATION dlhsie trva.
!!! 14. DATA VALIDATION by sa mala VZDY robit na SERVER SIDE a optimalne by sa mala robit aj na CLIENT SIDE, aby chyby boli odhalene co najskor bez nutnosti vykonat HTTP REQUEST na SERVER.
15. TAG HELPER CLASS [ValidationSummaryTagHelper] umoznuje zobrazit VALIDATION ERRORS v HTML ELEMENT [<div>]. TAG HELPER CLASS [ValidationSummaryTagHelper] ma nasledujuce MEMBERS.
   A. PROPERTY [Generator] TYPE [IHtmlGenerator] vracia HTML GENERATOR, ktory generuje HTML so zoznamom VALIDATION ERRORS.
   B. PROPERTY [ValidationSummary] TYPE [ValidationSummary], ktora je mapovana na HTML ATTRIBUTE [asp-validation-summary] umoznuje nastavit, ktore VALIDATION ERROR sa budu generovat.
16. ENUM [ValidationSummary] moze nadobudat nasledujuce VALUES.
   A. VALUE [None] znamena, ze sa nezobrazia ZIADNE VALIDATION ERRORS.
   B. VALUE [ModelOnly] znamena, ze sa zobrazia iba MODEL VALIDATION ERRORS, ale nie PROPERTY VALIDATION ERRORS.
   C. VALUE [All] znamena, ze sa zobrazia MODEL VALIDATION ERRORS aj PROPERTY VALIDATION ERRORS.
//----------------------------------------------------------------------------------------------------------------------