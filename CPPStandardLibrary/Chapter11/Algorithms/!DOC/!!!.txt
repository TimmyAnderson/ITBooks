//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie ALGORITHMS v C++.
2. C++ ALGORITHMS su definovane v nasledujucich LIBRARIES.
   A. LIBRARY <algorithm> definuje vacsinu ALGORITHMS.
   B. LIBRARY <numeric> definuje matematicke ALGORITHMS.
   C. LIBRARY <memory> definuje ALGORITHMS pracujuce s RAW MEMORY a OBJECTS.
3. C++ ALGORITHMS boli navrhnute podla nasledujucich principov.
   A. C++ ALGORITHMS pracuju nad COLLECTIONS, ktore su definovane bud pomocou ITERATOR PAIR, alebo pomocou BEGIN ITERATOR. ITERATOR PAIR sa pouziva nad hlavnou COLLECTION, ktoru ALGORITHM prechadza. Ak ALGORITHM vyzaduje pracu s dalsou COLLECTION, ta je spravidla definovana iba pomocou BEGIN ITERATOR a pocet ITEMS v tejto COLLECTION musi byt minimalne taky ako je pocet ITEMS v hlavnej COLLECTION definovanej ITERATOR PAIR.
   B. C++ ALGORITHMS definuju COLLECTION ako POLOOTVORENU, kde BEGIN ITERATOR ukazuje na prvy ITEM v COLLECTION a END ITERATOR ukazuje 1 POSITION za koniec COLLECTION.
   C. C++ ALGORITHMS prepisuju VALUES ITEMS nad ktorymi pracuju namiesto toho, aby tieto ITEMS vkladali ci odstranovali.
   D. C++ ALGORITHMS odstranuju ITEMS z COLLECTION tak, ze ich presuvaju na koniec COLLECTION, pricom vracaju ako RETURN VALUE novy END ITERATOR, ktory ukazuje na prvy odstraneny ITEM.
   E. C++ ALGORITHMS, ktore vyzaduju vykonanie COMPARISION ci TEST nad ITEMS umoznuju definovat CUSTOM COMPARERS ci CUSTOM PREDICATES, ktore su formou FUNCTION OBJECTS zasielane do C++ ALGORITHMS.
4. C++ definuje nasledujuce ALGORITHMS.
   1. FUNCTION all_of() vracia TRUE ak VSETKY ITEMS v RANGE definovanym ITERATOR PAIR vratili pre PREDICATE zaslany ako PARAMETER TRUE. Inak vracia FALSE.
   2. FUNCTION any_of() vracia TRUE ak ASPON 1 ITEM v RANGE definovanym ITERATOR PAIR vratil pre PREDICATE zaslany ako PARAMETER TRUE. Inak vracia FALSE.
   3. FUNCTION none_of() vracia TRUE ak ZIADEN ITEM v RANGE definovanym ITERATOR PAIR vratil pre PREDICATE zaslany ako PARAMETER TRUE. Inak vracia FALSE.
   4. FUNCTION for_each() pre kazdy ITEM v RANGE definovanym ITERATOR PAIR vola FUNCTION OBJECT zadanym ako PARAMETER. Vracia FUNCTION OBJECT, ktory bol zaslany ako PARAMETER.
   5. FUNCTION for_each_n() pre kazdy ITEM v RANGE definovanym BEGIN ITERATOR a poctom ITEMS vola FUNCTION OBJECT zadanym ako PARAMETER. Vracia END ITERATOR zadanej RANGE.
   6. FUNCTION count() pre RANGE definovanym ITERATOR PAIR vracia pocet ITEMS, ktorych VALUE je rovna VALUE zadanou ako PARAMETER.
   7. FUNCTION count_if() pre RANGE definovanym ITERATOR PAIR vracia pocet ITEMS, pre ktore PREDICATE zaslany ako PARAMETER vrati TRUE.
   8. FUNCTION mismatch() vracia PAIR obsahujuci prvu dvojicu ITEMS, ktore v RANGE 1 definovanym ITERATOR PAIR a RANGE 2 definovanym BEGIN ITERATOR maju ODLISNE VALUES. Ak sa ITERATOR PAIR NENASIEL, vracia sa ITERATOR PAIR obsahujuci END ITERATORS oboch RANGES.OVERLOADED VERSION umoznuje definovat RANGE 2 pomocou ITERATOR PAIR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   9. FUNCTION equal() vracia BOOLEAN VALUE urcujucu ci RANGE 1 definovanym ITERATOR PAIR ma rovnake ITEMS ako RANGE 2 definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat RANGE 2 pomocou ITERATOR PAIR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   10. FUNCTION find() v RANGE definovanym ITERATOR PAIR prvy ITEM, ktory ma rovnaku VALUE ako VALUE, ktora bola zadana ako PARAMETER. Vracia ITERATOR na najdeny ITEM, alebo END ITERATOR povodnej RANGE, ak sa ITEM nepodarilo najst.
   11. FUNCTION find_if() v RANGE definovanym ITERATOR PAIR prvy ITEM pre ktory PREDICATE zaslany ako PARAMETER vrati TRUE. Vracia ITERATOR na najdeny ITEM, alebo END ITERATOR povodnej RANGE, ak sa ITEM nepodarilo najst.
   12. FUNCTION find_if_not() v RANGE definovanym ITERATOR PAIR prvy ITEM pre ktory PREDICATE zaslany ako PARAMETER vrati FALSE. Vracia ITERATOR na najdeny ITEM, alebo END ITERATOR povodnej RANGE, ak sa ITEM nepodarilo najst.
   13. FUNCTION find_end() v RANGE 1 definovanym ITERATOR PAIR hlada posledny vyskyt RANGE 2 definovanym ITERATOR PAIR. Vracia BEGIN ITERATOR na najdenu RANGE, alebo END ITERATOR na RANGE 1, ak sa hladana RANGE nenasla. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   14. FUNCTION find_first_of() v RANGE 1 definovanym ITERATOR PAIR lubovolny ITEM z RANGE 2 definovanym ITERATOR PAIR. Vracia ITERATOR na najdeny ITEM, alebo END ITERATOR RANGE 1 ak sa hladany ITEM nenasiel. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   15. FUNCTION adjacent_find() v RANGE definovanym ITERATOR PAIR hlada prvy vyskyt dvojice za sebou nasledujucich ITEMS s rovnakou VALUE. Vracia ITERATOR na najdenu postupnost, alebo END ITERATOR povodnej RANGE, ak sa hladana postupnost nenasla. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   16. FUNCTION search() v RANGE 1 definovanym ITERATOR PAIR hlada RANGE 2 definovanym ITERATOR PAIR. Vracia BEGIN ITERATOR na najdenu RANGE, alebo END ITERATOR na RANGE 1, ak sa hladana RANGE nenasla. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER. OVERLOADED VERSION umoznuje definovat aj FUNCTION OBJECT, ktory sa na vyhladavanie RANGE pouzije.
   17. FUNCTION search_n() v RANGE definovanym ITERATOR PAIR hlada postupnost 'N' ITEMS, kde 'N' je zadany ako PARAMETER, ktore maju VALUE rovnakou ako VALUE zadanou ako PARAMETER. Vracia BEGIN ITERATOR na zaciatok najdenej postupnosti, alebo END ITERATOR na koniec povodnej RANGE, ak sa v RANGE hladana postupnost nenachadza. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   18. FUNCTION copy() z RANGE definovanym ITERATOR PAIR kopiruje pomocou COPY SEMANTICS do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS. Vracia END ITERATOR odkazujuci 1 POSITION za posledny kopirovany ITEM.
   19. FUNCTION copy_if() z RANGE definovanym ITERATOR PAIR kopiruje pomocou COPY SEMANTICS do OUTPUT RANGE definovanym BEGIN ITERATOR tie ITEMS pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE. Vracia END ITERATOR odkazujuci 1 POSITION za posledny kopirovany ITEM.
   20. FUNCTION copy_n() z RANGE definovanym BEGIN PAIR a poctom ITEMS kopiruje ITEMS pomocou COPY SEMANTICS do OUTPUT RANGE definovanym BEGIN ITERATOR. Vracia END ITERATOR odkazujuci 1 POSITION za posledny kopirovany ITEM.
   21. FUNCTION copy_backward() z RANGE definovanym ITERATOR PAIR kopiruje ITEMS pomocou COPY SEMANTICS do OUTPUT RANGE definovanym END ITERATOR tak, ze ITEMS v OUTPUT RANGE budu v opacnom poradi v akom su v INPUT RANGE. Vracia ITERATOR na posledny kopirovany ITEM.
   22. FUNCTION move() z RANGE definovanym ITERATOR PAIR presuva ITEMS pomocou MOVE SEMANTICS do OUTPUT RANGE definovanym BEGIN ITERATOR. Vracia END ITERATOR odkazujuci 1 POSITION za posledny presunuty ITEM.
   23. FUNCTION move_backward() z RANGE definovanym ITERATOR PAIR presuva ITEMS pomocou MOVE SEMANTICS do OUTPUT RANGE definovanym END ITERATOR tak, ze ITEMS v OUTPUT RANGE budu v opacnom poradi v akom su v INPUT RANGE. Vracia ITERATOR na posledny presunuty ITEM.
   24. FUNCTION fill() do RANGE definovanym ITERATOR PAIR vlozi ITEMS, ktorych VALUES su kopiami VALUE zadanej ako PARAMETER.
   25. FUNCTION fill_n() do RANGE definovanym BEGIN ITERATOR a poctom ITEMS vlozi ITEMS, ktorych VALUES su kopiami VALUE zadanej ako PARAMETER. Vracia END ITERATOR naplnenej RANGE.
   26. FUNCTION transform() nad vsetkymi ITEMS INPUT RANGE 1 definovanym ITERATOR PAIR a INPUT RANGE 2 definovanym BEGIN ITERATOR vykona BINARY OPERATION zadanu ako PARAMETER a vyslednu hodnotu ITEM zapise do OUTPUT RANGE definovanym BEGIN ITERATOR. Vracia END ITERATOR OUTPUT RANGE. OVERLOADED VERSION umoznuje vykonat UNARY OPERATION nad jednym INPUT RANGE.
   27. FUNCTION generate() do RANGE definovanym ITERATOR PAIR vlozi pocet ITEMS generovane pomocou FUNCTION OBJECT zadanym ako PARAMETER.
   28. FUNCTION generate_n() do RANGE definovanym BEGIN ITERATOR a poctom ITEMS vlozi ITEMS, ktorych VALUES su generovane pomocou FUNCTION OBJECT zadanym ako PARAMETER. Vracia END ITERATOR generovanej RANGE.
   29. FUNCTION remove() v INPUT RANGE definovanym ITERATOR PAIR presuva vsetky ITEMS s VALUE zadanou ako PARAMETER na koniec RANGE. Vracia ITERATOR na prvy premiestneny ktory tvori logicky END ITERATOR novovzniknutej RANGE <RANGE_BEGIN,RETURN_ITERATOR).
   30. FUNCTION remove_if() v RANGE definovanym ITERATOR PAIR presuva vsetky ITEMS pre ktore PREDICATE zaslany ako PARAMETER vratil TRUE na koniec RANGE. Vracia ITERATOR na prvy premiestneny ktory tvori logicky END ITERATOR novovzniknutej RANGE <RANGE_BEGIN,RETURN_ITERATOR).
   31. FUNCTION remove_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS, pricom vsak ITEMS OKREM TYCH, ktorych VALUE je rovna VALUE zadanou ako PARAMETER.
   32. FUNCTION remove_copy_if() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS OKREM TYCH pre ktore PREDICATE zaslany ako PARAMETER vrati TRUE.
   33. FUNCTION replace() v INPUT RANGE definovanym ITERATOR PAIR nahradza vsetky ITEMS s VALUE 1 zadanou ako PARAMETER za VALUE 2 zadanu ako PARAMETER.
   34. FUNCTION replace_if() v RANGE definovanym ITERATOR PAIR nahradza vsetky ITEMS pre ktore PREDICATE zaslany ako PARAMETER vratil TRUE za VALUE zaslanu ako PARAMETER.
   35. FUNCTION replace_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS, pricom vsak ITEMS s VALUE 1 zadanou ako PARAMETER nahradza za VALUE 2 zadanu ako PARAMETER.
   36. FUNCTION replace_copy_if() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS, pricom ITEMS pre ktore PREDICATE zaslany ako PARAMETER vratil TRUE su nahradene VALUE, ktora bola zaslana ako PARAMETER.
   37. FUNCTION swap() vymiena dvojicu VALUES zadanych ako PARAMETERS. OVERLOADED VERSION umoznuje VALUES dvojice ARRAYS.
   38. FUNCTION swap_ranges() vymiena VALUES v RANGE 1 definovanym ITERATOR PAIR s VALUES v RANGE 2 definovanym BEGIN ITERATOR.
   39. FUNCTION iter_swap() vymiena VALUES dvojice ITEMS definovanych pomocou ITERATORS.
   40. FUNCTION reverse() v INPUT RANGE definovanym ITERATOR PAIR premiestnuje ITEMS, pricom poradie ITEMS je reverzne voci povodnemu poradiu.
   41. FUNCTION reverse_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje ITEMS do OUTPUT RANGE definovanym BEGIN ITERATOR, pricom poradie ITEMS v OUTPUT RANGE je reverzne voci poradiu ITEMS v INPUT RANGE.
   42. FUNCTION rotate() v INPUT RANGE definovanym ITERATOR PAIR premiestnuje ITEMS, pricom poradie ITEMS je cyklicky rotovane tak, aby ITEM na ktory referuje ITERATOR zaslany ako PARAMETER bol na 1. POSITION a ITEM na POSITION (ITERATOR-1) bol na POSLEDNEJ POSITION v RANGE.
   43. FUNCTION rotate_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje ITEMS do OUTPUT RANGE definovanym BEGIN ITERATOR, pricom poradie ITEMS v OUTPUT RANGE je cyklicky rotovane tak, aby ITEM na ktory referuje ITERATOR zaslany ako PARAMETER bol na 1. POSITION OUTPUT RANGE a ITEM na POSITION (ITERATOR-1) bol na POSLEDNEJ POSITION OUTPUT RANGE.
   44. FUNCTION shuffle() v RANGE definovanym ITERATOR PAIR nahodne zamiesa ITEMS pomocou RANDOM GENERATOR zadanym ako PARAMETER.
   45. FUNCTION sample() z INPUT RANGE definovanym ITERATOR PAIR vybera NAHODNYM VYBEROM 'N' ITEMS, kde 'N' je zadany ako PARAMETER a tieto uklada do OUTPUT RANGE definovanym BEGIN ITERATOR. RANDOM GENERATOR je zaslany ako PARAMETER.
   46. FUNCTION unique() v RANGE definovanym ITERATOR PAIR premiestnuje ITEMS tak, aby ITEMS s rovnakou VALUE, ktore nasleduju za sebou boli presunute na koniec RANGE. Zaroven vracia ITERATOR na prvy premiestneny ITEM. Vysledkom je LOGICKY RANGE <RANGE_BEGIN,RETURN_ITERATOR), ktory NEOBSAHUJE za sebou nasledujuce ITEMS s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   47. FUNCTION unique_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR ITEMS tak, ze sa v OUTPUT RANGE sa NENACHAZAJU ITEMS s ROVNAKOU VALUE za SEBOU. Ak sa v INPUT RANGE taketo ITEMS nachadzaju, do OUTPUT RANGE je vlozeny iba 1. ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   48. FUNCTION is_partitioned() vracia TRUE, ak v RANGE definovanym ITERATOR PAIR plati, ze ITEMS pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE sa nachadzaju PRED ITEMS, pre ktore PREDICATE vracia FALSE. Inak vracia FALSE.
   49. FUNCTION partition() v RANGE definovanym ITERATOR PAIR vykonava SORTING ITEMS, aby vsetky ITEMS, pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE budu v RANGE PRED ITEMS, pre ktore PREDICATE vratil FALSE. Poradie ITEMS s ROVNAKOU VALUE NEMUSI byt ZACHOVANE.
   50. FUNCTION partition_copy() ITEM v RANGE definovanym ITERATOR PAIR kopiruje do dvojice RANGE definovanych BEGIN ITERATORS, pricom do 1. RANGE kopiruje ITEMS pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE a do 2. RANGE kopiruje ITEMS pre ktore PREDICATE vracia FALSE.
   51. FUNCTION stable_partition() v RANGE definovanym ITERATOR PAIR vykonava SORTING ITEMS, aby vsetky ITEMS, pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE budu v RANGE PRED ITEMS, pre ktore PREDICATE vratil FALSE. Poradie ITEMS s ROVNAKOU VALUE je ZACHOVANE.
   52. FUNCTION partition_point() pre RANGE definovanym ITERATOR PAIR vracia ITERATOR na ITEM, ktory NESPLNA PREDICATE zadany ako PARAMETER.
   53. FUNCTION is_sorted() v RANGE definovanym ITERATOR PAIR zistuje ci su vsetky ITEMS v RANGE SORTED. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   54. FUNCTION is_sorted_until() v RANGE definovanym ITERATOR PAIR zistuje kolko ITEMS v RANGE su SORTED. Vracia ITERATOR na ITEM, ktory je v RANGE uz NIE JE SORTED. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   55. FUNCTION sort() v RANGE definovanym ITERATOR PAIR vykonava SORT. Poradie ITEMS s ROVNAKOU VALUE NEMUSI byt ZACHOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   56. FUNCTION partial_sort() v RANGE definovanym ITERATOR PAIR pre ITERATOR urcujuci POSITION v RANGE vykonava PARTIAL SORT. POSITION v RANGE urcuje miesto, ktore ITEMS budu SORTED, pricom plati, ze ITEMS v RANGE <RANGE_BEGIN,POSITION) su SORTED a ZAROVEN maju MENSIU VALUE, ako ktorykolvek ITEM v RANGE (POSITION,RANGE_END). ITEMS v RANGE (POSITION,RANGE_END) NIE su SORTED. Poradie ITEMS s ROVNAKOU VALUE NEMUSI byt ZACHOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   57. FUNCTION partial_sort_copy() v INPUT RANGE definovanym ITERATOR PAIR vykonava PARTIAL SORT. Vysledok je zapisany do OUTPUT RANGE definovanym ITERATOR PAIR. Pocet ITEMS, ktore su SORTED je dany ako MIN((INPUT_RANGE_END-INPUT_RANGE_BEGIN),(OUTPUT_RANGE_END-OUTPUT_RANGE_BEGIN)). Poradie ITEMS s ROVNAKOU VALUE NEMUSI byt ZACHOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   58. FUNCTION stable_sort() v RANGE definovanym ITERATOR PAIR vykonava SORTING vsetkych ITEMS. Poradie ITEMS s ROVNAKOU VALUE OSTAVA ZACHOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   59. FUNCTION nth_element() v RANGE definovanym ITERATOR PAIR pre ITERATOR urcujuci POSITION v RANGE zadanu ako PARAMETER vykona PARTIAL SORT, ktory zabezpeci, ze VSETKY ITEMS pred POSITION na ktoru ukazuje ITERATOR maju MENSIU, alebo ROVNU hodnotu ako ITEMS za POSITION na ktoru ukazuje ITERATOR. Zaroven POSITION na ktoru ukazuje ITERATOR bude obsahovat hodnotu toho ITEM, ktory by sa tam nachadzal, ak by cela COLLECTION bola SORTED. FUNCTION sa lisi od SORT FUNCTIONS v tom, ze NEGARANTUJE, ze VSETKY ITEMS budu SORTED. Garantuje iba to, ze COLLECTION je N-tym ITEM rozdelena na 2 casti, kde ITEMS pred N-tym ITEM su MENSIE, alebo ROVNE, ako ITEMS za N-tym ITEM. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   60. FUNCTION lower_bound() pre SORTED RANGE definovanym ITERATOR PAIR vracia ITERATOR urcujuci ITEM, ktory ma v SORTED RANGE VACSIU, alebo ROVNU VALUE, ako VALUE zadanu ako PARAMETER. V pripade, ze sa taky ITEM v SORTED RANGE NENACHADZA, FUNCTION vracia ITERATOR na POSLEDNY ITEM. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   61. FUNCTION upper_bound() pre SORTED RANGE definovanym ITERATOR PAIR vracia ITERATOR urcujuci ITEM, ktory ma v SORTED RANGE VACSIU VALUE, ako VALUE zadanu ako PARAMETER. V pripade, ze sa taky ITEM v SORTED RANGE NENACHADZA, FUNCTION vracia ITERATOR na POSLEDNY ITEM. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   62. FUNCTION binary_search() vracia BOOLEAN VALUE urcujucu sa ITEM v SORTED RANGE definovanym ITERATOR PAIR nachadza. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   63. FUNCTION equal_range() pre SORTED RANGE definovanym ITERATOR PAIR vracia ITERATOR PAIR urcujuci ITEMS, ktore maju v SORTED RANGE IDENTICKU VALUE, ako VALUE zadanu ako PARAMETER. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   64. FUNCTION merge() vykonava MERGE dvojice v SORTED RANGES definovanych pomocou ITERATOR PAIR. Poradie ITEMS s rovnakou VALUE je ZACHOVANE, pricom ITEMS z 1. SORTED RANGE predchadzaju ITEMS z 2. SORTED RANGE. Vysledny SORTED RANGE je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   65. FUNCTION inplace_merge() vykonava MERGE dvojice v MEMORY PO SEBE IDUCICH SORTED RANGES definovanych pomocou ITERATOR PAIR. Poradie ITEMS s rovnakou VALUE je ZACHOVANE, pricom ITEMS z 1. SORTED RANGE prechadzaju ITESM z 2. SORTED RANGE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   66. FUNCTION includes() vracia BOOLEAN VALUE urcujucu ci kazdy ITEM v SORTED RANGE 2 sa nachadza v SORTED RANGE 1. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   67. FUNCTION set_difference() vykonava DIFFERENCE prvej SORTED RANGE od druhej SORTED RANGE. Obe SORTED RANGES su definovane pomocou ITERATOR PAIR. Pri DIFFERENCE so do vyslednej RANGE zapisovane ITEMS, ktore sa nachadzaju 1. SORTED RANGE, a zaroven sa NENACHADZAJU v 2. SORTED RANGE. Vysledny SORTED SET je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   68. FUNCTION set_intersection() vykonava INTERSECTION dvojice SORTED RANGES definovanych pomocou ITERATOR PAIR. Vysledny SORTED SET je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   69. FUNCTION set_symmetric_difference() vykonava SYMMETRIC DIFFERENCE dvojice SORTED RANGES definovanych pomocou ITERATOR PAIR. Pri SYMETRIC DIFFERENCE so do vyslednej RANGE zapisovane ITEMS, ktore sa nachadzaju IBA v JEDNEJ z dvojice RANGES. Vysledny SORTED SET je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   70. FUNCTION set_union() vykonava UNION dvojice SORTED RANGES definovanych pomocou ITERATOR PAIR. Vysledny SORTED SET je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   71. FUNCTION is_heap() vracia BOOLEAN VALUE urcujucu ci ITERATOR PAIR vytvara MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   72. FUNCTION is_heap_until() vracia ITERATOR na posledny ITEM v ITERATOR PAIR, ktory este vytvara MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   73. FUNCTION make_heap() vytvori z ITEM RANGE definovanym pomocou ITERATOR PAIR MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   74. FUNCTION push_heap() vlozi ITEM na koniec ITEM RANGE definovanym pomocou ITERATOR PAIR, ktory tvori MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   75. FUNCTION pop_heap() presunie ITEM s NAJVYSSOU VALUE na koniec ITEM RANGE definovanym pomocou ITERATOR PAIR, ktory tvori MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   76. FUNCTION sort_heap() vykona SORTING nad ITEM RANGE definovanym pomocou ITERATOR PAIR, ktory tvori MAX HEAP. Po vykonani SORTING uz ITEM RANGE nema vlastnosti MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   77. FUNCTION max() vracia VALUE obsahujuci MAXIMUM ITEM z ITEM RANGE definovanym pomocou INITIALIZER LIST. OVERLOADED VERSION umoznuje pouzit VALUE PAIR namiesto INITIALIZER LIST. Ak RANGE obsahuje VIACERO ITEMS s MAXIMALNOU VALUE, vrati sa VALUE PRVEHO ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   78. FUNCTION max_element() vracia ITERATOR obsahujuci poziciu na MAXIMUM ITEM z ITEM RANGE definovanym pomocou ITERATOR PAIR. Ak RANGE obsahuje VIACERO ITEMS s MAXIMALNOU VALUE, vrati sa ITERATOR na PRVY ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   79. FUNCTION min() vracia VALUE obsahujuci MINIMUM ITEM z ITEM RANGE definovanym pomocou INITIALIZER LIST. Ak RANGE obsahuje VIACERO ITEMS s MINIMALNOU VALUE, vrati sa VALUE PRVEHO ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje pouzit VALUE PAIR namiesto INITIALIZER LIST. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   80. FUNCTION min_element() vracia ITERATOR obsahujuci poziciu na MINIMUM ITEM z ITEM RANGE definovanym pomocou ITERATOR PAIR. Ak RANGE obsahuje VIACERO ITEMS s MINIMALNOU VALUE, vrati sa VALUE PRVEHO ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   81. FUNCTION minmax() vracia VALUE PAIR obsahujuci MINIMUM ITEM a MAXIMUM ITEM z ITEM RANGE definovanym pomocou INITIALIZER LIST. OVERLOADED VERSION umoznuje pouzit VALUE PAIR namiesto INITIALIZER LIST. Ak RANGE obsahuje VIACERO ITEMS s MINIMALNOU VALUE, vrati sa VALUE PRVEHO ITEM s rovnakou VALUE. Ak RANGE obsahuje VIACERO ITEMS s MAXIMALNOU VALUE, vrati sa VALUE POSLEDNEHO ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   82. FUNCTION minmax_element() vracia ITERATOR PAIR obsahujuci pozicie na MINIMUM ITEM a MAXIMUM ITEM z ITEM RANGE definovanym pomocou ITERATOR PAIR. Ak RANGE obsahuje VIACERO ITEMS s MINIMALNOU VALUE, vrati sa ITERATOR na PRVY ITEM s rovnakou VALUE. Ak RANGE obsahuje VIACERO ITEMS s MAXIMALNOU VALUE, vrati sa ITERATOR na POSLEDNY ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   83. FUNCTION clamp() vracia VALUE, ktora je v INTERVALE <MIN,MAX> stanovenom PARAMETRAMI 'MIN' a 'MAX'. Ak plati, ze [VALUE<MIN], FUNCTION vracia VALUE 'MIN'. Ak plati, ze [VALUE>MAX], FUNCTION vracia VALUE 'MAX'. Ak plati, ze [MIN>= VALUE && VALUE<=MAX], tak FUNCTION vracia VALUE 'VALUE'.
   84. FUNCTION lexicographical_compare() vracia BOOLEAN VALUE urcujucu ci ITERATOR RANGE 1 je LEXIKOGRAFICKY MENSI ako ITERATOR RANGE 2. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   85. FUNCTION is_permutation() vracia BOOLEAN VALUE urcujucu ci existuje PERMUTATION z ITERATOR RANGE 1 do ITERATOR RANGE 2. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   86. FUNCTION next_permutation() modifikuje ITEMS v ITERATOR RANGE tak, aby obsahovali NASLELDUJUCE PERMUTATION z mnoziny vsetkych PERMUTATIONS, ktore su zotriedene LEXIKOGRAFICKY. FUNCTION vracia TRUE, ak takato PERMUTATION existuje, ale FALSE, ak neexistuje. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   87. FUNCTION prev_permutation() modifikuje ITEMS v ITERATOR RANGE tak, aby obsahovali PREDCHADZAJUCU PERMUTATION z mnoziny vsetkych PERMUTATIONS, ktore su zotriedene LEXIKOGRAFICKY. FUNCTION vracia TRUE, ak takato PERMUTATION existuje, ale FALSE, ak neexistuje. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   88. FUNCTION iota() uklada do ITEMS v ITERATOR RANGE inkrementujucu sa hodnotu od VALUE, ktore je zadana ako PARAMETER.
   89. FUNCTION accumulate() sumuje vsetky hodnoty ITEMS v ITERATOR RANGE aplikaciou BINARY OPERATOR medzi hodnotami ITEMS. Vysledkom aplikacie BINARY OPERATOR je SCALAR VALUE. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM je prenasana ako PARAMETER. OVERLOADED VERSION umoznuje definovanie CUSTOM OPERATORS.
   90. FUNCTION inner_product() aplikuje medzi zodpovedajucimi ITEMS v 2 ITERATOR RANGES BINARY OPERATOR 2. Nasledne nad vysledkami aplikuje BINARY OPERATOR 1, ktory vykona SUM tychto vysledkov. Vysledkom aplikacie BINARY OPERATOR 1 je SCALAR VALUE. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR 1 pri kalkulacii 1. ITEM je prenasana ako PARAMETER. OVERLOADED VERSION umoznuje definovanie CUSTOM OPERATORS.
   91. FUNCTION adjacent_difference() vypocitava ROZDIEL medzi kazdou DVOJICOU NASLEDUJUCICH ITEMS. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM BINARY OPERATOR.
   92. FUNCTION partial_sum() aplikuje medzi hodnotami ITEMS pre KAZDY RANGE <1,I+1) BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I+1) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM BINARY OPERATOR.
   93. FUNCTION reduce() aplikuje BINARY OPERATOR, ktory vykona SUM jednotlivych ITEMS. Vysledkom aplikacie BINARY OPERATOR je SCALAR VALUE. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE. OVERLOADED VERSION umoznuje definovat START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM. OVERLOADED VERSION umoznuje definovat CUTOM BINARY OPERATOR.
   94. FUNCTION exclusive_scan() aplikuje medzi hodnotami ITEMS pre KAZDY RANGE <1,I) BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM je prenasana ako PARAMETER. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM BINARY OPERATOR.
   95. FUNCTION inclusive_scan() aplikuje medzi hodnotami ITEMS pre KAZDY RANGE <1,I+1) BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I+1) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. OVERLOADED VERSION umoznuje definovat START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM ako aj CUSTOM BINARY OPERATOR. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE.
   96. FUNCTION transform_reduce() aplikuje medzi zodpovedajucimi ITEMS v 2 ITERATOR RANGES BINARY OPERATOR 2. Nasledne nad vysledkami aplikuje BINARY OPERATOR 1, ktory vykona SUM tychto vysledkov. Vysledkom aplikacie BINARY OPERATOR 1 je SCALAR VALUE. PORADIE aplikacie BINARY OPERATOR 1 a BINARY OPERATOR 2 je NEDEFINOVANE. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR 1 pri kalkulacii 1. ITEM je prenasana ako PARAMETER. OVERLOADED VERSION umoznuje namiesto BINARY OPERATOR 2 pouzit UNARY OPERATION. OVERLOADED VERSION umoznuje aj definovanie CUSTOM OPERATORS.
   97. FUNCTION transform_exclusive_scan() transformuje KAZDY ITEM v ITERATOR RANGE pomocou UNARY OPERATOR. Nasledne medzi tranformovanymi hodnotami ITEMS pre KAZDY RANGE <1,I) aplikuje BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM je prenasana ako PARAMETER.
   98. FUNCTION transform_inclusive_scan() transformuje KAZDY ITEM v ITERATOR RANGE pomocou UNARY OPERATOR. Nasledne medzi tranformovanymi hodnotami ITEMS pre KAZDY RANGE <1,I+1) aplikuje BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I+1) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE. OVERLOADED VERSION umoznuje definovat START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM.
   99. FUNCTION uninitialized_copy() kopiruje ITEMS pomocou COPY SEMANTICS ITEMS z MEMORY RANGE do RAW MEMORY RANGE. MEMORY RANGE je definovany ITERATOR PAIR. RAW MEMORY RANGE je definovana pomocou BEGIN ITERATOR.
   100. FUNCTION uninitialized_copy_n() kopiruje ITEMS pomocou COPY SEMANTICS z MEMORY RANGE do RAW MEMORY RANGE. MEMORY RANGE je definovany BEGIN ITERATOR a poctom ITEMS, ktore maju byt kopirovane. RAW MEMORY RANGE je definovana pomocou BEGIN ITERATOR.
   101. FUNCTION uninitialized_fill() kopiruje ITEM pomocou COPY SEMANTICS do RAW MEMORY RANGE. RAW MEMORY RANGE je definovany ITERATOR PAIR.
   102. FUNCTION uninitialized_fill_n() kopiruje ITEM pomocou COPY SEMANTICS do RAW MEMORY RANGE. RAW MEMORY RANGE je definovany BEGIN ITERATOR a poctom kolkokrat ma byt ITEM skopirovany.
   103. FUNCTION uninitialized_move() presuva ITEMS pomocou MOVE SEMANTICS ITEMS z MEMORY RANGE do RAW MEMORY RANGE. MEMORY RANGE je definovany ITERATOR PAIR. RAW MEMORY RANGE je definovana pomocou BEGIN ITERATOR.
   104. FUNCTION uninitialized_move_n() presuva ITEMS pomocou MOVE SEMANTICS z MEMORY RANGE do RAW MEMORY RANGE. MEMORY RANGE je definovany BEGIN ITERATOR a poctom ITEMS, ktore maju byt presunute. RAW MEMORY RANGE je definovana pomocou BEGIN ITERATOR.
   105. FUNCTION uninitialized_default_construct() vola CONSTRUCTORS TYPE [ITERATOR::value_type] pre RAW MEMORY RANGE definovany ITERATOR PAIR. OBJECTS su vytvarane pomocou DEFAULT INITIALIZATION, kedy sa NEVOLA ZIADEN CONSTRUCTOR.
   106. FUNCTION uninitialized_default_construct_n() vola CONSTRUCTORS TYPE [ITERATOR::value_type] pre RAW MEMORY RANGE definovany BEGIN ITERATOR a poctom OBJECTS, ktore maju byt vytvorene. OBJECTS su vytvarane pomocou DEFAULT INITIALIZATION, kedy sa NEVOLA ZIADEN CONSTRUCTOR.
   107. FUNCTION uninitialized_value_construct() vola CONSTRUCTORS TYPE [ITERATOR::value_type] pre RAW MEMORY RANGE definovany ITERATOR PAIR. OBJECTS su vytvarane pomocou VALUE INITIALIZATION, kedy sa VOLA DEFAULT CONSTRUCTOR.
   108. FUNCTION uninitialized_value_construct_n() vola CONSTRUCTORS TYPE [ITERATOR::value_type] pre RAW MEMORY RANGE definovany BEGIN ITERATOR a poctom OBJECTS, ktore maju byt vytvorene. OBJECTS su vytvarane pomocou VALUE INITIALIZATION, kedy sa VOLA DEFAULT CONSTRUCTOR.
   109. FUNCTION destroy_at() vola DESTRUCTOR pre POINTER na OBJECT, ktory je preneseny ako PARAMETER.
   110. FUNCTION destroy() vola DESTRUCTORS pre OBJECT RANGE definovany ITERATOR PAIR.
   111. FUNCTION destroy_n() vola DESTRUCTORS pre OBJECT RANGE definovany BEGIN ITERATOR a poctom OBJECTS, ktore maju byt odstranene.
5. Pre ALGORITHM [TUnaryFunction for_each(TInputIterator First, TInputIterator Last, TUnaryFunction Function)] platia nasledujuce fakty.
   A. FUNCTION for_each() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last), kde pre KAZDY ITEM vola FUNCTION OBJECT 'Function'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa bude volat pre kazdy ITEM v COLLECTION.
   !!! E. RETURN VALUE FUNCTION for_each() je FUNCTION OBJECT 'Function', ktory je presunuty pomocou MOVE SEMANTICS.
   F. FUNCTION OBJECT 'Function' ma PROTOTYPE [void Function(TType& Item)]. Kedze ITEM je prenasany ako NON-CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Function' MOZE VALUE daneho ITEM MODIFIKOVAT. Ak modifikacia ITEMS nie je potrebna, je mozne v PROTOTYPE prenasat ITEM aj BY-VALUE namiesto BY-REFERENCE.
   G. Ak FUNCTION OBJECT 'Function' ma RETURN VALUE, tato je ignorovana.
   !!! H. INTERNAL STATE FUNCTION OBJECT 'Function' moze byt pocas iterovania MODIFIKOVANY. To je mozne pouzit napriklad ak chce FUNCTION OBJECT spocitavat VALUES vsetkych ITEMS, kedy sumarna VALUE moze byt ulozena ako FIELD FUNCTION OBJECT 'Function'.
   I. Zlozitost FUNCTION for_each() je O(N).
6. Pre ALGORITHM [typename iterator_traits<TInputIterator>::difference_type count(TInputIterator First, TInputIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION count() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a pocita kolko ITEMS ma rovnaku VALUE ako PARAMETER 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE, ktorej vyskyt v COLLECTION sa pocita.
   E. RETURN VALUE je DIFFERENCE TYPE obsahujuci pocet ITEMS s VALUE 'Value' v COLLECTION.
   F. Zlozitost FUNCTION count() je O(N).
7. Pre ALGORITHM [typename iterator_traits<TInputIterator>::difference_type count_if(TInputIterator first, TInputIterator last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION count_if() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a pocita pre kolko ITEMS PREDICATE 'Predicate' vrati TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje PREDICATE, ktory sa bude volat pre kazdy ITEM v COLLECTION.
   E. RETURN VALUE je DIFFERENCE TYPE obsahujuci pocet ITEMS pre ktore vrati PREDICATE 'Predicate' TRUE.
   F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   G. Zlozitost FUNCTION count_if() je O(N).
8. Pre ALGORITHM [constexpr TForwardIterator min_element(TForwardIterator First, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION min_element() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM s MINIMALNOU VALUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. RETURN VALUE je ITERATOR na ITEM s MINIMALNOU VALUE.
   !!! E. V pripade, ze COLLECTION obsahuje VIACERO ITEMS s ROVNAKOU MINIMALNOU VALUE, FUNCTION min_element() vracia ITERATOR na PRVY ITEM s MINIMALNOU VALUE. To je ROZDIEL oproti FUNCTION minmax_element().
   F. Na porovnavanie ITEMS sa pouziva OPERATOR<.
   G. Ak COLLECTION je prazdna, FUNCTION min_element() vracia ITERATOR 'Last'.
   H. Zlozitost FUNCTION min_element() je O(N-1).
9. Pre ALGORITHM [constexpr TForwardIterator min_element(TForwardIterator First, TForwardIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION min_element() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM s MINIMALNOU VALUE pricom na porovnanie ITEMS pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   E. RETURN VALUE je ITERATOR na ITEM s MINIMALNOU VALUE.
   !!! F. V pripade, ze COLLECTION obsahuje VIACERO ITEMS s ROVNAKOU MINIMALNOU VALUE, FUNCTION min_element() vracia ITERATOR na PRVY ITEM s MINIMALNOU VALUE. To je ROZDIEL oproti FUNCTION minmax_element().
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Left, const TType& Right)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Left' a NON-CONST PARAMETER 'Right', ktorych VALUES by sa vsak NEMALI MENIT.
   H. Ak COLLECTION je prazdna, FUNCTION min_element() vracia ITERATOR 'Last'.
   I. Zlozitost FUNCTION min_element() je O(N-1).
10. Pre ALGORITHM [constexpr TForwardIterator max_element(TForwardIterator First, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION max_element() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM s MAXIMALNOU VALUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. RETURN VALUE je ITERATOR na ITEM s MAXIMALNOU VALUE.
   !!! E. V pripade, ze COLLECTION obsahuje VIACERO ITEMS s ROVNAKOU MAXIMALNOU VALUE, FUNCTION max_element() vracia ITERATOR na PRVY ITEM s MAXIMALNOU VALUE. To je ROZDIEL oproti FUNCTION minmax_element().
   F. Na porovnavanie ITEMS sa pouziva OPERATOR<.
   G. Ak COLLECTION je prazdna, FUNCTION max_element() vracia ITERATOR 'Last'.
   H. Zlozitost FUNCTION max_element() je O(N-1).
11. Pre ALGORITHM [constexpr TForwardIterator max_element(TForwardIterator First, TForwardIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION max_element() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM s MAXIMALNOU VALUE pricom na porovnanie ITEMS pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   E. RETURN VALUE je ITERATOR na ITEM s MAXIMALNOU VALUE.
   !!! F. V pripade, ze COLLECTION obsahuje VIACERO ITEMS s ROVNAKOU MAXIMALNOU VALUE, FUNCTION max_element() vracia ITERATOR na PRVY ITEM s MAXIMALNOU VALUE. To je ROZDIEL oproti FUNCTION minmax_element().
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Left, const TType& Right)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Left' a NON-CONST PARAMETER 'Right', ktorych VALUES by sa vsak NEMALI MENIT.
   H. Ak COLLECTION je prazdna, FUNCTION max_element() vracia ITERATOR 'Last'.
   I. Zlozitost FUNCTION max_element() je O(N-1).
12. Pre ALGORITHM [constexpr std::pair<TForwardIterator,TForwardIterator> minmax_element(TForwardIterator First, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION minmax_element() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM s MINIMALNOU a MAXIMALNOU VALUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. RETURN VALUE je PAIR obsahujuci ITERATOR na ITEM s MINIMALNOU VALUE a ITERATOR na ITEM s MAXIMALNOU VALUE.
   E. V pripade, ze COLLECTION obsahuje VIACERO ITEMS s ROVNAKOU MINIMALNOU VALUE, FUNCTION minmax_element() vracia ITERATOR na PRVY ITEM s MINIMALNOU VALUE.
   !!! F. V pripade, ze COLLECTION obsahuje VIACERO ITEMS s ROVNAKOU MAXIMALNOU VALUE, FUNCTION minmax_element() vracia ITERATOR na POSLEDNY ITEM s MAXIMALNOU VALUE.
   G. Na porovnavanie ITEMS sa pouziva OPERATOR<.
   H. Ak COLLECTION je prazdna, FUNCTION minmax_element() vracia ITERATOR PAIR ('First','First').
   I. Zlozitost FUNCTION minmax_element() je O(1.5*(N-1)).
13. Pre ALGORITHM [constexpr std::pair<TForwardIterator,TForwardIterator> minmax_element(TForwardIterator First, TForwardIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION minmax_element() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM s MINIMALNOU a MAXIMALNOU VALUE pricom na porovnanie ITEMS pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   E. RETURN VALUE je PAIR obsahujuci ITERATOR na ITEM s MINIMALNOU VALUE a ITERATOR na ITEM s MAXIMALNOU VALUE.
   F. V pripade, ze COLLECTION obsahuje VIACERO ITEMS s ROVNAKOU MINIMALNOU VALUE, FUNCTION minmax_element() vracia ITERATOR na PRVY ITEM s MINIMALNOU VALUE.
   !!! G. V pripade, ze COLLECTION obsahuje VIACERO ITEMS s ROVNAKOU MAXIMALNOU VALUE, FUNCTION minmax_element() vracia ITERATOR na POSLEDNY ITEM s MAXIMALNOU VALUE.
   H. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Left, const TType& Right)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Left' a NON-CONST PARAMETER 'Right', ktorych VALUES by sa vsak NEMALI MENIT.
   I. Ak COLLECTION je prazdna, FUNCTION minmax_element() vracia ITERATOR PAIR ('First','First').
   J. Zlozitost FUNCTION minmax_element() je O(1.5*(N-1)).
14. Pre ALGORITHM [TInputIterator find(TInputIterator First, TInputIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION find() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM, ktoreho VALUE je identicka v PARAMETER 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE, ktora sa v COLLECTION ma vyhladat.
   E. RETURN VALUE je ITERATOR na PRVY ITEM, ktoreho VALUE je rovna PARAMETER 'Value'.
   F. Ak sa ITEM nenasiel, FUNCTION find() vracia ITERATOR 'Last'.
   G. VALUES jednotlivych ITEMS sa porovnavaju pomocou OPERATOR==.
   H. Zlozitost FUNCTION find() je O(N).
15. Pre ALGORITHM [TInputIterator find_if(TInputIterator First, TInputIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION find_if() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM, pre ktory PREDICATE 'Predicate' vrati TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje PREDICATE, ktory sa pouziva na vyhladanie ITEM.
   E. RETURN VALUE je ITERATOR na PRVY ITEM, pre ktory PREDICATE 'Predicate' vrati TRUE.
   F. Ak sa ITEM nenasiel, FUNCTION find_if() vracia ITERATOR 'Last'.
   G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenesany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   H. Zlozitost FUNCTION find_if() je O(N).
16. Pre ALGORITHM [TInputIterator find_if_not(TInputIterator First, TInputIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION find_if_not() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada ITEM, pre ktory PREDICATE 'Predicate' vrati FALSE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje PREDICATE, ktory sa pouziva na vyhladanie ITEM.
   E. RETURN VALUE je ITERATOR na PRVY ITEM, pre ktory PREDICATE 'Predicate' vrati FALSE.
   F. Ak sa postupnost ITEMS nenasla, FUNCTION find_if_not() vracia ITERATOR 'Last'.
   G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenesany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   H. Zlozitost FUNCTION find_if_not() je O(N).
17. Pre ALGORITHM [TForwardIterator search_n(TForwardIterator First, TForwardIterator Last, Size Count, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION search_n() prechadza celou COLLECTION definovanou pomocou BEGIN ITERATOR 'First' a poctom ITEMS 'Count' a hlada postupnost 'Count' za sebou iducich ITEMS, pre ktorych VALUE sa rovna VALUE 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje pocet ITEMS, ktorych postupnost sa ma vyhladat.
   E. 4. PARAMETER definuje VALUE, ktorej postupnost sa v COLLECTION ma vyhladat.
   F. RETURN VALUE je ITERATOR na zaciatok postupnosti 'Count' ITEMS.
   G. Ak sa postupnost ITEMS nenasla, FUNCTION search_n() vracia ITERATOR 'Last'.
   H. Na porovnavanie ITEMS sa pouziva OPERATOR<.
   I. Zlozitost FUNCTION search_n() je O(N).
18. Pre ALGORITHM [TForwardIterator search_n(TForwardIterator First, TForwardIterator Last, Size Count, const TType& Value, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION search_n() prechadza celou COLLECTION definovanou pomocou BEGIN ITERATOR 'First' a poctom ITEMS 'Count' a hlada postupnost 'Count' za sebou iducich  ITEMS, pre ktorych BINARY PREDICATE 'Predicate' vrati TRUE. BINARY PREDICATE ma ako jeden z PARAMETROV PARAMETER 'Value' FUNCTION search_n().
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje pocet ITEMS, ktorych postupnost sa ma vyhladat.
   E. 4. PARAMETER definuje VALUE, ktora sluzi ako PARAMETER do BINARY PREDICATE 'Predicate'.
   !!! F. 5. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na vyhladanie ITEM. BINARY PREDICATE ma 2 PARAMETER, kde 1. PARAMETER obsahuje iterovany ITEM z COLLECTION a 2. PARAMETER obsahuje 4. PARAMETER FUNCTION search_n().
   G. RETURN VALUE je ITERATOR na zaciatok postupnosti 'Count' ITEMS.
   !!! H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item, const TType& Value)]. PARAMETER 'Item' obsahuje iterovany ITEM z COLLECTION. PARAMETER 'Value' obsahuje 4. PARAMETER FUNCTION search_n(). Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   I. Ak sa ITEM nenasiel, FUNCTION search_n() vracia ITERATOR 'Last'.
   J. Zlozitost FUNCTION search_n() je O(N).
19. Pre ALGORITHM [TForwardIterator1 search(TForwardIterator1 First, TForwardIterator1 Last, TForwardIterator2 SearchFirst, TForwardIterator SearchLast)] platia nasledujuce fakty.
   A. FUNCTION search() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada v nej postupnost ITEMS, ktore su LOGICKY ROVNE ITEMS v SEARCH COLLECTION definovanou ITERATOR PAIR <SearchFirst,SearchLast). LOGICKA ROVNOST ITEM z COLLECTION a ITEM zo SEARCH COLLECTION nastava vtedy ak BINARY PREDICATE vracia pre tieto ITEMS TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR SEARCH COLLECTION.
   E. 4. PARAMETER definuje END ITERATOR SEARCH COLLECTION.
   F. RETURN VALUE je ITERATOR na zaciatok postupnosti ITEMS, ktore su rovne SEARCH COLLECTION.
   G. Ak sa postupnost ITEMS nenasla, FUNCTION search() vracia ITERATOR 'Last'.
   H. Zlozitost FUNCTION search() je O(N*SN).
20. Pre ALGORITHM [TForwardIterator1 search(TForwardIterator1 First, TForwardIterator1 Last, TForwardIterator2 SearchFirst, TForwardIterator SearchLast, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION search() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada v nej postupnost ITEMS, pre ktore BINARY PREDICATE vrati TRUE. Ako 2. PARAMETER BINARY PREDICATE sa pouzivaju ITEMS zo SEARCH COLLECTION definovanou ITERATOR PAIR <SearchFirst,SearchLast).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR SEARCH COLLECTION.
   E. 4. PARAMETER definuje END ITERATOR SEARCH COLLECTION.
   !!! F. 5. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na vyhladanie ITEMS. BINARY PREDICATE ma 2 PARAMETER, kde 1. PARAMETER obsahuje iterovany ITEM z COLLECTION a 2. PARAMETER obsahuje iterovany ITEM zo SEARCH COLLECTION.
   G. RETURN VALUE je ITERATOR na zaciatok postupnosti ITEMS, ktore su LOGICKY ROVNE SEARCH COLLECTION na zaklade vyhodnotenia v BINARY PREDICATE.
   !!! H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION. PARAMETER 'Item2' obsahuje ITEROVANY ITEM zo SEARCH COLLECTION. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   I. Ak sa postupnost ITEMS nenasla, FUNCTION search() vracia ITERATOR 'Last'.
   J. Zlozitost FUNCTION search() je O(N*SN).
21. Pre ALGORITHM [TForwardIterator1 find_end(TForwardIterator1 First, TForwardIterator1 Last, TForwardIterator2 SearchFirst, TForwardIterator SearchLast)] platia nasledujuce fakty.
   A. FUNCTION find_end() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada v nej POSLEDNY VYSKYT postupnosti ITEMS, ktore su rovne SEARCH COLLECTION definovanou ITERATOR PAIR <SearchFirst,SearchLast).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR SEARCH COLLECTION.
   E. 4. PARAMETER definuje END ITERATOR SEARCH COLLECTION.
   F. RETURN VALUE je ITERATOR na zaciatok POSLEDNEHO VYSKYTU postupnosti ITEMS, ktore su rovne SEARCH COLLECTION.
   G. Ak sa postupnost ITEMS nenasla, FUNCTION find_end() vracia ITERATOR 'Last'.
   H. Zlozitost FUNCTION find_end() je O(SN*(N-SN+1)).
22. Pre ALGORITHM [TForwardIterator1 find_end(TForwardIterator1 First, TForwardIterator1 Last, TForwardIterator2 SearchFirst, TForwardIterator SearchLast, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION find_end() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada v nej POSLEDNY VYSKYT postupnosti ITEMS, ktore su LOGICKY ROVNE ITEMS v SEARCH COLLECTION definovanou ITERATOR PAIR <SearchFirst,SearchLast). LOGICKA ROVNOST ITEM z COLLECTION a ITEM zo SEARCH COLLECTION nastava vtedy ak BINARY PREDICATE vracia pre tieto ITEMS TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR SEARCH COLLECTION.
   E. 4. PARAMETER definuje END ITERATOR SEARCH COLLECTION.
   !!! F. 5. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na vyhladanie ITEMS. BINARY PREDICATE ma 2 PARAMETER, kde 1. PARAMETER obsahuje iterovany ITEM z COLLECTION a 2. PARAMETER obsahuje iterovany ITEM zo SEARCH COLLECTION.
   G. RETURN VALUE je ITERATOR na zaciatok POSLEDNEHO VYSKYTU postupnosti ITEMS, ktore su LOGICKY ROVNE SEARCH COLLECTION na zaklade vyhodnotenia v BINARY PREDICATE.
   !!! H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION. PARAMETER 'Item2' obsahuje ITEROVANY ITEM zo SEARCH COLLECTION. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   I. Ak sa postupnost ITEMS nenasla, FUNCTION find_end() vracia ITERATOR 'Last'.
   J. Zlozitost FUNCTION find_end() je O(SN*(N-SN+1)).
23. Pre ALGORITHM [TForwardIterator1 find_first_of(TForwardIterator1 First, TForwardIterator1 Last, TForwardIterator2 SearchFirst, TForwardIterator SearchLast)] platia nasledujuce fakty.
   A. FUNCTION find_first_of() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada v nej ITEM, ktoreho VALUE je rovna VALUE niektoreho z ITEMS v SEARCH COLLECTION definovanou ITERATOR PAIR <SearchFirst,SearchLast).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR SEARCH COLLECTION.
   E. 4. PARAMETER definuje END ITERATOR SEARCH COLLECTION.
   F. RETURN VALUE je ITERATOR na ITEM, ktoreho VALUE je rovna VALUE niektoreho z ITEMS v SEARCH COLLECTION.
   G. Ak sa ITEM nenasiel, FUNCTION find_first_of() vracia ITERATOR 'Last'.
   H. Zlozitost FUNCTION find_first_of() je O(N*SN).
24. Pre ALGORITHM [TForwardIterator1 find_first_of(TForwardIterator1 First, TForwardIterator1 Last, TForwardIterator2 SearchFirst, TForwardIterator SearchLast, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION find_end() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada v nej ITEM, ktoreho VALUE je LOGICKY ROVNA VALUE niektoreho z ITEMS v SEARCH COLLECTION definovanou ITERATOR PAIR <SearchFirst,SearchLast). LOGICKA ROVNOST ITEM z COLLECTION a ITEM zo SEARCH COLLECTION nastava vtedy ak BINARY PREDICATE vracia pre tieto ITEMS TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR SEARCH COLLECTION.
   E. 4. PARAMETER definuje END ITERATOR SEARCH COLLECTION.
   !!! F. 5. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na vyhladanie ITEMS. BINARY PREDICATE ma 2 PARAMETER, kde 1. PARAMETER obsahuje iterovany ITEM z COLLECTION a 2. PARAMETER obsahuje iterovany ITEM zo SEARCH COLLECTION.
   G. RETURN VALUE je ITERATOR na ITEM, ktoreho VALUE je LOGICKY ROVNA VALUE niektoreho z ITEMS v SEARCH COLLECTION.
   !!! H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION. PARAMETER 'Item2' obsahuje ITEROVANY ITEM zo SEARCH COLLECTION. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   I. Ak sa ITEM nenasiel, FUNCTION find_first_of() vracia ITERATOR 'Last'.
   J. Zlozitost FUNCTION find_first_of() je O(N*SN).
25. Pre ALGORITHM [TForwardIterator adjacent_find(TForwardIterator First, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION adjacent_find() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada dvojicu ROVNAKYCH ITEMS, ktore nasledujuce za sebou.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. RETURN VALUE je ITERATOR na ITEM, ktoreho VALUE je rovna VALUE nasledujuceho ITEM.
   E. Ak sa postupnost ITEMS nenasla, FUNCTION adjacent_find() vracia ITERATOR 'Last'.
   F. Zlozitost FUNCTION adjacent_find() je O(N).
26. Pre ALGORITHM [TForwardIterator adjacent_find(TForwardIterator First, TForwardIterator Last, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION adjacent_find() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada dvojicu LOGICKY ROVNAKYCH ITEMS, ktore nasledujuce za sebou. ITEMS su LOGICKY ROVNAKE, ak pre ne BINARY PREDICATE 'Predicate' vrati TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na porovnanie ITEMS.
   E. RETURN VALUE je ITERATOR na ITEM, ktoreho VALUE je rovna VALUE nasledujuceho ITEM.
   !!! F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION. PARAMETER 'Item2' obsahuje NASLEDUJUCI ITEM z COLLECTION. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   G. Ak sa ITEM nenasiel, FUNCTION adjacent_find() vracia ITERATOR 'Last'.
   H. Zlozitost FUNCTION adjacent_find() je O(N).
27. Pre ALGORITHM [bool equal(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2)] platia nasledujuce fakty.
   A. FUNCTION equal() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First1,Last1) a zistuje ci je identicka s COLLECTION definovanou BEGIN ITERATOR 'First2'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. RETURN VALUE urcuje ci su COLLECTION 1 a COLLECTION 2 identicke.
   F. Zlozitost FUNCTION equal() je O(N).
28. Pre ALGORITHM [bool equal(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION equal() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First1,Last1) a zistuje ci je LOGICKY IDENTICKA s COLLECTION definovanou BEGIN ITERATOR 'First2'. COLLECTIONS su LOGICKY IDENTICKE ak pre vsetky ITEMS vrati BINARY PREDICATE 'Predicate' TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   !!! E. 4. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na porovnanie ITEMS.
   F. RETURN VALUE urcuje ci su COLLECTION 1 a COLLECTION 2 identicke.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje iterovany ITEM z COLLECTION 2. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   H. Zlozitost FUNCTION equal() je O(N).
29. Pre ALGORITHM [bool equal(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TInputIterator2 Last2)] platia nasledujuce fakty.
   A. FUNCTION equal() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First1,Last1) a zistuje ci je identicka s COLLECTION definovanou pomocou ITERATOR PAIR <First2,Last2).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   F. RETURN VALUE urcuje ci su COLLECTION 1 a COLLECTION 2 identicke.
   G. Zlozitost FUNCTION equal() je O(MIN(N1,N2)).
30. Pre ALGORITHM [bool equal(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TInputIterator2 Last2, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION equal() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First1,Last1) a zistuje ci je LOGICKY IDENTICKA s COLLECTION definovanou pomocou ITERATOR PAIR <First2,Last2). COLLECTIONS su LOGICKY IDENTICKE ak pre vsetky ITEMS vrati BINARY PREDICATE 'Predicate' TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   !!! F. 5. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na porovnanie ITEMS.
   G. RETURN VALUE urcuje ci su COLLECTION 1 a COLLECTION 2 identicke.
   !!! H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje iterovany ITEM z COLLECTION 2. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   I. Zlozitost FUNCTION equal() je O(MIN(N1,N2)).
31. Pre ALGORITHM [bool is_permutation(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2)] platia nasledujuce fakty.
   A. FUNCTION is_permutation() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First1,Last1) a zistuje ci obsahuje ROVNAKE ITEMS, ktore mozu byt v LUBOVOLNOM PORADI ako COLLECTION definovanou BEGIN ITERATOR 'First2'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. RETURN VALUE urcuje ci COLLECTION 1 a COLLECTION 2 obsahuju tie iste ITEMS.
   F. Zlozitost FUNCTION is_permutation() je O(N*N).
32. Pre ALGORITHM [bool is_permutation(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION is_permutation() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First1,Last1) a zistuje ci LOGICKY obsahuje ROVNAKE ITEMS, ktore mozu byt v LUBOVOLNOM PORADI ako COLLECTION definovanou BEGIN ITERATOR 'First2'. COLLECTIONS obsahuju LOGICKY IDENTICKE ITEMS ak pre vsetky ITEMS vrati BINARY PREDICATE 'Predicate' TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   !!! E. 4. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na porovnanie ITEMS.
   F. RETURN VALUE urcuje ci COLLECTION 1 a COLLECTION 2 obsahuju tie iste ITEMS.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje iterovany ITEM z COLLECTION 2. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   H. Zlozitost FUNCTION is_permutation() je O(N*N).
33. Pre ALGORITHM [bool is_permutation(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TInputIterator2 Last2)] platia nasledujuce fakty.
   A. FUNCTION is_permutation() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First1,Last1) a zistuje ci obsahuje ROVNAKE ITEMS, ktore mozu byt v LUBOVOLNOM PORADI ako COLLECTION definovana pomocou ITERATOR PAIR <First2,Last2).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   F. RETURN VALUE urcuje ci COLLECTION 1 a COLLECTION 2 obsahuju tie iste ITEMS.
   G. Zlozitost FUNCTION is_permutation() je O(N*N).
34. Pre ALGORITHM [bool is_permutation(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TInputIterator2 Last2, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION is_permutation() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First1,Last1) a zistuje ci obsahuje LOGICKY ROVNAKE ITEMS, ktore mozu byt v LUBOVOLNOM PORADI ako COLLECTION definovana pomocou ITERATOR PAIR <First2,Last2). COLLECTIONS obsahuju LOGICKY IDENTICKE ITEMS ak pre vsetky ITEMS vrati BINARY PREDICATE 'Predicate' TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   !!! F. 5. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na porovnanie ITEMS.
   G. RETURN VALUE urcuje ci COLLECTION 1 a COLLECTION 2 obsahuju tie iste ITEMS.
   !!! H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje iterovany ITEM z COLLECTION 2. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   I. Zlozitost FUNCTION is_permutation() je O(N*N).
35. Pre ALGORITHM [std::pair<TInputIterator1,TInputIterator2> mismatch(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2)] platia nasledujuce fakty.
   A. FUNCTION mismatch() hlada v COLLECTION 1 definovanou pomocou ITERATOR PAIR <First1,Last1) a COLLECTION 2 definovanou pomocou BEGIN ITERATOR 'First2' PRVU DVOJICU ITEMS, ktore maju ROZDIELNE VALUES.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. RETURN VALUE obsahuje ITERATOR PAIR urcujuci ITEMS, ktore maju v COLLECTION 1 a COLLECTION 2 ROZDIELNE VALUES.
   !!! F. Ak sa ITERATOR PAIR urcujuci ITEMS, ktore maju v COLLECTION 1 a COLLECTION 2 ROZDIELNE VALUES nenasiel, FUNCTION vracia ITERATOR PAIR, kde 1. ITERATOR je rovny PARAMETER 'End1' a 2. ITERATOR je rovny zodpovedajucemu ITERATOR v COLLECTION 2. Ten NEMUSI by rovny END ITERATOR COLLECTION 2, ak COLLECTION 2 je SUPERSET COLLECTION 1.
   F. Zlozitost FUNCTION mismatch() je O(N).
36. Pre ALGORITHM [std::pair<TInputIterator1,TInputIterator2> mismatch(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION mismatch() hlada v COLLECTION 1 definovanou pomocou ITERATOR PAIR <First1,Last1) a COLLECTION 2 definovanou pomocou BEGIN ITERATOR 'First2' PRVU DVOJICU ITEMS, ktore maju LOGICKY ROZDIELNE VALUES. ITEMS maju LOGICKY ROZDIELNE VALUES vtedy ak pre ne BINARY PREDICATE 'Predicate' vrati FALSE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   !!! E. 4. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na porovnanie ITEMS.
   F. RETURN VALUE obsahuje ITERATOR PAIR urcujuci ITEMS, ktore maju v COLLECTION 1 a COLLECTION 2 ROZDIELNE VALUES.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje iterovany ITEM z COLLECTION 2. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   !!! H. Ak sa ITERATOR PAIR urcujuci ITEMS, ktore maju v COLLECTION 1 a COLLECTION 2 ROZDIELNE VALUES nenasiel, FUNCTION vracia ITERATOR PAIR, kde 1. ITERATOR je rovny PARAMETER 'End1' a 2. ITERATOR je rovny zodpovedajucemu ITERATOR v COLLECTION 2. Ten NEMUSI by rovny END ITERATOR COLLECTION 2, ak COLLECTION 2 je SUPERSET COLLECTION 1.
   I. Zlozitost FUNCTION mismatch() je O(N).
37. Pre ALGORITHM [std::pair<TInputIterator1,TInputIterator2> mismatch(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TInputIterator2 Last2)] platia nasledujuce fakty.
   A. FUNCTION mismatch() hlada v COLLECTION 1 definovanou pomocou ITERATOR PAIR <First1,Last1) a COLLECTION 2 definovanou pomocou ITERATOR PAIR <First2,Last2) PRVU DVOJICU ITEMS, ktore maju ROZDIELNE VALUES.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   F. RETURN VALUE obsahuje ITERATOR PAIR urcujuci ITEMS, ktore maju v COLLECTION 1 a COLLECTION 2 ROZDIELNE VALUES.
   !!! G. Ak sa ITERATOR PAIR urcujuci ITEMS, ktore maju v COLLECTION 1 a COLLECTION 2 ROZDIELNE VALUES nenasiel, FUNCTION vracia ITERATOR PAIR, kde 1. ITERATOR je rovny PARAMETER 'End1' a 2. ITERATOR je rovny zodpovedajucemu ITERATOR v COLLECTION 2. Ten NEMUSI by rovny END ITERATOR COLLECTION 2, ak COLLECTION 2 je SUPERSET COLLECTION 1.
   H. Zlozitost FUNCTION mismatch() je O(MIN(N1,N2)).
38. Pre ALGORITHM [std::pair<TInputIterator1,TInputIterator2> mismatch(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TInputIterator2 Last2, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION mismatch() hlada v COLLECTION 1 definovanou pomocou ITERATOR PAIR <First1,Last1) a COLLECTION 2 definovanou pomocou ITERATOR PAIR <First2,Last2) PRVU DVOJICU ITEMS, ktore maju LOGICKY ROZDIELNE VALUES. ITEMS maju LOGICKY ROZDIELNE VALUES vtedy ak pre ne BINARY PREDICATE 'Predicate' vrati FALSE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   !!! F. 5. PARAMETER definuje BINARY PREDICATE, ktory sa pouziva na porovnanie ITEMS.
   G. RETURN VALUE obsahuje ITERATOR PAIR urcujuci ITEMS, ktore maju v COLLECTION 1 a COLLECTION 2 ROZDIELNE VALUES.
   !!! H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje iterovany ITEM z COLLECTION 2. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   !!! I. Ak sa ITERATOR PAIR urcujuci ITEMS, ktore maju v COLLECTION 1 a COLLECTION 2 ROZDIELNE VALUES nenasiel, FUNCTION vracia ITERATOR PAIR, kde 1. ITERATOR je rovny PARAMETER 'End1' a 2. ITERATOR je rovny zodpovedajucemu ITERATOR v COLLECTION 2. Ten NEMUSI by rovny END ITERATOR COLLECTION 2, ak COLLECTION 2 je SUPERSET COLLECTION 1.
   J. Zlozitost FUNCTION mismatch() je O(MIN(N1,N2)).
39. Pre ALGORITHM [bool lexicographical_compare(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TInputIterator2 Last2)] platia nasledujuce fakty.
   A. FUNCTION lexicographical_compare() urcuje ci COLLECTION 1 definovana pomocou ITERATOR PAIR <First1,Last1) je LEXIKOGRAFICKY MENSIA ako COLLECTION 2 definovana pomocou ITERATOR PAIR <First2,Last2).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   !!! F. RETURN VALUE urcuje ci COLLECTION 1 je LEXIKOGRAFICKY MENSIA ako COLLECTION 2.
   !!!!! G. COLLECTION je LEXIKOGRAFICKY MENSIA ak pri postupnom prechadzani oboch COLLECTIONS sa najde prva dvojica ITEMS, ktorych hodnota je (VALUE_1!=VALUE_2 && VALUE_1<VALUE_2). Ak sa ziadna takato dvojica ITEMS nenasla, potom je COLLECTION 1 LEXIKOGRAFICKY MENSIA ako COLLECTION 2 ak COLLECTION 2 obsahuje VIACERO ITEMS. Ak obe COLLECTIONS obsahuju rovnaky pocet ITEMS, potom COLLECTION 1 NIE JE MENSIA ako COLLECTION 2.
   H. Zlozitost FUNCTION lexicographical_compare() je O(2*MIN(N1,N2)).
40. Pre ALGORITHM [bool lexicographical_compare(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TInputIterator2 Last2, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION lexicographical_compare() urcuje ci COLLECTION 1 definovana pomocou ITERATOR PAIR <First1,Last1) je LEXIKOGRAFICKY MENSIA ako COLLECTION 2 definovana pomocou ITERATOR PAIR <First2,Last2). Porovnavanie ITEMS sa vykonava volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   !!! F. 5. PARAMETER definuje FUNCTION OBJECT, ktory sa pouziva na zistenie ci ITEM 1 je MENSI ako ITEM 2.
   !!! G. RETURN VALUE urcuje ci COLLECTION 1 je LEXIKOGRAFICKY MENSIA ako COLLECTION 2.
   !!! H. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje iterovany ITEM z COLLECTION 2. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   !!!!! I. COLLECTION je LEXIKOGRAFICKY MENSIA ak pri postupnom prechadzani oboch COLLECTIONS sa najde prva dvojica ITEMS, ktorych hodnota je (VALUE_1!=VALUE_2 && VALUE_1<VALUE_2). Ak sa ziadna takato dvojica ITEMS nenasla, potom je COLLECTION 1 LEXIKOGRAFICKY MENSIA ako COLLECTION 2 ak COLLECTION 2 obsahuje VIACERO ITEMS. Ak obe COLLECTIONS obsahuju rovnaky pocet ITEMS, potom COLLECTION 1 NIE JE MENSIA ako COLLECTION 2.
   J. Zlozitost FUNCTION lexicographical_compare() je O(2*MIN(N1,N2)).
41. Pre ALGORITHM [bool is_sorted(TForwardIterator First, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION is_sorted() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a zistuje ci je COLLECTION SORTED.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. RETURN VALUE urcuje ci je COLLECTION SORTED.
   E. Zlozitost FUNCTION is_sorted() je O(N).
42. Pre ALGORITHM [bool is_sorted(TForwardIterator First, TForwardIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION is_sorted() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a zistuje ci je COLLECTION SORTED. ITEMS su porovnavane pomocou FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa pouziva na zistenie ci ITEM 1 je MENSI ako ITEM 2.
   E. RETURN VALUE urcuje ci je COLLECTION SORTED.
   !!! F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   G. Zlozitost FUNCTION is_sorted() je O(N).
43. Pre ALGORITHM [TForwardIterator is_sorted_until(TForwardIterator First, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION is_sorted_until() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada PRVY ITEM, ktory NIE JE SORTED.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. RETURN VALUE obsahuje ITERATOR na PRVY ITEM, ktory NIE JE SORTED.
   E. Ak COLLECTION je SORTED FUNCTION is_sorted_until() vracia ITERATOR 'Last'.
   F. Zlozitost FUNCTION is_sorted_until() je O(N).
44. Pre ALGORITHM [TForwardIterator is_sorted_until(TForwardIterator First, TForwardIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION is_sorted_until() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada PRVY ITEM, ktory NIE JE SORTED. ITEMS su porovnavane pomocou FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa pouziva na zistenie ci ITEM 1 je MENSI ako ITEM 2.
   E. RETURN VALUE obsahuje ITERATOR na PRVY ITEM, ktory NIE JE SORTED.
   !!! F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   G. Ak COLLECTION je SORTED FUNCTION is_sorted_until() vracia ITERATOR 'Last'.
   H. Zlozitost FUNCTION is_sorted_until() je O(N).
45. Pre ALGORITHM [bool is_partitioned(TForwardIterator First, TForwardIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION is_partitioned() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a zistuje ci VSETKY ITEMS pre ktore PREDICATE 'Predicate' vrati TRUE sa nachadzaju PRED ITEMS pre ktore PREDICATE 'Predicate' vrati FALSE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa pouziva na zistenie, ktore ITEMS do ktorej PARTITION patria.
   E. RETURN VALUE obsahuje informaciu ci VSETKY ITEMS pre ktore PREDICATE 'Predicate' vrati TRUE sa nachadzaju PRED ITEMS pre ktore PREDICATE 'Predicate' vrati FALSE.
   !!! F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   G. Zlozitost FUNCTION is_partitioned() je O(N).
46. Pre ALGORITHM [TForwardIterator partition_point(TForwardIterator First, TForwardIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   !!! A. FUNCTION partition_point() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada PRVY ITEM pre ktory PREDICATE 'Predicate' vrati FALSE. COLLECTION MUSI BYT PARTITIONED.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa pouziva na zistenie, ktore ITEMS do ktorej PARTITION patria.
   E. RETURN VALUE obsahuje ITERATOR na PRVY ITEM, pre ktory PREDICATE 'Predicate' vratil FALSE.
   !!!!! F. FUNCTION partition_point() VYZADUJE, aby COLLECTION bola PARTITIONED. To znaci, ze VSETKY ITEMS, pre ktore PREDICATE 'Predicate' vrati TRUE sa MUSIA nachadzat PRED ITEMS, pre ktore PREDICATE 'Predicate' vrati FALSE.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   H. Ak COLLECTION NEMA PARTITION POINT FUNCTION partition_point() vracia ITERATOR 'Last'.
   I. Zlozitost FUNCTION partition_point() je O(N), ale pre RANDOM-ACCESS ITERATOR je zlozitost O(LOG(N)).
47. Pre ALGORITHM [bool is_heap(TForwardIterator First, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION is_heap() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a zistuje ci COLLECTION je HEAP.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. RETURN VALUE urcuje ci COLLECTION je HEAP.
   !!!!! E. COLLECTION je HEAP ak plati, ze pre kazdy INDEX 'I' z intervalu <0,Last-First) vrati CODE [OPERATOR<(COLLECTION(FLOOR((I-1)/2)),COLLECTION(I))] hodnotu FALSE.
   F. Zlozitost FUNCTION is_heap() je O(N).
48. Pre ALGORITHM [bool is_heap(TForwardIterator First, TForwardIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION is_heap() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a zistuje ci COLLECTION je HEAP.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa pouziva na zistenie ci ITEM 1 je MENSI ako ITEM 2.
   E. RETURN VALUE urcuje ci COLLECTION je HEAP.
   !!!!! F. COLLECTION je HEAP ak plati, ze pre kazdy INDEX 'I' z intervalu <0,Last-First) vrati CODE [Compare(COLLECTION(FLOOR((I-1)/2)),COLLECTION(I))] hodnotu FALSE.
   !!! G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   H. Zlozitost FUNCTION is_heap() je O(N).
49. Pre ALGORITHM [TRandomAccessIterator is_heap_until(TRandomAccessIterator First, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION is_heap_until() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada POSLEDNY ITEM, ktory je este sucastou HEAP.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. RETURN VALUE obsahuje ITERATOR na POSLEDNY ITEM, ktory je este sucastou HEAP.
   !!!!! E. COLLECTION je HEAP ak plati, ze pre kazdy INDEX 'I' z intervalu <0,Last-First) vrati CODE [OPERATOR<(COLLECTION(FLOOR((I-1)/2)),COLLECTION(I))] hodnotu FALSE.
   F. Zlozitost FUNCTION is_heap() je O(N).
50. Pre ALGORITHM [TRandomAccessIterator is_heap_until(TRandomAccessIterator First, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION is_heap_until() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a hlada PRVY ITEM, ktory uz NIE JE este sucastou HEAP.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa pouziva na zistenie ci ITEM 1 je MENSI ako ITEM 2.
   E. RETURN VALUE obsahuje ITERATOR na PRVY ITEM, ktory uz NIE JE este sucastou HEAP.
   !!!!! F. COLLECTION je HEAP ak plati, ze pre kazdy INDEX 'I' z intervalu <0,Last-First) vrati CODE [Compare(COLLECTION(FLOOR((I-1)/2)),COLLECTION(I))] hodnotu FALSE.
   !!! G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   H. Ak COLLECTION je HEAP FUNCTION is_heap_until() vracia ITERATOR 'Last'.
   I. Zlozitost FUNCTION is_heap_until() je O(N).
51. Pre ALGORITHM [bool all_of(TInputIterator First, TInputIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION all_of() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a zistuje ci pre VSETKY ITEMS vrati PREDICATE 'Predicate' TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa sa vola pre kazdy ITEM.
   E. RETURN VALUE urcuje ci pre KAZDY ITEM v COLLECTION PREDICATE 'Predicate' vratil TRUE.
   !!! F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   G. Zlozitost FUNCTION all_of() je O(N).
52. Pre ALGORITHM [bool any_of(TInputIterator First, TInputIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION any_of() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a zistuje ci pre ASPON JEDEN ITEM vrati PREDICATE 'Predicate' TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa sa vola pre kazdy ITEM.
   E. RETURN VALUE urcuje ci pre ASPON JEDEN ITEM v COLLECTION PREDICATE 'Predicate' vratil TRUE.
   !!! F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   G. Zlozitost FUNCTION any_of() je O(N).
53. Pre ALGORITHM [bool none_of(TInputIterator First, TInputIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION none_of() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a zistuje ci pre ZIADEN ITEM NEVRATI PREDICATE 'Predicate' TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sa sa vola pre kazdy ITEM.
   E. RETURN VALUE urcuje ci pre ZIADEN ITEM v COLLECTION PREDICATE 'Predicate' NEVRATIL TRUE.
   !!! F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   G. Zlozitost FUNCTION none_of() je O(N).
54. Pre ALGORITHM [TOutputIterator copy(TInputIterator First, TInputIterator Last, TOutputIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION copy() kopiruje ITEMS z INPUT COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'DestinationFirst'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! F. OUTPUT COLLECTION sa NESMIE nachadzat v RANGE <First,Last).
   G. Zlozitost FUNCTION copy() je O(N).
55. Pre ALGORITHM [TBidirectionalIterator2 copy_backward(TBidirectionalIterator1 First, TBidirectionalIterator1 Last, TBidirectionalIterator2 DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION copy_backward() kopiruje ITEMS z INPUT COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'DestinationFirst'. Kopirovanie prebieha OD POSLEDNEHO ITEM k PRVEMU ITEM, avsak pozicia ITEMS v OUTPUT COLLECTION je ROVNAKA ako pozicia ITEMS v INPUT COLLECTION.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje END ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! F. OUTPUT COLLECTION sa NESMIE nachadzat v RANGE (First,Last>.
   G. Zlozitost FUNCTION copy_backward() je O(N).
56. Pre ALGORITHM [TOutputIterator copy_n(TInputIterator First, Size Count, TOutputIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION copy_n() kopiruje ITEMS z INPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'First' a poctom ITEMS 'Count' do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'DestinationFirst'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje pocet ITEMS v INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! F. OUTPUT COLLECTION sa NESMIE nachadzat v RANGE <First,First+Count).
   G. Zlozitost FUNCTION copy_n() je O(N).
57. Pre ALGORITHM [TOutputIterator copy_if(TInputIterator First, TInputIterator Last, TOutputIterator DestinationFirst, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION copy_if() kopiruje tie ITEMS z INPUT COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'DestinationFirst' pre ktore PREDICATE 'Predicate' vrati TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! E. 4. PARAMETER definuje FUNCTION OBJECT, ktory urcuje, ktory ITEM sa prekopiruje.
   F. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   !!! H. OUTPUT COLLECTION sa NESMIE nachadzat v RANGE <First,Last).
   I. Zlozitost FUNCTION copy_if() je O(N).
58. Pre ALGORITHM [TOutputIterator move(TInputIterator First, TInputIterator Last, TOutputIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION move() pomocou MOVE SEMANTICS presuva ITEMS z INPUT COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'DestinationFirst'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! F. OUTPUT COLLECTION sa NESMIE nachadzat v RANGE <First,Last).
   G. Zlozitost FUNCTION move() je O(N).
59. Pre ALGORITHM [TBidirectionalIterator2 move_backward(TBidirectionalIterator1 First, TBidirectionalIterator1 Last, TBidirectionalIterator2 DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION move_backward() pomocou MOVE SEMANTICS presuva ITEMS z INPUT COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'DestinationFirst'. Presun ITEMS prebieha OD POSLEDNEHO ITEM k PRVEMU ITEM, avsak pozicia ITEMS v OUTPUT COLLECTION je ROVNAKA ako pozicia ITEMS v INPUT COLLECTION.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje END ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! F. OUTPUT COLLECTION sa NESMIE nachadzat v RANGE (First,Last>.
   G. Zlozitost FUNCTION move_backward() je O(N).
60. Pre ALGORITHM [TOutputIterator transform(TInputIterator First, TInputIterator Last, TOutputIterator DestinationFirst, TUnaryOperation UnaryOperation)] platia nasledujuce fakty.
   A. FUNCTION transform() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a na jednotlive ITEMS aplikuje FUNCTION OBJECT 'UnaryOperation'. Vysledok zapisuje do OUTPUT COLLECTION definovanou pomocou BEGIN ITERATOR 'DestinationFirst'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! E. 4. PARAMETER definuje FUNCTION OBJECT, ktory sa vola pre kazdy ITEM a vysledok ktorej sa zapisuje do OUTPUT COLLECTION.
   F. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! G. FUNCTION OBJECT 'UnaryOperation' ma PROTOTYPE [TReturn UnaryOperation(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'UnaryOperation' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'UnaryOperation' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   H. Zlozitost FUNCTION transform() je O(N).
61. Pre ALGORITHM [TOutputIterator transform(TInputIterator1 First1, TInputIterator1 Last1, TInputIterator2 First2, TOutputIterator DestinationFirst, TBinaryOperation BinaryOperation)] platia nasledujuce fakty.
   A. FUNCTION transform() prechadza INPUT COLLECTION 1 definovanou pomocou ITERATOR PAIR <First1,Last1) a INPUT COLLECTION 2 definovanou pomocou BEGIN ITERATOR 'First2' a na zodpovedajuce DVOJICE ITEMS aplikuje FUNCTION OBJECT 'BinaryOperation'. Vysledok zapisuje do OUTPUT COLLECTION definovanou pomocou BEGIN ITERATOR 'DestinationFirst'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! F. 5. PARAMETER definuje FUNCTION OBJECT, ktory sa vola pre kazdu zodpovedajucu DVOJICU ITEMS a vysledok ktorej sa zapisuje do OUTPUT COLLECTION.
   G. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! H. FUNCTION OBJECT 'BinaryOperation' ma PROTOTYPE [TReturn BinaryOperation(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje iterovany ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje iterovany ITEM z COLLECTION 2. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'BinaryOperation' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'BinaryOperation' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   I. Zlozitost FUNCTION transform() je O(N).
62. Pre ALGORITHM [TForwardIterator2 swap_ranges(TForwardIterator1 First1, TForwardIterator1 Last1, TForwardIterator First2)] platia nasledujuce fakty.
   A. FUNCTION swap_ranges() vymiena ITEMS medzi COLLECTION 1 definovanou pomocou ITERATOR PAIR <First1,Last1) a COLLECTION 2 definovanou pomocou BEGIN ITERATOR 'First2'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. RETURN VALUE obsahuje END ITERATOR COLLECTION 2.
   F. Zlozitost FUNCTION swap_ranges() je O(N).
63. Pre ALGORITHM [void fill(TForwardIterator First, TForwardIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION fill() naplna ITEMS v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) na VALUE 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE, ktora sa nastavi ako VALUE kazdeho ITEM.
   E. Zlozitost FUNCTION fill() je O(N).
64. Pre ALGORITHM [TOutputIterator fill_n(TOutputIterator First, Size Count, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION fill_n() naplna ITEMS v COLLECTION definovanej pomocou BEGIN ITERATOR 'First' a poctom ITEMS 'Count' na VALUE 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER urcuje POCET ITEMS v COLLECTION.
   D. 3. PARAMETER definuje VALUE, ktora sa nastavi ako VALUE kazdeho ITEM.
   E. RETURN VALUE obsahuje END ITERATOR COLLECTION.
   F. Zlozitost FUNCTION fill_n() je O(N).
65. Pre ALGORITHM [void generate(TForwardIterator First, TForwardIterator Last, TGenerator& Generator)] platia nasledujuce fakty.
   A. FUNCTION generate() naplna ITEMS v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) na VALUES, ktore generuje FUNCTION OBJECT 'Generator'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sluzi na generovanie VALUES, ktorymi sa naplnaju ITEMS COLLECTION.
   !!! E. FUNCTION OBJECT 'Generator' ma PROTOTYPE [TReturn Generator(void)].
   F. Zlozitost FUNCTION generate() je O(N).
66. Pre ALGORITHM [TOutputIterator generate_n(TOutputIterator First, Size Count, TGenerator& Generator)] platia nasledujuce fakty.
   A. FUNCTION generate_n() naplna ITEMS v COLLECTION definovanej pomocou BEGIN ITERATOR 'First' a poctom ITEMS 'Count' na VALUES, ktore generuje FUNCTION OBJECT 'Generator'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER urcuje POCET ITEMS v COLLECTION.
   D. 3. PARAMETER definuje FUNCTION OBJECT, ktory sluzi na generovanie VALUES, ktorymi sa naplnaju ITEMS COLLECTION.
   E. RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! F. FUNCTION OBJECT 'Generator' ma PROTOTYPE [TReturn Generator(void)].
   G. Zlozitost FUNCTION generate_n() je O(N).
67. Pre ALGORITHM [void iota(TForwardIterator First, TForwardIterator Last, TType StartValue)] platia nasledujuce fakty.
   A. FUNCTION iota() naplna ITEMS v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) na inkrementalne sa zvysujucu VALUE zacinajucu VALUE 'StartValue'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje BEGIN VALUE, ktora sa nastavi ako 1. ITEM COLLECTION. Dalsie ITEMS budu obsahovat VALUES inkrementalne sa zvysujucej BEGIN VALUE.
   E. Zlozitost FUNCTION iota() je O(N).
68. Pre ALGORITHM [void replace(TForwardIterator First, TForwardIterator Last, const TType& OldValue, const TType& NewValue)] platia nasledujuce fakty.
   A. FUNCTION replace() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a nahradzuje v nej vsetky ITEMS s VALUE 'OldValue' za ITEMS s VALUE 'NewValue'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER obsahuje VALUE, ktora sa ma v COLLECTION nahradit VALUE 'NewValue'.
   E. 4. PARAMETER obsahuje VALUE, ktora ma v COLLECTION sluzit ako nahrada za VALUE 'OldValue'.
   F. Zlozitost FUNCTION replace() je O(N).
69. Pre ALGORITHM [void replace_if(TForwardIterator First, TForwardIterator Last, TUnaryPredicate Predicate, const TType& NewValue)] platia nasledujuce fakty.
   A. FUNCTION replace_if() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a nahradzuje v nej vsetky ITEMS pre ktore PREDICATE 'Predicate' vrati TRUE za ITEMS s VALUE 'NewValue'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje FUNCTION OBJECT, ktory urcuje ktore ITEMS budu v COLLECTION nahradene.
   E. 4. PARAMETER obsahuje VALUE, ktora ma v COLLECTION sluzit ako nahrada za ITEMS pre ktore PREDICATE 'Predicate' vratil TRUE.
   F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   G. Zlozitost FUNCTION replace_if() je O(N).
70. Pre ALGORITHM [TOutputIterator replace_copy(TInputIterator First, TInputIterator Last, TOutputIterator DestinationFirst, const TType& OldValue, const TType& NewValue)] platia nasledujuce fakty.
   A. FUNCTION replace_copy() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a kopiruje jej ITEMS do OUTPUT COLLECTION definovanou POMOCOU BEGIN ITERATOR 'DestinationFirst', pricom pocas kopirovania su v OUTPUT COLLECTION VSETKY ITEMS s VALUE 'OldValue' nahradene za ITEMS s VALUE 'NewValue'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER obsahuje VALUE, ktora sa ma v OUTPUT COLLECTION nahradit VALUE 'NewValue'.
   F. 5. PARAMETER obsahuje VALUE, ktora ma v OUTPUT COLLECTION sluzit ako nahrada za VALUE 'OldValue'.
   G. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   H. Zlozitost FUNCTION replace_copy() je O(N).
71. Pre ALGORITHM [TOutputIterator replace_copy_if(TInputIterator First, TInputIterator Last, TOutputIterator DestinationFirst, TUnaryPredicate Predicate, const TType& NewValue)] platia nasledujuce fakty.
   A. FUNCTION replace_copy_if() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a kopiruje jej ITEMS do OUTPUT COLLECTION definovanou POMOCOU BEGIN ITERATOR 'DestinationFirst', pricom pocas kopirovania su v OUTPUT COLLECTION VSETKY ITEMS pre ktore PREDICATE 'Predicate' vrati TRUE nahradene za ITEMS s VALUE 'NewValue'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER definuje FUNCTION OBJECT, ktory urcuje ktore ITEMS budu v OUTPUT COLLECTION nahradene.
   F. 5. PARAMETER obsahuje VALUE, ktora ma v COLLECTION sluzit ako nahrada za ITEMS pre ktore PREDICATE 'Predicate' vratil TRUE.
   G. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   I. Zlozitost FUNCTION replace_copy_if() je O(N).
72. Pre ALGORITHM [TForwardIterator remove(TForwardIterator First, TForwardIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION remove() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a ODSTRANUJE z nej vsetky ITEMS s VALUE 'Value'. ODSTRANENE ITEMS v skutocnosti NIE SU FYZICKY ODSTRANE z COLLECTION, len PREPISANE tymi ITEMS, ktore NIE SU z COLLECTION ODSTRANENE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER obsahuje VALUE, ktora sa ma z COLLECTION odstranit.
   !!! E. RETURN VALUE obsahuje END ITERATOR LOGICKEJ COLLECTION, ktora vznikla po odstraneni ITEMS.
   !!!!! F. FUNCTION remove() fyzicky NEODSTRANUJE ITEMS z COLLECTION, iba ich presuva tak, aby sa v novej LOGICKEJ COLLECTION definovanej pomocou ITERATOR PAIR <First,RETURN_VALUE) NENACHADZALI.
   G. Poradie ITEMS, ktore NEBOLI PREPISANE ODSTRANOVANIM ITEMS sa NEMENI.
   H. Zlozitost FUNCTION remove() je O(N).
73. Pre ALGORITHM [TForwardIterator remove_if(TForwardIterator First, TForwardIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION remove_if() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a ODSTRANUJE z nej vsetky ITEMS pre ktore FUNCTION OBJECT 'Predicate' vrati TRUE. ODSTRANENE ITEMS v skutocnosti NIE SU FYZICKY ODSTRANE z COLLECTION, len PREPISANE tymi ITEMS, ktore z COLLECTION NIE SU ODSTRANENE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje FUNCTION OBJECT, ktory urcuje ktore ITEMS budu z COLLECTION ODSTRANENE.
   !!! E. RETURN VALUE obsahuje END ITERATOR LOGICKEJ COLLECTION, ktora vznikla po odstraneni ITEMS.
   !!!!! F. FUNCTION remove_if() fyzicky NEODSTRANUJE ITEMS z COLLECTION, iba ich presuva tak, aby sa v novej LOGICKEJ COLLECTION definovanej pomocou ITERATOR PAIR <First,RETURN_VALUE) NENACHADZALI.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   !!! H. FUNCTION OBJECT 'Predicate' NESMIE MENIT svoj VNUTORNY STATE, pretoze FUNCTION remove_if() si vytvara je KOPIU FUNCTION OBJECT a okrem toho ju moze VOLAT VIACKRAT pri odstranovani 1 ITEM. Interny STATE by preto mohol narusit konzistenciu FUNCTION remove_if().
   I. Poradie ITEMS, ktore NEBOLI PREPISANE ODSTRANOVANIM ITEMS sa NEMENI.
   J. Zlozitost FUNCTION remove_if() je O(N).
74. Pre ALGORITHM [TForwardIterator remove_copy(TForwardIterator First, TForwardIterator Last, TOutputIterator DestinationFirst, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION remove_copy() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a do OUTPUT COLLECTION kopiruje ITEMS, ktorych VALUE sa NEROVNA PARAMETER 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER obsahuje VALUE, ktora sa NEMA do OUTPUT COLLECTION kopirovat.
   !!! F. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   G. Zlozitost FUNCTION remove_copy() je O(N).
75. Pre ALGORITHM [TForwardIterator remove_copy_if(TForwardIterator First, TForwardIterator Last, TOutputIterator DestinationFirst, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION remove_copy_if() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a do OUTPUT COLLECTION kopiruje ITEMS, pre ktore PREDICATE 'Predicate' vrati FALSE.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER definuje FUNCTION OBJECT, ktory urcuje ktore ITEMS sa NEMAJU KOPIROVAT do OUTPUT COLLECTION.
   !!! F. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   !!! H. FUNCTION OBJECT 'Predicate' NESMIE MENIT svoj VNUTORNY STATE, pretoze FUNCTION remove_copy_if() si vytvara je KOPIU FUNCTION OBJECT a okrem toho ju moze VOLAT VIACKRAT pri odstranovani 1 ITEM. Interny STATE by preto mohol narusit konzistenciu FUNCTION remove_copy_if().
   I. Zlozitost FUNCTION remove_copy_if() je O(N).
76. Pre ALGORITHM [TForwardIterator unique(TForwardIterator First, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION unique() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a ODSTRANUJE z nej vsetky ITEMS, ktore sa v COLLECTION nachadzaju ZA SEBOU a maju ROVNAKU VALUE. ODSTRANENE ITEMS v skutocnosti NIE SU FYZICKY ODSTRANE z COLLECTION, len PREPISANE tymi ITEMS, ktore NIE SU z COLLECTION ODSTRANENE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. RETURN VALUE obsahuje END ITERATOR LOGICKEJ COLLECTION, ktora vznikla po odstraneni ITEMS.
   !!!!! E. FUNCTION unique() fyzicky NEODSTRANUJE ITEMS z COLLECTION, iba ich presuva tak, aby sa v novej LOGICKEJ COLLECTION definovanej pomocou ITERATOR PAIR <First,RETURN_VALUE) NENACHADZALI.
   F. Poradie ITEMS, ktore NEBOLI PREPISANE ODSTRANOVANIM ITEMS sa NEMENI.
   G. Zlozitost FUNCTION unique() je O(N).
77. Pre ALGORITHM [TForwardIterator unique(TForwardIterator First, TForwardIterator Last, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION unique() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a ODSTRANUJE z nej vsetky ITEMS, ktore sa v COLLECTION nachadzaju ZA SEBOU a pre ktore BINARY PREDICATE 'Predicate' vrati TRUE. ODSTRANENE ITEMS v skutocnosti NIE SU FYZICKY ODSTRANE z COLLECTION, len PREPISANE tymi ITEMS, ktore NIE SU z COLLECTION ODSTRANENE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. 3. PARAMETER definuje FUNCTION OBJECT, ktory urcuje ktore ITEMS budu z COLLECTION ODSTRANENE. V BINARY PREDICATE sa porovnava VALUE aktualneho ITEM a POSLEDNEHO NEODSTRANENEHO ITEM.
   !!! E. RETURN VALUE obsahuje END ITERATOR LOGICKEJ COLLECTION, ktora vznikla po odstraneni ITEMS.
   !!!!! F. FUNCTION unique() fyzicky NEODSTRANUJE ITEMS z COLLECTION, iba ich presuva tak, aby sa v novej LOGICKEJ COLLECTION definovanej pomocou ITERATOR PAIR <First,RETURN_VALUE) NENACHADZALI.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType1& Item1, const TType2& Item2)]. PARAMETER 'Item1' obsahuje POSLEDNY ITEM z COLLECTION, ktory NEBOL ODSTRANENY. PARAMETER 'Item2' obsahuje ITEROVANY ITEM z COLLECTION. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   !!! H. FUNCTION OBJECT 'Predicate' NESMIE MENIT svoj VNUTORNY STATE.
   I. Poradie ITEMS, ktore NEBOLI PREPISANE ODSTRANOVANIM ITEMS sa NEMENI.
   J. Zlozitost FUNCTION unique() je O(N).
78. Pre ALGORITHM [TOutputIterator unique_copy(TInputIterator First, TInputIterator Last, TInputIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION unique_copy() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a do OUTPUT COLLECTION definovanou pomocou BEGIN ITERATOR 'DestinationFirst' kopiruje vsetkty ITEMS pre ktore plati, ze VALUE daneho ITEM NIE JE ROVNA VALUE POSLEDNEHO NEODSTRANENEHO ITEM.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   F. Zlozitost FUNCTION unique_copy() je O(N).
79. Pre ALGORITHM [TOutputIterator unique_copy(TInputIterator First, TInputIterator Last, TInputIterator DestinationFirst, TBinaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION unique_copy() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a do OUTPUT COLLECTION definovanou pomocou BEGIN ITERATOR 'DestinationFirst' kopiruje vsetkty ITEMS OKREM TYCH pre ktore plati, ze pre VALUE daneho ITEM a VALUE POSLEDNEHO PREKOPIROVANEHO ITEM vrati BINARY PREDICATE 'Predicate' TRUE.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! E. 4. PARAMETER definuje FUNCTION OBJECT, ktory urcuje ktore ITEMS NEBUDE prekopirovane do OUTPUT COLLECTION. V BINARY PREDICATE sa porovnava VALUE aktualneho ITEM a POSLEDNEHO NEODSTRANENEHO ITEM.
   !!! F. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! G. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType1& Item1, const TType2& Item2)]. PARAMETER 'Item1' obsahuje POSLEDNY ITEM z COLLECTION, ktory NEBOL ODSTRANENY. PARAMETER 'Item2' obsahuje ITEROVANY ITEM z COLLECTION. Kedze ITEMS su prenesane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZU VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETERS, ktorych VALUES by sa vsak NEMALI MENIT.
   !!! H. FUNCTION OBJECT 'Predicate' NESMIE MENIT svoj VNUTORNY STATE.
   I. Zlozitost FUNCTION unique_copy() je O(N).
80. Pre ALGORITHM [void reverse(TBidirectionalIterator First, TBidirectionalIterator Last)] platia nasledujuce fakty.
   A. FUNCTION reverse() obracia ITEMS v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) tak, aby boli ulozene odzadu dopredu.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. Zlozitost FUNCTION reverse() je O(N/2).
81. Pre ALGORITHM [TOutputIterator reverse_copy(TBidirectionalIterator First, TBidirectionalIterator Last, TOutputIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION reverse_copy() kopiruje ITEMS z INPUT COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) do OUTPUT COLLECTION definovanou pomocou BEGIN ITERATOR 'DestinationFirst' v OBRATENOM PORADI v akom su v INPUT COLLECTION.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   F. Zlozitost FUNCTION reverse_copy() je O(N).
82. Pre ALGORITHM [TForwardIterator rotate(TForwardIterator First, TForwardIterator NewFirst, TForwardIterator Last)] platia nasledujuce fakty.
   A. FUNCTION rotate() rotuje ITEMS v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) tak, aby COLLECTION mala ako 1. ITEM ten ITEM na ktory ukazuje ITERATOR 'NewFirst'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje ITERATOR urcujuci NOVY BEGIN ITERATOR rotovanej COLLECTION.
   D. 3. PARAMETER definuje END ITERATOR COLLECTION.
   !!! E. RETURN VALUE obsahuje ITERATOR na POVODNY BEGIN ITERATOR COLLECTION.
   F. Zlozitost FUNCTION rotate() je O(N).
83. Pre ALGORITHM [TOutputIterator rotate_copy(TForwardIterator First, TForwardIterator NewFirst, TForwardIterator Last, TOutputIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION rotate_copy() kopiruje ITEMS z INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) do OUTPUT COLLECTION definovnou pomocou BEGIN ITERATOR 'DestinationFirst' tak, aby OUTPUT COLLECTION zacinala ITEM na ktory odkazuje ITERATOR 'DestinationFirst'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje ITERATOR urcujuci NOVY BEGIN ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   E. 4. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   !!! F. RETURN VALUE obsahuje END ITERATOR na OUTPUT COLLECTION.
   G. Zlozitost FUNCTION rotate_copy() je O(N).
84. Pre ALGORITHM [bool next_permutation(TBidirectionalIterator First, TBidirectionalIterator Last)] platia nasledujuce fakty.
   A. FUNCTION next_permutation() presuva ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) tak, aby vytvarali NASLEDUJUCU PERMUTATION ITEMS.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. RETURN VALUE obsahuje informaciu ci NASLEDUJUCU PERMUTATION je mozne vykonat.
   E. Zlozitost FUNCTION next_permutation() je O(N/2).
85. Pre ALGORITHM [bool next_permutation(TBidirectionalIterator First, TBidirectionalIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION next_permutation() presuva ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) tak, aby vytvarali NASLEDUJUCU PERMUTATION ITEMS. Na porovnavanie ITEMS pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!! E. RETURN VALUE obsahuje informaciu ci NASLEDUJUCU PERMUTATION je mozne vykonat.
   F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Left, const TType& Right)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Left' a NON-CONST PARAMETER 'Right', ktorych VALUES by sa vsak NEMALI MENIT.
   G. Zlozitost FUNCTION next_permutation() je O(N/2).
86. Pre ALGORITHM [bool prev_permutation(TBidirectionalIterator First, TBidirectionalIterator Last)] platia nasledujuce fakty.
   A. FUNCTION prev_permutation() presuva ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) tak, aby vytvali PREDCHADZAJUCU PERMUTATION ITEMS.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. RETURN VALUE obsahuje informaciu ci PREDCHADZAJUCU PERMUTATION je mozne vykonat.
   E. Zlozitost FUNCTION prev_permutation() je O(N/2).
87. Pre ALGORITHM [bool prev_permutation(TBidirectionalIterator First, TBidirectionalIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION prev_permutation() presuva ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) tak, aby vytvali PREDCHADZAJUCU PERMUTATION ITEMS. Na porovnavanie ITEMS pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!! E. RETURN VALUE obsahuje informaciu ci PREDCHADZAJUCU PERMUTATION je mozne vykonat.
   F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Left, const TType& Right)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Left' a NON-CONST PARAMETER 'Right', ktorych VALUES by sa vsak NEMALI MENIT.
   G. Zlozitost FUNCTION prev_permutation() je O(N/2).
88. Pre ALGORITHM [void shuffle(TRandomAccessIterator First, TRandomAccessIterator Last, TUniformRandomNumberGenerator&& Generator)] platia nasledujuce fakty.
   A. FUNCTION shuffle() pretriedi ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) tak, aby ITEMS boli ulozene v NAHODNOM PORADI, ktore urcuje FUNCTION OBJECT 'Generator'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje UNIFORM NUMBER RANDOM GENERATOR, ktory sa pouziva na urcenie pozicie jednotlivych ITEMS.
   E. Zlozitost FUNCTION shuffle() je O(N).
89. Pre ALGORITHM [TForwardIterator partition(TForwardIterator First, TForwardIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION partition() pretriedi ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) tak, aby ITEMS pre ktore PREDICATE 'Predicate' vrati TRUE sa nachadzali PRED ITEMS, pre ktore PREDICATE 'Predicate' vrati FALSE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje FUNCTION OBJECT urcujuci ktore ITEMS budu presunute na zaciatok a ktore na koniec COLLECTION.
   !!! E. RETURN VALUE obsahuje ITERATOR na PRVY ITEM pre ktory PREDICATE 'Predicate' vratil FALSE.
   F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   !!! G. RELATIVNE poradie ITEMS v 1. a 2. GROUP voci POVODNEMU poradiu ITEMS NIE JE ZACHOVANE.
   H. Zlozitost FUNCTION partition() je O(N).
90. Pre ALGORITHM [TBidirectionalIterator stable_partition(TBidirectionalIterator First, TBidirectionalIterator Last, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION stable_partition() pretriedi ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) tak, aby ITEMS pre ktore PREDICATE 'Predicate' vrati TRUE sa nachadzali PRED ITEMS, pre ktore PREDICATE 'Predicate' vrati FALSE.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje FUNCTION OBJECT urcujuci ktore ITEMS budu presunute na zaciatok a ktore na koniec COLLECTION.
   !!! E. RETURN VALUE obsahuje ITERATOR na PRVY ITEM pre ktory PREDICATE 'Predicate' vratil FALSE.
   F. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   !!! G. RELATIVNE poradie ITEMS v 1. a 2. GROUP voci POVODNEMU poradiu ITEMS JE ZACHOVANE.
   H. Zlozitost FUNCTION stable_partition() je O(N).
91. Pre ALGORITHM [pair<TOutputIterator1,TOutputIterator2> partition_copy(TInputIterator First, TInputIterator Last, TOutputIterator1 DestinationFirst1, TOutputIterator1 DestinationFirst2, TUnaryPredicate Predicate)] platia nasledujuce fakty.
   A. FUNCTION partition_copy() prechadza vsetkymi ITEMS v INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) pricom ITEMS pre ktore PREDICATE 'Predicate' vratil TRUE kopiruje do OUTPUT COLLECTION 1 definovanou pomocou BEGIN ITERATOR 'DestinationFirst1' a ITEMS pre ktore PREDICATE 'Predicate' vratil FALSE kopiruje do OUTPUT COLLECTION 2 definovanou pomocou BEGIN ITERATOR 'DestinationFirst2'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION 1.
   E. 4. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION 2.
   F. 5. PARAMETER definuje FUNCTION OBJECT urcujuci ktore ITEMS budu presunute co OUTPUT COLLECTION 1 a ktore budu presunute do OUTPUT COLLECTION 2.
   !!! G. RETURN VALUE obsahuje ITERATOR PAIR, kde 1. ITEM obsahuje END ITERATOR OUTPUT COLLECTION 1 a 2. ITEM obsahuje END ITERATOR OUTPUT COLLECTION 2.
   H. FUNCTION OBJECT 'Predicate' ma PROTOTYPE [bool Predicate(const TType& Item)]. Kedze ITEM je prenasany ako CONST REFERENCE, znamena to, ze FUNCTION OBJECT 'Predicate' NEMOZE VALUE daneho ITEM MODIFIKOVAT. FUNCTION OBJECT 'Predicate' moze mat aj NON-CONST PARAMETER 'Item', ktoreho VALUE by sa vsak NEMALA MENIT.
   I. Zlozitost FUNCTION partition_copy() je O(N).
92. Pre ALGORITHM [void sort(TRandomAccessIterator First, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION sort() robi SORTING ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   E. Poradie ITEMS s ROVNAKOU VALUE NIE JE ZACHOVANE.
   F. Zlozitost FUNCTION sort() je O(N*LOG(N)).
93. Pre ALGORITHM [void sort(TRandomAccessIterator First, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION sort() robi SORTING ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!! E. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   G. Poradie ITEMS s ROVNAKOU VALUE NIE JE ZACHOVANE.
   H. Zlozitost FUNCTION sort() je O(N*LOG(N)).
94. Pre ALGORITHM [void stable_sort(TRandomAccessIterator First, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION stable_sort() robi SORTING ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   !!!! E. Poradie ITEMS s ROVNAKOU VALUE JE ZACHOVANE.
   F. Zlozitost FUNCTION stable_sort() je O(N*LOG(N)*LOG(N)).
95. Pre ALGORITHM [void stable_sort(TRandomAccessIterator First, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION stable_sort() robi SORTING ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!! E. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!! G. Poradie ITEMS s ROVNAKOU VALUE JE ZACHOVANE.
   H. Zlozitost FUNCTION stable_sort() je O(N*LOG(N)*LOG(N)).
96. Pre ALGORITHM [void partial_sort(TRandomAccessIterator First, TRandomAccessIterator Middle, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION partial_sort() robi SORTING prvych (Middle-First) ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje ITERATOR po ktory ITEMS maju byt SORTED.
   D. 3. PARAMETER definuje END ITERATOR COLLECTION.
   !!! E. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. Poradie ITEMS s ROVNAKOU VALUE NIE JE ZACHOVANE.
   G. Zlozitost FUNCTION partial_sort() je O(N*LOG(MIDDLE-FIRST)).
97. Pre ALGORITHM [void partial_sort(TRandomAccessIterator First, TRandomAccessIterator Middle, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION partial_sort() robi SORTING prvych (Middle-First) ITEMS v COLLECTION definovanou pomocou ITERATOR PAIR <First,Last). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje ITERATOR po ktory ITEMS maju byt SORTED.
   D. 3. PARAMETER definuje END ITERATOR COLLECTION.
   E. 4. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!! F. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. Poradie ITEMS s ROVNAKOU VALUE NIE JE ZACHOVANE.
   I. Zlozitost FUNCTION partial_sort() je O(N*LOG(MIDDLE-FIRST)).
98. Pre ALGORITHM [TRandomAccessIterator partial_sort_copy(TInputIterator First, TInputIterator Last, TRandomAccessIterator DestinationFirst, TRandomAccessIterator DestinationLast)] platia nasledujuce fakty.
   A. FUNCTION partial_sort_copy() robi SORTING ITEMS z INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) pricom vysledok SORTING uklada do OUTPUT COLLECTION definovanou pomocou ITERATOR PAIR <DestinationFirst,DestinationLast). Pocet ITEMS, ktore budu SORTED je rovny MIN((Last-First),(DestinationLast-DestinationFirst)).
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER definuje END ITERATOR OUTPUT COLLECTION.
   F. RETURN VALUE obsahuje ITERATOR na POSLEDNY PREKOPIROVANY ITEM v OUTPUT COLLECTION.
   !!! G. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   H. Poradie ITEMS s ROVNAKOU VALUE NIE JE ZACHOVANE.
   I. Zlozitost FUNCTION partial_sort_copy() je O(N*LOG(MIN((LAST-FIRST),(DESTINATION_LAST-DESTINATION_FIRST)))).
99. Pre ALGORITHM [TRandomAccessIterator partial_sort_copy(TInputIterator First, TInputIterator Last, TRandomAccessIterator DestinationFirst, TRandomAccessIterator DestinationLast, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION partial_sort_copy() robi SORTING ITEMS z INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) pricom vysledok SORTING uklada do OUTPUT COLLECTION definovanou pomocou ITERATOR PAIR <DestinationFirst,DestinationLast). Pocet ITEMS, ktore budu SORTED je rovny MIN((Last-First),(DestinationLast-DestinationFirst)). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER definuje END ITERATOR OUTPUT COLLECTION.
   F. 5. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   G. RETURN VALUE obsahuje ITERATOR na POSLEDNY PREKOPIROVANY ITEM v OUTPUT COLLECTION.
   !!! H. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   I. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   J. Poradie ITEMS s ROVNAKOU VALUE NIE JE ZACHOVANE.
   K. Zlozitost FUNCTION partial_sort_copy() je O(N*LOG(MIN((LAST-FIRST),(DESTINATION_LAST-DESTINATION_FIRST)))).
100. Pre ALGORITHM [void nth_element(TRandomAccessIterator First, TRandomAccessIterator NthElement, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION nth_element() robi SORTING ITEMS v INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) pricom vsak ITEMS NIE SU KOMPLETNE SORTED iba plati, ze ITEM na ktory ukazuje PARAMETER 'NthElement' bude na spravnej pozicii ako keby bola cela COLLECTION SORTED a zaroven ITEMS PRED tymto ITEM maju MENSIE VALUES a ITEMS ZA tymto ITEM maju MENSIE VALUES. ITEMS v oboch logickych GROUPS vsak NIE SU SORTED.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje ITERATOR na ITEM, ktory MUSI byt SORTED tak ako keby bola cela COLLECTION SORTED.
   D. 3. PARAMETER definuje END ITERATOR COLLECTION.
   !!! E. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. Zlozitost FUNCTION nth_element() je O(N).
101. Pre ALGORITHM [void nth_element(TRandomAccessIterator First, TRandomAccessIterator NthElement, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION nth_element() robi SORTING ITEMS v INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) pricom vsak ITEMS NIE SU KOMPLETNE SORTED iba plati, ze ITEM na ktory ukazuje PARAMETER 'NthElement' bude na spravnej pozicii ako keby bola cela COLLECTION SORTED a zaroven ITEMS PRED tymto ITEM maju MENSIE VALUES a ITEMS ZA tymto ITEM maju MENSIE VALUES. ITEMS v oboch logickych GROUPS vsak NIE SU SORTED. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje ITERATOR na ITEM, ktory MUSI byt SORTED tak ako keby bola cela COLLECTION SORTED.
   D. 3. PARAMETER definuje END ITERATOR COLLECTION.
   E. 4. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!! F. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. Zlozitost FUNCTION nth_element() je O(N).
102. Pre ALGORITHM [void make_heap(TRandomAccessIterator First, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION make_heap() prechadza celu COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) vytvarajuc z nej MAX HEAP.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)].
   !!! E. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. Zlozitost FUNCTION make_heap() je O(3*N).
103. Pre ALGORITHM [void make_heap(TRandomAccessIterator First, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION make_heap() prechadza celu COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) vytvarajuc z nej MAX HEAP. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   E. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)].
   !!! F. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. Zlozitost FUNCTION make_heap() je O(3*N).
104. Pre ALGORITHM [void push_heap(TRandomAccessIterator First, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION push_heap() v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) premiestni ITEM na pozicii (Last-1) tak, aby COLLECTION bola MAX HEAP.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!!!! D. FUNCTION push_heap() realne umiestni ITEM, ktory bol predtym vlozeny na KONIEC COLLECTION tak, aby COLLECTION znova splnala kriteria pre MAX HEAP.
   E. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)].
   !!! F. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. Zlozitost FUNCTION push_heap() je O(LOG(N)).
105. Pre ALGORITHM [void push_heap(TRandomAccessIterator First, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION push_heap() v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) premiestni ITEM na pozicii (Last-1) tak, aby COLLECTION bola MAX HEAP. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!!!! E. FUNCTION push_heap() realne umiestni ITEM, ktory bol predtym vlozeny na KONIEC COLLECTION tak, aby COLLECTION znova splnala kriteria pre MAX HEAP.
   F. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)].
   !!! G. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   H. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   I. Zlozitost FUNCTION push_heap() je O(LOG(N)).
106. Pre ALGORITHM [void pop_heap(TRandomAccessIterator First, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION pop_heap() v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) premiestni ITEM z pozicie 'First' na KONIEC COLLECTION, pricom nad COLLECTION <First,Last-1) vykona SORTING, aby COLLECTION bola MAX HEAP.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!!!! D. FUNCTION pop_heap() realne odstrani FIRST ITEM jeho presunom na koniec, pricom nad zbytok COLLECTION vykona SORTING, aby splnala kriteria pre MAX HEAP.
   E. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)].
   !!! F. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. Zlozitost FUNCTION pop_heap() je O(2*LOG(N)).
107. Pre ALGORITHM [void pop_heap(TRandomAccessIterator First, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION pop_heap() v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) premiestni ITEM z pozicie 'First' na KONIEC COLLECTION, pricom nad COLLECTION <First,Last-1) vykona SORTING, aby COLLECTION bola MAX HEAP. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!!!! E. FUNCTION pop_heap() realne odstrani FIRST ITEM jeho presunom na koniec, pricom nad zbytok COLLECTION vykona SORTING, aby splnala kriteria pre MAX HEAP.
   F. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)].
   !!! G. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   H. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   I. Zlozitost FUNCTION pop_heap() je O(2*LOG(N)).
108. Pre ALGORITHM [void sort_heap(TRandomAccessIterator First, TRandomAccessIterator Last)] platia nasledujuce fakty.
   A. FUNCTION sort_heap() v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last), ktora tvori MAX HEAP vykona SORTING ITEM, pricom COLLECTION po vykonani SORTING uz NIE JE MAX HEAP.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   !!! D. Na porovnavanie ITEMS sa pouziva OPERATOR<, ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   E. Zlozitost FUNCTION sort_heap() je O(2*N*LOG(N)).
109. Pre ALGORITHM [void sort_heap(TRandomAccessIterator First, TRandomAccessIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION sort_heap() v COLLECTION definovanej pomocou ITERATOR PAIR <First,Last), ktora tvori MAX HEAP vykona SORTING ITEM, pricom COLLECTION po vykonani SORTING uz NIE JE MAX HEAP. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!! E. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   G. Zlozitost FUNCTION sort_heap() je O(2*N*LOG(N)).
110. Pre ALGORITHM [bool binary_search(TForwardIterator First, TForwardIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION binary_search() v SORTED COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) zistuje ci sa v nej nachadza ITEM s VALUE 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE, ktora sa ma v COLLECTION najst.
   E. RETURN VALUE obsahuje informaciu ci sa ITEM s VALUE 'Value' podarilo v COLLECTION najst.
   !!! F. COLLECTION MUSI byt SORTED.
   G. Zlozitost FUNCTION binary_search() je O(LOG(N)) pre RANDOM ACCESS ITERATORS a O(N) pre ostatne typy ITERATORS.
111. Pre ALGORITHM [bool binary_search(TForwardIterator First, TForwardIterator Last, const TType& Value, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION binary_search() v SORTED COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) zistuje ci sa v nej nachadza ITEM s VALUE 'Value'. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE, ktora sa ma v COLLECTION najst.
   E. 4. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   F. RETURN VALUE obsahuje informaciu ci sa ITEM s VALUE 'Value' podarilo v COLLECTION najst.
   !!! G. COLLECTION MUSI byt SORTED.
   !!! H. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   I. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   J. Zlozitost FUNCTION binary_search() je O(LOG(N)) pre RANDOM ACCESS ITERATORS a O(N) pre ostatne typy ITERATORS.
112. Pre ALGORITHM [bool includes(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2)] platia nasledujuce fakty.
   A. FUNCTION includes() v SORTED COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) zistuje ci obsahuje VSETKY ITEMS SORTED COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   F. RETURN VALUE obsahuje informaciu ci sa COLLECTION 1 obsahuje VSETKY ITEMS z COLLECTION 2.
   !!!!! G. Ak COLLECTION 2 obsahuje ITEM s ROVANKOU VALUE 'N' krat, potom aj COLLECTION 1 MUSI obsahovat aspon 'N' ITEMS s danou VALUE.
   !!! H. Obe COLLECTIONS MUSIA byt SORTED podla ROVNAKYCH KRITERII.
   I. Zlozitost FUNCTION includes() je O(2*(N1+N2-1)).
113. Pre ALGORITHM [bool includes(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION includes() v SORTED COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) zistuje ci obsahuje VSETKY ITEMS SORTED COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR COLLECTION 2.
   F. 5. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTIONS.
   G. RETURN VALUE obsahuje informaciu ci sa COLLECTION 1 obsahuje VSETKY ITEMS z COLLECTION 2.
   !!! H. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   I. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. PARAMETER 'Item1' obsahuje ITEM z COLLECTION 1. PARAMETER 'Item2' obsahuje ITEM z COLLECTION 2. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!!!! J. Ak COLLECTION 2 obsahuje ITEM s ROVANKOU VALUE 'N' krat, potom aj COLLECTION 1 MUSI obsahovat aspon 'N' ITEMS s danou VALUE.
   !!! K. Obe COLLECTIONS MUSIA byt SORTED podla ROVNAKYCH KRITERII.
   L. Zlozitost FUNCTION includes() je O(2*(N1+N2-1)).
114. Pre ALGORITHM [TForwardIterator lower_bound(TForwardIterator First, TForwardIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION lower_bound() v SORTED COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) hlada PRVY ITEM, ktore VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE ku ktorej sa ma najst ITEM, ktoreho VALUE by bola VACSIA, alebo ROVNA ako PARAMETER 'Value'.
   E. RETURN VALUE obsahuje ITERATOR na ITEM, ktoreho VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value'.
   !!! F. Ak sa hladany ITEM NENASIEL, RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! G. COLLECTION MUSI byt SORTED.
   H. Zlozitost FUNCTION lower_bound() je O(LOG2(N)+O(1)) pre RANDOM ACCESS ITERATORS a O(N) pre NON-RANDOM ITERATORS.
115. Pre ALGORITHM [TForwardIterator lower_bound(TForwardIterator First, TForwardIterator Last, const TType& Value, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION lower_bound() v SORTED COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) hlada PRVY ITEM, ktore VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value'. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE ku ktorej sa ma najst ITEM, ktoreho VALUE by bola VACSIA, alebo ROVNA ako PARAMETER 'Value'.
   E. 4. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   F. RETURN VALUE obsahuje ITERATOR na ITEM, ktoreho VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value'.
   !!! G. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   H. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!! I. Ak sa hladany ITEM NENASIEL, RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! J. COLLECTION MUSI byt SORTED.
   K. Zlozitost FUNCTION lower_bound() je O(LOG2(N)+O(1)) pre RANDOM ACCESS ITERATORS a O(N) pre NON-RANDOM ITERATORS.
116. Pre ALGORITHM [TForwardIterator upper_bound(TForwardIterator First, TForwardIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION upper_bound() v SORTED COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) hlada PRVY ITEM, ktore VALUE je VACSIA ako VALUE PARAMETER 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE ku ktorej sa ma najst ITEM, ktoreho VALUE by bola VACSIA ako PARAMETER 'Value'.
   E. RETURN VALUE obsahuje ITERATOR na ITEM, ktoreho VALUE je VACSIA ako VALUE PARAMETER 'Value'.
   !!! F. Ak sa hladany ITEM NENASIEL, RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! G. COLLECTION MUSI byt SORTED.
   H. Zlozitost FUNCTION upper_bound() je O(LOG2(N)+O(1)) pre RANDOM ACCESS ITERATORS a O(N) pre NON-RANDOM ITERATORS.
117. Pre ALGORITHM [TForwardIterator upper_bound(TForwardIterator First, TForwardIterator Last, const TType& Value, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION upper_bound() v SORTED COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) hlada PRVY ITEM, ktore VALUE je VACSIA ako VALUE PARAMETER 'Value'. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE ku ktorej sa ma najst ITEM, ktoreho VALUE by bola VACSIA ako PARAMETER 'Value'.
   E. 4. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   F. RETURN VALUE obsahuje ITERATOR na ITEM, ktoreho VALUE je VACSIA ako VALUE PARAMETER 'Value'.
   !!! G. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   H. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!! I. Ak sa hladany ITEM NENASIEL, RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! J. COLLECTION MUSI byt SORTED.
   K. Zlozitost FUNCTION upper_bound() je O(LOG2(N)+O(1)) pre RANDOM ACCESS ITERATORS a O(N) pre NON-RANDOM ITERATORS.
118. Pre ALGORITHM [pair<TForwardIterator,TForwardIterator> equal_range(TForwardIterator First, TForwardIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION equal_range() v SORTED COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) hlada ITERATOR PAIR, kde PRVY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value' a DRUHY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA ako VALUE PARAMETER 'Value'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE ku ktorej sa ma najst ITERATOR PAIR, kde PRVY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value' a DRUHY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA ako VALUE PARAMETER 'Value'.
   E. RETURN VALUE obsahuje ITERATOR PAIR, kde PRVY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value' a DRUHY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA ako VALUE PARAMETER 'Value'.
   !!! F. Ak ITEM, ktoreho VALUE by bola VACSIA, alebo ROVNA ako PARAMETER 'Value' NENASIEL, PRVY ITERATOR v RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! G. Ak ITEM, ktoreho VALUE by bola VACSIA ako PARAMETER 'Value' NENASIEL, DRUHY ITERATOR v RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! H. COLLECTION MUSI byt SORTED.
   H. Zlozitost FUNCTION equal_range() je O(2*LOG2(N)+O(1)) pre RANDOM ACCESS ITERATORS a O(N) pre NON-RANDOM ITERATORS.
119. Pre ALGORITHM [pair<TForwardIterator,TForwardIterator> equal_range(TForwardIterator First, TForwardIterator Last, const TType& Value, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION equal_range() v SORTED COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) hlada ITERATOR PAIR, kde PRVY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value' a DRUHY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA ako VALUE PARAMETER 'Value'. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE ku ktorej sa ma najst ITERATOR PAIR, kde PRVY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value' a DRUHY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA ako VALUE PARAMETER 'Value'.
   E. 4. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   F. RETURN VALUE obsahuje ITERATOR PAIR, kde PRVY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA, alebo ROVNA ako VALUE PARAMETER 'Value' a DRUHY ITERATOR odkazuje na PRVY ITEM, ktore VALUE je VACSIA ako VALUE PARAMETER 'Value'.
   !!! G. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   H. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!! I. Ak ITEM, ktoreho VALUE by bola VACSIA, alebo ROVNA ako PARAMETER 'Value' NENASIEL, PRVY ITERATOR v RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! J. Ak ITEM, ktoreho VALUE by bola VACSIA ako PARAMETER 'Value' NENASIEL, DRUHY ITERATOR v RETURN VALUE obsahuje END ITERATOR COLLECTION.
   !!! K. COLLECTION MUSI byt SORTED.
   L. Zlozitost FUNCTION equal_range() je O(2*LOG2(N)+O(1)) pre RANDOM ACCESS ITERATORS a O(N) pre NON-RANDOM ITERATORS.
120. Pre ALGORITHM [TOutputIterator merge(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst)] platia nasledujuce fakty.
   A. FUNCTION merge() vykonava MERGING SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2) a ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! H. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   I. Zlozitost FUNCTION merge() je O(N1+N2-1).
121. Pre ALGORITHM [TOutputIterator merge(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION merge() vykonava MERGING SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2) a ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. 6. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   H. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! I. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   J. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!! K. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   L. Zlozitost FUNCTION merge() je O(N1+N2-1).
122. Pre ALGORITHM [TOutputIterator set_union(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst)] platia nasledujuce fakty.
   A. FUNCTION set_union() vykonava UNION SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2) a ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. Ak sa v niektorej COLLECTION ITEM s rovnakou VALUE nachadza VIACKRAT, potom v OUTPUT COLLECTION sa nachadza tento ITEM 'N' krat, kde N=MAX(POCET_VYSKYTOV_ITEM_V_COLLECTION1,POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!!!! H. Ak sa v niektorej COLLECTION ITEM s rovnakou VALUE nachadza VIACKRAT, potom v OUTPUT COLLECTION sa nachadza tento ITEM 'N' krat, kde N=MAX(POCET_VYSKYTOV_ITEM_V_COLLECTION1,POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   !!! I. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   J. Zlozitost FUNCTION set_union() je O(2*(N1+N2-1)).
123. Pre ALGORITHM [TOutputIterator set_union(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION set_union() vykonava UNION SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2) a ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. Ak sa v niektorej COLLECTION ITEM s rovnakou VALUE nachadza VIACKRAT, potom v OUTPUT COLLECTION sa nachadza tento ITEM 'N' krat, kde N=MAX(POCET_VYSKYTOV_ITEM_V_COLLECTION1,POCET_VYSKYTOV_ITEM_V_COLLECTION2). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. 6. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   H. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! I. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   J. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!!!! K. Ak sa v niektorej COLLECTION ITEM s rovnakou VALUE nachadza VIACKRAT, potom v OUTPUT COLLECTION sa nachadza tento ITEM 'N' krat, kde N=MAX(POCET_VYSKYTOV_ITEM_V_COLLECTION1,POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   !!! L. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   M. Zlozitost FUNCTION set_union() je O(2*(N1+N2-1)).
124. Pre ALGORITHM [TOutputIterator set_intersection(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst)] platia nasledujuce fakty.
   A. FUNCTION set_intersection() vykonava INTERSECTION SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2) a ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. Ak sa v niektorej COLLECTION ITEM s rovnakou VALUE nachadza VIACKRAT, potom v OUTPUT COLLECTION sa nachadza tento ITEM 'N' krat, kde N=MIN(POCET_VYSKYTOV_ITEM_V_COLLECTION1,POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!!!! H. Ak sa v niektorej COLLECTION ITEM s rovnakou VALUE nachadza VIACKRAT, potom v OUTPUT COLLECTION sa nachadza tento ITEM 'N' krat, kde N=MIN(POCET_VYSKYTOV_ITEM_V_COLLECTION1,POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   !!! I. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   J. Zlozitost FUNCTION set_intersection() je O(2*(N1+N2-1)).
125. Pre ALGORITHM [TOutputIterator set_intersection(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION set_intersection() vykonava INTERSECTION SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2) a ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. Ak sa v niektorej COLLECTION ITEM s rovnakou VALUE nachadza VIACKRAT, potom v OUTPUT COLLECTION sa nachadza tento ITEM 'N' krat, kde N=MIN(POCET_VYSKYTOV_ITEM_V_COLLECTION1,POCET_VYSKYTOV_ITEM_V_COLLECTION2). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. 6. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   H. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! I. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   J. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!!!! K. Ak sa v niektorej COLLECTION ITEM s rovnakou VALUE nachadza VIACKRAT, potom v OUTPUT COLLECTION sa nachadza tento ITEM 'N' krat, kde N=MIN(POCET_VYSKYTOV_ITEM_V_COLLECTION1,POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   !!! L. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   M. Zlozitost FUNCTION set_intersection() je O(2*(N1+N2-1)).
126. Pre ALGORITHM [TOutputIterator set_difference(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst)] platia nasledujuce fakty.
   A. FUNCTION set_difference() od SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) LOGICKY ODCITA ITEMS v SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2). ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. LOGICKE ODCITANIE znamena, ze do OUTPUT COLLECTION sa zaradzuju IBA tie ITEMS, ktore sa nachadzaju v INPUT COLLECTION 1 a ZAROVEN sa NENACHADZAJU v INPUT COLLECTION 2. Ak sa v INPUT COLLECTION 1 aj INPUT COLLECTION 2 nachadza VIACERO ITEMS s ROVNAKOU VALUE, potom sa dany ITEM sa v OUTPUT COLLECTION nachadza 'N' krat, kde N=MAX(0,MIN(POCET_VYSKYTOV_ITEM_V_COLLECTION1-POCET_VYSKYTOV_ITEM_V_COLLECTION2)).
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!!!! H. Ak sa v INPUT COLLECTION 1 aj INPUT COLLECTION 2 nachadza VIACERO ITEMS s ROVNAKOU VALUE, potom sa dany ITEM v OUTPUT COLLECTION nachadza 'N' krat, kde N=MAX(0,MIN(POCET_VYSKYTOV_ITEM_V_COLLECTION1-POCET_VYSKYTOV_ITEM_V_COLLECTION2)).
   !!! I. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   J. Zlozitost FUNCTION set_difference() je O(2*(N1+N2-1)).
127. Pre ALGORITHM [TOutputIterator set_difference(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION set_difference() od SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) LOGICKY ODCITA ITEMS v SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2). ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. LOGICKE ODCITANIE znamena, ze do OUTPUT COLLECTION sa zaradzuju IBA tie ITEMS, ktore sa nachadzaju v INPUT COLLECTION 1 a ZAROVEN sa NENACHADZAJU v INPUT COLLECTION 2. Ak sa v INPUT COLLECTION 1 aj INPUT COLLECTION 2 nachadza VIACERO ITEMS s ROVNAKOU VALUE, potom sa dany ITEM sa v OUTPUT COLLECTION nachadza 'N' krat, kde N=MAX(0,MIN(POCET_VYSKYTOV_ITEM_V_COLLECTION1-POCET_VYSKYTOV_ITEM_V_COLLECTION2)). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. 6. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   H. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! I. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   J. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!!!! K. Ak sa v INPUT COLLECTION 1 aj INPUT COLLECTION 2 nachadza VIACERO ITEMS s ROVNAKOU VALUE, potom sa dany ITEM v OUTPUT COLLECTION nachadza 'N' krat, kde N=MAX(0,MIN(POCET_VYSKYTOV_ITEM_V_COLLECTION1-POCET_VYSKYTOV_ITEM_V_COLLECTION2)).
   !!! L. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   M. Zlozitost FUNCTION set_difference() je O(2*(N1+N2-1)).
128. Pre ALGORITHM [TOutputIterator set_symmetric_difference(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst)] platia nasledujuce fakty.
   A. FUNCTION set_symmetric_difference() zo SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2) vybera tie ITEMS, ktore sa nachadzaju v JEDNEJ z NICH, ale NIE v OBOCH z NICH. ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. Ak sa v INPUT COLLECTION 1 aj INPUT COLLECTION 2 nachadza VIACERO ITEMS s ROVNAKOU VALUE, potom sa dany ITEM sa v OUTPUT COLLECTION nachadza 'N' krat, kde N=ABS(POCET_VYSKYTOV_ITEM_V_COLLECTION1-POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!!!! H. Ak sa v INPUT COLLECTION 1 aj INPUT COLLECTION 2 nachadza VIACERO ITEMS s ROVNAKOU VALUE, potom sa dany ITEM sa v OUTPUT COLLECTION nachadza 'N' krat, kde N=ABS(POCET_VYSKYTOV_ITEM_V_COLLECTION1-POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   !!! I. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   J. Zlozitost FUNCTION set_symmetric_difference() je O(2*(N1+N2-1)).
129. Pre ALGORITHM [TOutputIterator set_symmetric_difference(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TInputIterator Last2, TOutputIterator OutputFirst, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION set_symmetric_difference() zo SORTED INPUT COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <First2,Last2) vybera tie ITEMS, ktore sa nachadzaju v JEDNEJ z NICH, ale NIE v OBOCH z NICH. ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou BEGIN ITERATOR 'OutputFirst'. Ak sa v INPUT COLLECTION 1 aj INPUT COLLECTION 2 nachadza VIACERO ITEMS s ROVNAKOU VALUE, potom sa dany ITEM sa v OUTPUT COLLECTION nachadza 'N' krat, kde N=ABS(POCET_VYSKYTOV_ITEM_V_COLLECTION1-POCET_VYSKYTOV_ITEM_V_COLLECTION2). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 2.
   E. 4. PARAMETER definuje END ITERATOR INPUT COLLECTION 2.
   F. 5. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   G. 6. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   H. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   !!! I. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   J. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!!!! K. Ak sa v INPUT COLLECTION 1 aj INPUT COLLECTION 2 nachadza VIACERO ITEMS s ROVNAKOU VALUE, potom sa dany ITEM sa v OUTPUT COLLECTION nachadza 'N' krat, kde N=ABS(POCET_VYSKYTOV_ITEM_V_COLLECTION1-POCET_VYSKYTOV_ITEM_V_COLLECTION2).
   !!! L. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   M. Zlozitost FUNCTION set_symmetric_difference() je O(2*(N1+N2-1)).
130. Pre ALGORITHM [void inplace_merge(TBidirectionalIterator First, TBidirectionalIterator Middle, TBidirectionalIterator Last)] platia nasledujuce fakty.
   A. FUNCTION inplace_merge() vykonava MERGING INPUT SORTED COLLECTION 1 definovanej pomocou ITERATOR PAIR <First,Middle) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <Middle,Last), pricom ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou ITERATOR PAIR <First,Last).
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1, ktory je zaroven BEGIN ITERATOR OUTPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1, ktory je zaroven BEGIN ITERATOR INPUT COLLECTION 2.
   D. 3. PARAMETER definuje END ITERATOR INPUT COLLECTION 2, ktory je zaroven END ITERATOR OUTPUT COLLECTION.
   !!! E. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   F. Zlozitost FUNCTION inplace_merge() je O(N-1), ak je dostatok MEMORY, alebo O(N*LOG(N)) ak nie je mozne alokovat dostatocnu MEMORY.
131. Pre ALGORITHM [void inplace_merge(TBidirectionalIterator First, TBidirectionalIterator Middle, TBidirectionalIterator Last, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION inplace_merge() vykonava MERGING INPUT SORTED COLLECTION 1 definovanej pomocou ITERATOR PAIR <First,Middle) a SORTED INPUT COLLECTION 2 definovanej pomocou ITERATOR PAIR <Middle,Last), pricom ITEMS vyslednej COLLECTION zapisuje do OUTPUT COLLECTION definovanej pomocou ITERATOR PAIR <First,Last). ITEMS su porovnane volanim FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION 1, ktory je zaroven BEGIN ITERATOR OUTPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION 1, ktory je zaroven BEGIN ITERATOR INPUT COLLECTION 2.
   D. 3. PARAMETER definuje END ITERATOR INPUT COLLECTION 2, ktory je zaroven END ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS v COLLECTION.
   !!! F. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   !!! H. OBE INPUT COLLECTIONS MUSIA byt SORTED a SORTED je aj OUTPUT COLLECION.
   I. Zlozitost FUNCTION inplace_merge() je O(N-1), ak je dostatok MEMORY, alebo O(N*LOG(N)) ak nie je mozne alokovat dostatocnu MEMORY.
132. Pre ALGORITHM [TType accumulate(TInputIterator First, TInputIterator Last, TType Value)] platia nasledujuce fakty.
   A. FUNCTION accumulate() vykonava operaciu [RETURN_VALUE=INITIAL_VALUE+ITEM_1+ ... +ITEM_N], kde ITEM_1 az ITEM_N su ITEMS z COLLECTION definovanej pomocou ITERATOR PAIR <First,Last).
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje INITIAL VALUE pre operaciu [RETURN_VALUE=INITIAL_VALUE+ITEM_1+ ... +ITEM_N].
   E. RETURN VALUE obsahuje hodnotu operacie [RETURN_VALUE=INITIAL_VALUE+ITEM_1+ ... +ITEM_N].
   F. FUNCTION je definovana v LIBRARY <numeric>.
   G. Zlozitost FUNCTION accumulate() je O(N).
133. Pre ALGORITHM [TType accumulate(TInputIterator First, TInputIterator Last, TType Value, TBinaryOperation Operation)] platia nasledujuce fakty.
   A. FUNCTION accumulate() vykonava operaciu [RETURN_VALUE=INITIAL_VALUE OPERATION ITEM_1 OPERATION ... OPERATION ITEM_N], kde ITEM_1 az ITEM_N su ITEMS z COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) a OPERATION je volanie FUNCTION OBJECT 'Operation'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje INITIAL VALUE pre operaciu [RETURN_VALUE=INITIAL_VALUE OPERATION ITEM_1 OPERATION ... OPERATION ITEM_N], kde ITEM_1 az ITEM_N su ITEMS z COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) a OPERATION je FUNCTION OBJECT 'Operation'.
   E. 4. PARAMETER definuje BINARY OPERATION, ktora sa aplikuje medzi INITIAL VALUE a VALUES vsetkych ITEMS v COLLECTION.
   F. RETURN VALUE obsahuje hodnotu operacie [RETURN_VALUE=INITIAL_VALUE OPERATION ITEM_1 OPERATION ... OPERATION ITEM_N], kde ITEM_1 az ITEM_N su ITEMS z COLLECTION definovanej pomocou ITERATOR PAIR <First,Last) a OPERATION je FUNCTION OBJECT 'Operation'.
   G. FUNCTION OBJECT 'Operation' ma PROTOTYPE [TType Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Operation' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Operation' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. FUNCTION je definovana v LIBRARY <numeric>.
   I. Zlozitost FUNCTION accumulate() je O(N).
134. Pre ALGORITHM [TType inner_product(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TType Value)] platia nasledujuce fakty.
   A. FUNCTION inner_product() vykonava operaciu [RETURN_VALUE=INITIAL_VALUE+(ITEM_1_1*ITEM_2_1)+ ... +(ITEM_1_N*ITEM_2_N)], kde ITEM_1_1 az ITEM_1_N su ITEMS z COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1) a ITEM_2_1 az ITEM_2_N su ITEMS z COLLECTION 2 definovanej pomocou BEGIN ITERATOR 'First2'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje INITIAL VALUE operaciu [RETURN_VALUE=INITIAL_VALUE+(ITEM_1_1*ITEM_2_1)+ ... +(ITEM_1_N*ITEM_2_N)].
   F. RETURN VALUE obsahuje vysledok operacie [RETURN_VALUE=INITIAL_VALUE+(ITEM_1_1*ITEM_2_1)+ ... +(ITEM_1_N*ITEM_2_N)].
   G. FUNCTION je definovana v LIBRARY <numeric>.
   H. Zlozitost FUNCTION inner_product() je O(N).
135. Pre ALGORITHM [TType inner_product(TInputIterator First1, TInputIterator Last1, TInputIterator First2, TType Value, TBinaryOperation1 Operation1, TBinaryOperation2 Operation2)] platia nasledujuce fakty.
   A. FUNCTION inner_product() vykonava operaciu [RETURN_VALUE=INITIAL_VALUE OPERATION_1 (ITEM_1_1 OPERATION_2 ITEM_2_1) OPERATION_1 ... OPERATION_1 (ITEM_1_N OPERATION_2 ITEM_2_N)], kde ITEM_1_1 az ITEM_1_N su ITEMS z COLLECTION 1 definovanej pomocou ITERATOR PAIR <First1,Last1), ITEM_2_1 az ITEM_2_N su ITEMS z COLLECTION 2 definovanej pomocou BEGIN ITERATOR 'First2', OPERATION_1 je volanie FUNCTION OBJECT 'Operation1' a OPERATION_2 je volanie FUNCTION OBJECT 'Operation2'.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION 1.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION 1.
   D. 3. PARAMETER definuje BEGIN ITERATOR COLLECTION 2.
   E. 4. PARAMETER definuje INITIAL VALUE pre operaciu [RETURN_VALUE=INITIAL_VALUE OPERATION_1 (ITEM_1_1 OPERATION_2 ITEM_2_1) OPERATION_1 ... OPERATION_1 (ITEM_1_N OPERATION_2 ITEM_2_N)].
   F. 5. PARAMETER definuje BINARY OPERATION, ktora sa aplikuje medzi INITIAL VALUE a VALUES, ktore vzniknu po aplikacii FUNCTION OBJECT 'Operation2' medzi vsetkymi ITEM PAIRS oboch COLLECTIONS.
   G. 6. PARAMETER definuje BINARY OPERATION, ktora sa aplikuje medzi vsetkymi ITEM PAIRS oboch COLLECTIONS.
   H. RETURN VALUE obsahuje vysledok operacie [RETURN_VALUE=INITIAL_VALUE OPERATION_1 (ITEM_1_1 OPERATION_2 ITEM_2_1) OPERATION_1 ... OPERATION_1 (ITEM_1_N OPERATION_2 ITEM_2_N)].
   I. FUNCTION OBJECT 'Operation1' ma PROTOTYPE [TType Operation1(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Operation1' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Operation1' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   J. FUNCTION OBJECT 'Operation2' ma PROTOTYPE [TType Operation2(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Operation2' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Operation2' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   K. FUNCTION je definovana v LIBRARY <numeric>.
   L. Zlozitost FUNCTION inner_product() je O(N).
136. Pre ALGORITHM [TOutputIterator partial_sum(TInputIterator First, TInputIterator Last, TInputIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION partial_sum() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a do kazdeho ITEM v OUTPUT COLLECTION definovanou BEGIN ITERATOR 'DestinationFirst' zapisuje vysledok operacie [OUTPUT_ITEM_N=INPUT_ITEM_1+...+INPUT_ITEM_N].
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   F. FUNCTION je definovana v LIBRARY <numeric>.
   G. Zlozitost FUNCTION partial_sum() je O(N-1).
137. Pre ALGORITHM [TOutputIterator partial_sum(TInputIterator First, TInputIterator Last, TInputIterator DestinationFirst, TBinaryOperation Operation)] platia nasledujuce fakty.
   A. FUNCTION partial_sum() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a do kazdeho ITEM v OUTPUT COLLECTION definovanou BEGIN ITERATOR 'DestinationFirst' zapisuje vysledok operacie [OUTPUT_ITEM_N=INPUT_ITEM_1 OPERATION ... OPERATION INPUT_ITEM_N], kde OPERATION je volanie FUNCTION OBJECT 'Operation'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER definuje BINARY OPERATION, ktora sa aplikuje medzi jednotlivymi ITEMS v COLLECTION.
   F. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   G. FUNCTION OBJECT 'Operation' ma PROTOTYPE [TType Operation1(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Operation' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Operation' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. FUNCTION je definovana v LIBRARY <numeric>.
   I. Zlozitost FUNCTION partial_sum() je O(N-1).
138. Pre ALGORITHM [TOutputIterator adjacent_difference(TInputIterator First, TInputIterator Last, TInputIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION adjacent_difference() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a do kazdeho ITEM v OUTPUT COLLECTION definovanou BEGIN ITERATOR 'DestinationFirst' zapisuje vysledok operacie [OUTPUT_ITEM_N=INPUT_ITEM_N-INPUT_ITEM_N_MINUS_1]. Do 1. ITEM OUTPUT COLLECTION je zapisany ITEM na ktory odkazuje ITERATOR 'First'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   F. FUNCTION je definovana v LIBRARY <numeric>.
   G. Zlozitost FUNCTION adjacent_difference() je O(N-1).
139. Pre ALGORITHM [TOutputIterator adjacent_difference(TInputIterator First, TInputIterator Last, TInputIterator DestinationFirst, TBinaryOperation Operation)] platia nasledujuce fakty.
   A. FUNCTION adjacent_difference() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last) a do kazdeho ITEM v OUTPUT COLLECTION definovanou BEGIN ITERATOR 'DestinationFirst' zapisuje vysledok operacie [OUTPUT_ITEM_N=INPUT_ITEM_N OPERATION INPUT_ITEM_N_MINUS_1], kde OPERATION je volanie FUNCTION OBJECT 'Operation'. Do 1. ITEM OUTPUT COLLECTION je zapisany ITEM na ktory odkazuje ITERATOR 'First'.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. 4. PARAMETER definuje BINARY OPERATION, ktora sa aplikuje medzi jednotlivymi ITEMS v COLLECTION.
   F. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   G. FUNCTION OBJECT 'Operation' ma PROTOTYPE [TType Operation1(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Operation' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Operation' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. FUNCTION je definovana v LIBRARY <numeric>.
   I. Zlozitost FUNCTION adjacent_difference() je O(N-1).
140. Pre ALGORITHM [TForwardIterator uninitialized_copy(TInputIterator First, TInputIterator Last, TForwardIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION uninitialized_copy() prechadza celou INPUT COLLECTION definovanou pomocou ITERATOR PAIR <First,Last), pricom jednotlive ITEMS kopriuje do OUTPUT COLLECTION definovanou pomocou BEGIN ITERATOR 'DestinationFirst'. OUTPUT COLLECTION reprezentuje UNINITIALIZED MEMORY.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   F. Zlozitost FUNCTION uninitialized_copy() je O(N).
141. Pre ALGORITHM [TForwardIterator uninitialized_copy_n(TInputIterator First, Size Count, TForwardIterator DestinationFirst)] platia nasledujuce fakty.
   A. FUNCTION uninitialized_copy_n() prechadza celou INPUT COLLECTION definovanou BEGIN ITERATOR 'First' a poctom ITEMS 'Count', pricom jednotlive ITEMS kopriuje do OUTPUT COLLECTION definovanou pomocou BEGIN ITERATOR 'DestinationFirst'. OUTPUT COLLECTION reprezentuje UNINITIALIZED MEMORY.
   B. 1. PARAMETER definuje BEGIN ITERATOR INPUT COLLECTION.
   C. 2. PARAMETER definuje POCET ITEMS INPUT COLLECTION.
   D. 3. PARAMETER definuje BEGIN ITERATOR OUTPUT COLLECTION.
   E. RETURN VALUE obsahuje END ITERATOR OUTPUT COLLECTION.
   F. Zlozitost FUNCTION uninitialized_copy_n() je O(N).
142. Pre ALGORITHM [void uninitialized_fill(TInputIterator First, TInputIterator Last, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION uninitialized_fill() prechadza celou COLLECTION definovanou pomocou ITERATOR PAIR <First,Last), pricom do jednotlive ITEMS zapisuje VALUE 'Value'. OUTPUT COLLECTION reprezentuje UNINITIALIZED MEMORY.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE, ktora sa ma zapisat do ITEMS COLLECTION.
   E. Zlozitost FUNCTION uninitialized_fill() je O(N).
143. Pre ALGORITHM [void uninitialized_fill_n(TInputIterator First, Size Count, const TType& Value)] platia nasledujuce fakty.
   A. FUNCTION uninitialized_fill_n() prechadza celou COLLECTION definovanou BEGIN ITERATOR 'First' a poctom ITEMS 'Count', pricom do jednotlive ITEMS zapisuje VALUE 'Value'. OUTPUT COLLECTION reprezentuje UNINITIALIZED MEMORY.
   B. 1. PARAMETER definuje BEGIN ITERATOR COLLECTION.
   C. 2. PARAMETER definuje END ITERATOR COLLECTION.
   D. 3. PARAMETER definuje VALUE, ktora sa ma zapisat do ITEMS COLLECTION.
   E. Zlozitost FUNCTION uninitialized_fill_n() je O(N).
144. Pre ALGORITHM [void swap(TType& Value1, TType& Value2) noexcept] platia nasledujuce fakty.
   A. FUNCTION swap() vymiena obsah VALUE 'Value1' a VALUE 'Value2'.
   B. 1. PARAMETER obsahuje REFERENCE na VALUE 1.
   C. 2. PARAMETER obsahuje REFERENCE na VALUE 2.
   D. Zlozitost FUNCTION swap() je O(1).
145. Pre ALGORITHM [void swap(TType (&Array1)[SIZE], TType (&Array2)[SIZE]) noexcept] platia nasledujuce fakty.
   A. FUNCTION swap() vymiena obsah ARRAY 'Array1' a ARRAY 'Array2'.
   B. 1. PARAMETER obsahuje REFERENCE na ARRAY 1.
   C. 2. PARAMETER obsahuje REFERENCE na ARRAY 2.
   D. Zlozitost FUNCTION swap() je O(N).
146. Pre ALGORITHM [void iter_swap(TForwardIterator Iterator1, TForwardIterator Iterator2)] platia nasledujuce fakty.
   A. FUNCTION iter_swap() vymiena obsah VALUE na ktory odkazuje ITERATOR 'Iterator1' a obsah VALUE na ktory odkazuje ITERATOR 'Iterator2'.
   B. 1. PARAMETER obsahuje ITERATOR na VALUE 1.
   C. 2. PARAMETER obsahuje ITERATOR na VALUE 2.
   D. Zlozitost FUNCTION iter_swap() je O(1).
147. Pre ALGORITHM [constexpr const TType& min(const TType& Value1, const TType& Value2)] platia nasledujuce fakty.
   A. FUNCTION min() vracia MINIMALNU VALUE z VALUE 'Value1' a VALUE 'Value2'.
   B. 1. PARAMETER obsahuje CONST REFERENCE na VALUE 1.
   C. 2. PARAMETER obsahuje CONST REFERENCE na VALUE 2.
   D. RETURN VALUE obsahuje MINIMALNU VALUE z dvojice VALUES.
   E. Zlozitost FUNCTION min() je O(1).
148. Pre ALGORITHM [constexpr const TType& min(const TType& Value1, const TType& Value2, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION min() vracia MINIMALNU VALUE z VALUE 'Value1' a VALUE 'Value2'. Na porovnanie ITEMS sa pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER obsahuje CONST REFERENCE na VALUE 1.
   C. 2. PARAMETER obsahuje CONST REFERENCE na VALUE 2.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS.
   E. RETURN VALUE obsahuje MINIMALNU VALUE z dvojice VALUES.
   !!! F. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. Zlozitost FUNCTION min() je O(1).
149. Pre ALGORITHM [constexpr TType min(initializer_list<TType> List)] platia nasledujuce fakty.
   A. FUNCTION min() vracia MINIMALNU VALUE z INITIALIZER LIST.
   B. PARAMETER obsahuje INITIALIZER LIST.
   C. RETURN VALUE obsahuje MINIMALNU VALUE z INITIALIZER LIST.
   D. Zlozitost FUNCTION min() je O(N-1).
150. Pre ALGORITHM [constexpr TType min(initializer_list<TType> List, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION min() vracia MINIMALNU VALUE z INITIALIZER LIST. Na porovnanie ITEMS sa pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER obsahuje INITIALIZER LIST.
   C. 2. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS.
   D. RETURN VALUE obsahuje MINIMALNU VALUE z INITIALIZER LIST.
   !!! E. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   G. Zlozitost FUNCTION min() je O(N-1).
151. Pre ALGORITHM [constexpr const TType& max(const TType& Value1, const TType& Value2)] platia nasledujuce fakty.
   A. FUNCTION max() vracia MAXIMALNU VALUE z VALUE 'Value1' a VALUE 'Value2'.
   B. 1. PARAMETER obsahuje CONST REFERENCE na VALUE 1.
   C. 2. PARAMETER obsahuje CONST REFERENCE na VALUE 2.
   D. RETURN VALUE obsahuje MAXIMALNU VALUE z dvojice VALUES.
   E. Zlozitost FUNCTION max() je O(1).
152. Pre ALGORITHM [constexpr const TType& max(const TType& Value1, const TType& Value2, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION max() vracia MAXIMALNU VALUE z VALUE 'Value1' a VALUE 'Value2'. Na porovnanie ITEMS sa pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER obsahuje CONST REFERENCE na VALUE 1.
   C. 2. PARAMETER obsahuje CONST REFERENCE na VALUE 2.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS.
   E. RETURN VALUE obsahuje MAXIMALNU VALUE z dvojice VALUES.
   !!! F. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. Zlozitost FUNCTION max() je O(1).
153. Pre ALGORITHM [constexpr TType max(initializer_list<TType> List)] platia nasledujuce fakty.
   A. FUNCTION max() vracia MAXIMALNU VALUE z INITIALIZER LIST.
   B. PARAMETER obsahuje INITIALIZER LIST.
   C. RETURN VALUE obsahuje MAXIMALNU VALUE z INITIALIZER LIST.
   D. Zlozitost FUNCTION max() je O(N-1).
154. Pre ALGORITHM [constexpr TType max(initializer_list<TType> List, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION max() vracia MAXIMALNU VALUE z INITIALIZER LIST. Na porovnanie ITEMS sa pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER obsahuje INITIALIZER LIST.
   C. 2. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS.
   D. RETURN VALUE obsahuje MAXIMALNU VALUE z INITIALIZER LIST.
   !!! E. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   G. Zlozitost FUNCTION max() je O(N-1).
155. Pre ALGORITHM [constexpr pair<const TType&,const TType&> minmax(const TType& Value1, const TType& Value2)] platia nasledujuce fakty.
   A. FUNCTION minmax() vracia z VALUE 'Value1' a VALUE 'Value2' PAIR, ktoreho 1. ITEM obsahuje MINIMALNU VALUE a 2. ITEM obsahuje MAXIMALNU VALUE.
   B. 1. PARAMETER obsahuje CONST REFERENCE na VALUE 1.
   C. 2. PARAMETER obsahuje CONST REFERENCE na VALUE 2.
   D. RETURN VALUE obsahuje PAIR, kde 1. ITEM obsahuje MINIMALNU VALUE a 2. ITEM obsahuje MAXIMALNU VALUE.
   E. Zlozitost FUNCTION minmax() je O(1).
156. Pre ALGORITHM [constexpr pair<const TType&,const TType&> minmax(const TType& Value1, const TType& Value2, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION minmax() vracia z VALUE 'Value1' a VALUE 'Value2' PAIR, ktoreho 1. ITEM obsahuje MINIMALNU VALUE a 2. ITEM obsahuje MAXIMALNU VALUE. Na porovnanie ITEMS sa pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER obsahuje CONST REFERENCE na VALUE 1.
   C. 2. PARAMETER obsahuje CONST REFERENCE na VALUE 2.
   D. 3. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS.
   E. RETURN VALUE obsahuje PAIR, kde 1. ITEM obsahuje MINIMALNU VALUE a 2. ITEM obsahuje MAXIMALNU VALUE.
   !!! F. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   G. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   H. Zlozitost FUNCTION minmax() je O(1).
157. Pre ALGORITHM [constexpr pair<TType,TType> minmax(initializer_list<TType> List)] platia nasledujuce fakty.
   A. FUNCTION minmax() vracia z INITIALIZER LIST PAIR, ktoreho 1. ITEM obsahuje MINIMALNU VALUE a 2. ITEM obsahuje MAXIMALNU VALUE.
   B. PARAMETER obsahuje INITIALIZER LIST.
   C. RETURN VALUE obsahuje PAIR, kde 1. ITEM obsahuje MINIMALNU VALUE a 2. ITEM obsahuje MAXIMALNU VALUE.
   D. Zlozitost FUNCTION minmax() je O(3/2*N).
158. Pre ALGORITHM [constexpr pair<TType,TType> minmax(initializer_list<TType> List, TCompare Compare)] platia nasledujuce fakty.
   A. FUNCTION minmax() vracia z INITIALIZER LIST PAIR, ktoreho 1. ITEM obsahuje MINIMALNU VALUE a 2. ITEM obsahuje MAXIMALNU VALUE. Na porovnanie ITEMS sa pouziva FUNCTION OBJECT 'Compare'.
   B. 1. PARAMETER obsahuje INITIALIZER LIST.
   C. 2. PARAMETER definuje CUSTOM COMPARER, ktory sa pouziva na porovnavanie ITEMS.
   D. RETURN VALUE obsahuje PAIR, kde 1. ITEM obsahuje MINIMALNU VALUE a 2. ITEM obsahuje MAXIMALNU VALUE.
   !!! E. Na porovnavanie ITEMS sa pouziva FUNCTION OBJECT 'Compare', ktory musi vratit TRUE, ak ITEM 1 je MENSI ako ITEM 2, ale FALSE v opacnom pripade.
   F. FUNCTION OBJECT 'Compare' ma PROTOTYPE [bool Compare(const TType& Item1, const TType& Item2)]. Kedze ITEMS su prenasane ako CONST REFERENCES, znamena to, ze FUNCTION OBJECT 'Compare' NEMOZE VALUES danych ITEMS MODIFIKOVAT. FUNCTION OBJECT 'Compare' moze mat aj NON-CONST PARAMETER 'Item1' a NON-CONST PARAMETER 'Item2', ktorych VALUES by sa vsak NEMALI MENIT.
   G. Zlozitost FUNCTION minmax() je O(3/2*N).
//-------------------------------------------------------------------------------------------------------