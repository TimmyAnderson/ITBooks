//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje riesenie problemov s kompatibilitou programov.
2. Ak implementacia C++ NEPODPORUJE TEMPLATE SPECIALIZATION riesenim je definovanie SPECIALIZATION, ktora ma vlastne meno, rozdielne od mena TEMPLATE z ktorej robim SPECIALIZATION.
3. Ak implementacia C++ NEPODPORUJE TEMPLATE FUNCTION v TEMPLATE CLASS, tak riesenim je definovanie separatnej KLASICKEJ METHOD pre KAZDY TYPE. Tym padom namiesto TEMPLATE FUNCTION v TEMPLATE CLASS mam v TEMPLATE CLASS pre kazdy TYPE zvlastnu METHOD, ktora uz sama NIE JE TEMPLATE. Inym riesenim je definovanie GLOBAL TEMPLATE FUNCTION.
!!! 4. Stare C++ implementacie vratane Visual Studio C++ 6.0. po mali definovany platnost VARIABLE vo 'for' ci 'if' az po KONIEC SCOPE v ktorom je 'for', alebo 'if' DEKLAROVANA. Nove C++ implementacie maju platnost iba po KONIEC 'for', alebo 'if' bloku.
5. Standardne C++ OPERATOR NEW pri nedostatku pamate vracia EXCEPTION typu 'bad_alloc'. Starsie C++ implementacie vracali NULL. Toto chovanie je mozne realizovat SYNTAXOU [new (nothrow) XXX;], kde 'no_throw' je SPECIFICKY OBJEKT typu 'nothrow_t', ktory C++ indikuje, ze pri nedostatku pamate nema hodit EXCEPTION, ale vratit NULL.
6. Starsie verzie STL obsahovali HEADER FILES s nazvom <XXX.h> a CLASSES boli v GLOBAL NAMESPACES. Novsie verzie obsahuju HEADER FILES s nazvom <XXX> a su definovane v 'std' NAMESPACE.
!!! 7. Pomocou MACRO '__cplusplus' je mozne zistit ci kod je kompilovany C, alebo C++. 
//-------------------------------------------------------------------------------------------------------