//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie TYPE TRAITS v C++.
2. C++ STANDARD LIBRARY definuje TYPE TRAITS v LIBRARY [<type_traits>].
3. Niektore TYPE TRAITS su implementovane za podpory COMPILER, a nie je ich mozne implementovat iba pomocou C++.
4. TYPE TRAITS je mozne rozdelit do nasledujucich kategorii.
   A. TYPE TRAITS vracajuce TYPE.
   B. TYPE TRAITS vracajuce VALUE.
5. TYPE TRAITS vracajuce TYPE mozu vracat kalkulovany TYPE nasledujucimi sposobmi.
   A. CODE [TYPE_TRAIT<TEMPLATE_PARAMETERS>::type], vracia pomocou USING [type] kalkulovany TYPE.
   B. CODE [TYPE_TRAIT_t<TEMPLATE_PARAMETERS>], priamo vracia kalkulovany TYPE.
6. TYPE TRAITS vracajuce VALUE mozu vracat kalkulovanu VALUE nasledujucimi sposobmi.
   A. CODE [TYPE_TRAIT<TEMPLATE_PARAMETERS>::value], vracia pomocou STATIC FIELD [value] kalkulovanu VALUE.
   B. CODE [TYPE_TRAIT_v<TEMPLATE_PARAMETERS>], priamo vracia kalkulovanu VALUE.
   C. CODE [TYPE_TRAIT<TEMPLATE_PARAMETERS>{}] pomocou CONVERSION [OPERATOR bool()] vracia kalkulovanu VALUE.
   D. CODE [TYPE_TRAIT<TEMPLATE_PARAMETERS>()] pomocou OPERATOR [OPERATOR()] vracia kalkulovanu VALUE.
7. Vsetky C++ STANDARD LIBRARY TYPE TRAITS, ktore vracaju VALUE su DERIVED zo STRUCT [template<typename TType, TType VALUE> integral_constant]. STRUCT [template<typename TType, TType Value> integral_constant] ma nasledujuce MEMBERS.
   A. STATIC CONSTEXPR FIELD [TType value] obsahuje VALUE danho TYPE TRAIT.
   B. USING [value_type] obsahuje TYPE danho TYPE TRAIT. Vo vacsine TYPE TRAITS, ktore vracaju VALUE je to TYPE [bool].
   C. USING [type] TYPE samotneho TYPE TRAIT, ktore je nastaveny na TYPE [integral_constant<TType,VALUE>].
   D. CONSTEXPR CONVERSION OPERATOR [constexpr operator value_type() const noexcept] vracia VALUE danho TYPE TRAIT.
   E. CONSTEXPR OPERATOR [constexpr value_type operator()() const noexcept] vracia VALUE danho TYPE TRAIT.
8. Pre TYPE [bool] definuje C++ STANDARD LIBRARY nasledujuce USINGS.
   A. USING [template<bool VALUE> using bool_constant=integral_constant<bool,VALUE>].
   B. USING [using true_type=bool_constant<true>].
   C. USING [using false_type=bool_constant<false>].
!!! 9. C++ STANDARD LIBRARIES TYPE TRAITS vracajuce VALUE TYPE [bool] su implementovane nasledovne.
   A. Ak TYPE TRAITS vracajuce VALUE TYPE [bool] vracaju VALUE [true], tak su DERIVED z TYPE [true_type].
   B. Ak TYPE TRAITS vracajuce VALUE TYPE [bool] vracaju VALUE [false], tak su DERIVED z TYPE [false_type].
10. Pre TYPE TRAIT [is_void<TType>] platia nasledujuce fakty.
   A. USING [is_void<TType>::value] vracia VALUE [true], ake je TYPE 'TType' TYPE [void].
   B. USING [is_void<TType>::value] vracia VALUE [false], ake je TYPE 'TType' NIE JE TYPE [void].
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
11. Pre TYPE TRAIT [is_integral<TType>] platia nasledujuce fakty.
   A. USING [is_integral<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES a INTEGER TYPES.
   B. USING [is_integral<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
12. Pre TYPE TRAIT [is_floating_point<TType>] platia nasledujuce fakty.
   A. USING [is_floating_point<TType>::value] vracia VALUE [true] pre FLOATING POINT TYPES.
   B. USING [is_floating_point<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
13. Pre TYPE TRAIT [is_array<TType>] platia nasledujuce fakty.
   A. USING [is_array<TType>::value] vracia VALUE [true] pre C-ARRAYS, bez ohladu na to ci maju, alebo nemaju definovanu LENGTH.
   B. USING [is_array<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
14. Pre TYPE TRAIT [is_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_pointer<TType>::value] vracia VALUE [true] pre POINTERS, vratane POINTERS na FUNCTIONS.
   B. USING [is_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES, vratane, C-ARRAYS, POINTERS TO MEMBERS (FIELDS a METHODS) a TYPE [nullptr_t].
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
15. Pre TYPE TRAIT [is_null_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_null_pointer<TType>::value] vracia VALUE [true] pre	TYPE [nullptr_t].
   B. USING [is_null_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
16. Pre TYPE TRAIT [is_member_object_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_member_object_pointer<TType>::value] vracia VALUE [true] pre TYPE POINTER na FIELD TYPE 'TType'.
   B. USING [is_member_object_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
17. Pre TYPE TRAIT [is_member_function_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_member_function_pointer<TType>::value] vracia VALUE [true] pre TYPE POINTER na METHOD TYPE 'TType'.
   B. USING [is_member_function_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
18. Pre TYPE TRAIT [is_lvalue_reference<TType>] platia nasledujuce fakty.
   A. USING [is_lvalue_reference<TType>::value] vracia VALUE [true] pre TYPE predstavuje LVALUE REFERENCE.
   B. USING [is_lvalue_reference<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
19. Pre TYPE TRAIT [is_rvalue_reference<TType>] platia nasledujuce fakty.
   A. USING [is_rvalue_reference<TType>::value] vracia VALUE [true] pre TYPE predstavuje RVALUE REFERENCE.
   B. USING [is_rvalue_reference<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
20. Pre TYPE TRAIT [is_enum<TType>] platia nasledujuce fakty.
   A. USING [is_enum<TType>::value] vracia VALUE [true] pre UNSCOPED ENUMS (KEYWORD [enum]) a SCOPED ENUMS (KEYWORD [enum class]).
   B. USING [is_enum<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
21. Pre TYPE TRAIT [is_class<TType>] platia nasledujuce fakty.
   A. USING [is_class<TType>::value] vracia VALUE [true] pre CLASSES, STRUCTURES a LAMBDA EXPRESSIONS, ktore su interne implementovane ako CLASSES.
   B. USING [is_class<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
22. Pre TYPE TRAIT [is_union<TType>] platia nasledujuce fakty.
   A. USING [is_union<TType>::value] vracia VALUE [true] pre UNIONS a UNION TEMPLATES.
   B. USING [is_union<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
23. Pre TYPE TRAIT [is_function<TType>] platia nasledujuce fakty.
   A. USING [is_function<TType>::value] vracia VALUE [true] pre FUNCTIONS a METHODS.
   B. USING [is_function<TType>::value] vracia VALUE [false] pre POINTERS na FUNCTIONS, LAMBDA EXPRESSIONS a pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
24. Pre TYPE TRAIT [is_reference<TType>] platia nasledujuce fakty.
   A. USING [is_reference<TType>::value] vracia VALUE [true] pre TYPE predstavuje REFERENCE TYPE.
   B. USING [is_reference<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
25. Pre TYPE TRAIT [is_member_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_member_pointer<TType>::value] vracia VALUE [true] pre TYPE POINTER na FIELD TYPE 'TType' a pre TYPE POINTER na METHOD TYPE 'TType'.
   B. USING [is_member_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
26. Pre TYPE TRAIT [is_arithmetic<TType>] platia nasledujuce fakty.
   A. USING [is_arithmetic<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES, INTEGER TYPES a FLOATING POINT TYPES.
   B. USING [is_arithmetic<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
27. Pre TYPE TRAIT [is_fundamental<TType>] platia nasledujuce fakty.
   A. USING [is_fundamental<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES, INTEGER TYPES, FLOATING POINT TYPES, TYPE [void] a TYPE [nullptr_t].
   B. USING [is_fundamental<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
28. Pre TYPE TRAIT [is_scalar<TType>] platia nasledujuce fakty.
   A. USING [is_scalar<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES, INTEGER TYPES, FLOATING POINT TYPES, POINTER TYPES, POINTER TO MEMBER TYPES, ENUM TYPES a TYPE [nullptr_t].
   B. USING [is_scalar<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
29. Pre TYPE TRAIT [is_object<TType>] platia nasledujuce fakty.
   A. USING [is_object<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES, INTEGER TYPES, FLOATING POINT TYPES, POINTER TYPES, POINTER TO MEMBER TYPES, ENUM TYPES, ARRAY TYPES, CLASS TYPES, STRUCTURE TYPES, UNION TYPES a TYPE [nullptr_t].
   B. USING [is_object<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
30. Pre TYPE TRAIT [is_compound<TType>] platia nasledujuce fakty.
   A. USING [is_compound<TType>::value] vracia VALUE [true] pre ENUM TYPES, ARRAY TYPES, CLASS TYPES, STRUCTUR TYPES, UNION TYPES, REFERENCE TYPES, POINTER TYPES, POINTER TO MEMBER TYPES a FUNCTION TYPES.
   B. USING [is_compound<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
31. Pre TYPE TRAIT [is_signed<TType>] platia nasledujuce fakty.
   A. USING [is_signed<TType>::value] vracia VALUE [true] pre ARITHMETIC TYPES, ktore su SIGNED.
   B. USING [is_signed<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES, vratane ENUM TYPES a TYPE [bool].
   C. USING [is_signed<TType>::value] vracia pre TYPE [char] vracia IMPLEMENTATION DEFINED VALUE.
   D. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
32. Pre TYPE TRAIT [is_unsigned<TType>] platia nasledujuce fakty.
   A. USING [is_unsigned<TType>::value] vracia VALUE [true] pre ARITHMETIC TYPES, ktore su UNSIGNED, vratane TYPE [bool].
   B. USING [is_unsigned<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES, vratane ENUM TYPES.
   C. USING [is_unsigned<TType>::value] vracia pre TYPE [char] vracia IMPLEMENTATION DEFINED VALUE.
   D. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
33. Pre TYPE TRAIT [is_const<TType>] platia nasledujuce fakty.
   A. USING [is_const<TType>::value] vracia VALUE [true] pre CONSTANT TYPES, vratane CONSTANT POINTERS a ARRAYS obsahujucich CONSTANT VALUES.
   B. USING [is_const<TType>::value] vracia VALUE [false] pre NON-CONSTANT TYPES, vratane NON-CONSTANT POINTERS, NON-CONSTANT REFERENCES a ARRAYS obsahujucich NON-CONSTANT VALUES. VALUE [false] je takisto vratena pre NON-CONSTANT POINTERS na CONSTANTS, NON-CONSTANT REFERENCES na CONSTANTS ci ARRAYS obsahujucich NON-CONSTANT VALUES.
34. Pre TYPE TRAIT [is_volatile<TType>] platia nasledujuce fakty.
   A. USING [is_volatile<TType>::value] vracia VALUE [true] pre VOLATILE TYPES, vratane VOLATILE POINTERS a ARRAYS obsahujucich VOLATILE VALUES.
   B. USING [is_volatile<TType>::value] vracia VALUE [false] pre NON-VOLATILE TYPES, vratane NON-VOLATILE POINTERS, NON-VOLATILE REFERENCES a ARRAYS obsahujucich NON-VOLATILE VALUES. VALUE [false] je takisto vratena pre NON-VOLATILE POINTERS na VOLATILES, NON-VOLATILE REFERENCES na VOLATILES ci ARRAYS obsahujucich NON-VOLATILE VALUES.
35. Pre TYPE TRAIT [is_aggregate<TType>] platia nasledujuce fakty.
   A. USING [is_aggregate<TType>::value] vracia VALUE [true] pre AGGREGATE TYPES.
   B. USING [is_aggregate<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
36. AGGREGATE TYPES su bud C-LIKE ARRAYS, alebo USER DEFINED TYPES (CLASSES, STRUCTURES, UNIONS) s nasledujucimi obmedzeniami.
   A. Nemaju definovany CUSTOM CONSTRUCTOR.
   B. Nemaju PRIVATE, alebo PROTECTED FIELDS.
   C. Nemaju NON-PUBLIC BASE CLASSES.
   D. Nemaju VIRTUAL METHODS.
37. Pre TYPE TRAIT [is_trivial<TType>] platia nasledujuce fakty.
   A. USING [is_trivial<TType>::value] vracia VALUE [true] pre SCALAR TYPES, TRIVIAL CLASS TYPES, ARRAYS SCALAR TYPES a ARRAYS TRIVIAL CLASS TYPES.
   B. USING [is_trivial<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
38. TRIVIAL CLASS TYPES su USER DEFINED CLASSES s nasledujucimi obmedzeniami.
   A. Nemaju definovany CUSTOM DEFAULT CONSTRUCTOR, CUSTOM CONSTRUCTOR, CUSTOM COPY CONSTRUCTOR a CUSTOM MOVE CONSTRUCTOR.
   B. Nemaju definovany CUSTOM COPY OPERATOR [OPERATOR=] a CUSTOM MOVE OPERATOR [OPERATOR=].
   C. Nemaju definovany CUSTOM DESTRUCTOR.
   D. Nemaju VIRTUAL METHODS.
   E. Nemaju VIRTUAL BASE CLASSES.
   F. Nemaju NON TRIVIAL FIELDS.
   G. Nemaju VOLATILE FIELDS.
39. Pre TYPE TRAIT [is_trivial<TType>] platia nasledujuce fakty.
   A. USING [is_trivial<TType>::value] vracia VALUE [true] pre SCALAR TYPES, TRIVIALLY COPYABLE CLASS TYPES, ARRAYS SCALAR TYPES a ARRAYS TRIVIALLY COPYABLE CLASS TYPES.
   B. USING [is_trivial<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
40. TRIVIALLY COPYABLE CLASS TYPES su USER DEFINED CLASSES s nasledujucimi obmedzeniami.
   !!! A. Mozu mat definovany CUSTOM DEFAULT 
   B. Nemaju definovany CUSTOM CONSTRUCTOR, CUSTOM COPY CONSTRUCTOR a CUSTOM MOVE CONSTRUCTOR.
   C. Nemaju definovany CUSTOM COPY OPERATOR [OPERATOR=] a CUSTOM MOVE OPERATOR [OPERATOR=].
   D. Nemaju definovany CUSTOM DESTRUCTOR.
   E. Nemaju VIRTUAL METHODS.
   F. Nemaju VIRTUAL BASE CLASSES.
   G. Nemaju NON TRIVIAL FIELDS.
   H. Nemaju VOLATILE FIELDS.
41. Pre TYPE TRAIT [is_standard_layout<TType>] platia nasledujuce fakty.
   A. USING [is_standard_layout<TType>::value] vracia VALUE [true] pre SCALAR TYPES, STANDARD LAYOUT CLASS TYPES, ARRAYS SCALAR TYPES a ARRAYS STANDARD LAYOUT CLASS TYPES.
   B. USING [is_standard_layout<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
42. STANDARD LAYOUT CLASS TYPES su USER DEFINED CLASSES s nasledujucimi obmedzeniami.
   A. Maju rovnaky ACCESS MODIFIER pre vsetky FIELDS.
   B. Nemaju VIRTUAL METHODS.
   C. Nemaju NON STANDARD LAYOUT BASE CLASSES.
   D. Nemaju VIRTUAL BASE CLASSES.
   E. Nemaju NON STANDARD LAYOUT NON STATIC FIELDS.
   F. Nemaju NON STATIC REFERENCE FIELDS.
43. Pre TYPE TRAIT [is_empty<TType>] platia nasledujuce fakty.
   A. USING [is_empty<TType>::value] vracia VALUE [true] pre CLASS TYPES, ktore nemaju NON-STATIC FIELDS, nemaju VIRTUAL METHODS, nemaju VIRTUAL BASE CLASSES a maju iba EMTPY BASE CLASSES.
   B. USING [is_empty<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
44. Pre TYPE TRAIT [is_polymorphic<TType>] platia nasledujuce fakty.
   A. USING [is_polymorphic<TType>::value] vracia VALUE [true] pre CLASSES, ktore maju VIRTUAL METHODS.
   B. USING [is_polymorphic<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
45. Pre TYPE TRAIT [is_abstract<TType>] platia nasledujuce fakty.
   A. USING [is_abstract<TType>::value] vracia VALUE [true] pre CLASSES, ktore maju PURE VIRTUAL METHODS.
   B. USING [is_abstract<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
46. Pre TYPE TRAIT [is_final<TType>] platia nasledujuce fakty.
   A. USING [is_final<TType>::value] vracia VALUE [true] pre FINAL CLASSES.
   B. USING [is_final<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
47. Pre TYPE TRAIT [has_virtual_destructor<TType>] platia nasledujuce fakty.
   A. USING [has_virtual_destructor<TType>::value] vracia VALUE [true] pre CLASSES, ktore maju VIRTUAL DESTRUCTORS.
   B. USING [has_virtual_destructor<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
48. Pre TYPE TRAIT [has_unique_object_representations<TType>] platia nasledujuce fakty.
   A. USING [has_unique_object_representations<TType>::value] vracia VALUE [true] pre TYPES, ktore su TRIVIALLY COPIABLE a ktorych BINARY REPRESENTATION je ROVNAKA, ak obsahuju ich FIELDS tie iste VALUES. Takisto pre ARRAYS takychto CLASSES vracia TYPE TRAIT VALUE [true].
   B. USING [has_unique_object_representations<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
   !!! D. Pre CLASSES, pre ktore TYPE TRAIT [has_unique_object_representations<TType>::value] vracia VALUE [true] je plati, ze vzdy je pre ne mozne vypocitat validny HASH CODE.
   !!!!! E. To, ktore SCALAR TYPES splnaju tuto podmienku je IMPLEMENTATION DEFINED.
49. Pre TYPE TRAIT [alignment_of<TType>] platia nasledujuce fakty.
   A. USING [alignment_of<TType>::value] TYPE [size_t] vracia pocet BYTES potrebnych na zarovnanie daneho TYPE.
   B. USING [alignment_of<TType>::value] vracia tu istu VALUE ako OPERATOR [alignof(TYPE)].
50. Pre TYPE TRAIT [rank<TType>] platia nasledujuce fakty.
   A. USING [rank<TType>::value] TYPE [size_t] pre C-ARRAYS vracia pocet DIMENSIONS daneho C-ARRAY.
   B. USING [rank<TType>::value] TYPE [size_t] vracia VALUE [0] pre vsetky ostatne TYPES.
51. Pre TYPE TRAIT [extent<TType,INDEX>] platia nasledujuce fakty.
   A. USING [extent<TType,INDEX>::value] TYPE [size_t] pre C-ARRAYS vracia velkost C-ARRAY pre DIMENSION [INDEX]. Ak dany ARRAY nema danu DIMENSION, tak TYPE TRAIT vracia VALUE [0].
   B. USING [extent<TType,INDEX>::value] TYPE [size_t] vracia VALUE [0] pre vsetky ostatne TYPES.
52. Pre TYPE TRAIT [underlying_type<TType>] platia nasledujuce fakty.
   A. USING [underlying_type<TType>::type] vracia UNDERLYING TYPE ENUM TYPE.
   B. USING [underlying_type<TType>::type] pre NON-ENUM TYPES je UNDEFINED.
53. Pre TYPE TRAIT [is_invocable<TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [is_invocable<TFunction,TArguments...>::value] vracia VALUE [true] ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_invocable<TFunction,TArguments...>::value] vracia VALUE [false] ak TYPE [TFunction] NIE JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...].
54. Pre TYPE TRAIT [is_nothrow_invocable<TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [is_nothrow_invocable<TFunction,TArguments...>::value] vracia VALUE [true] ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...] a zaroven FUNCTION [TFunction] nehadze EXCEPTIONS. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_nothrow_invocable<TFunction,TArguments...>::value] vracia VALUE [false] ak TYPE [TFunction] NIE JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...], alebo ak FUNCTION [TFunction] moze hodit EXCEPTIONS.
55. Pre TYPE TRAIT [is_invocable_r<TReturnValue,TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [is_invocable_r<TReturnValue,TFunction,TArguments...>::value] vracia VALUE [true] ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...] a zaroven RETURN VALUE TYPE je CONVERTIBLE na TYPE [TReturnValue]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_invocable_r<TReturnValue,TFunction,TArguments...>::value] vracia VALUE [false] ak TYPE [TFunction] NIE JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...], ktorej RETURN VALUE TYPE je CONVERTIBLE na TYPE [TReturnValue].
56. Pre TYPE TRAIT [is_nothrow_invocable_r<TReturnValue,TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [is_nothrow_invocable_r<TReturnValue,TFunction,TArguments...>::value] vracia VALUE [true] ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...], RETURN VALUE TYPE je CONVERTIBLE na TYPE [TReturnValue] a zaroven FUNCTION [TFunction] nehadze EXCEPTIONS. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_nothrow_invocable_r<TReturnValue,TFunction,TArguments...>::value] vracia VALUE [false] ak TYPE [TFunction] NIE JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...], ktorej RETURN VALUE TYPE je CONVERTIBLE na TYPE [TReturnValue], alebo ak FUNCTION [TFunction] moze hodit EXCEPTIONS.
57. Pre TYPE TRAIT [invoke_result<TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [invoke_result<TFunction,TArguments...>::type] vracia RETURN VALUE TYPE, ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [invoke_result<TFunction,TArguments...>::type] nie je DEFINED ak FUNCTION [TFunction] nie je CALLABLE pre ARGUMENTS [TArguments...].
58. Pre TYPE TRAIT [is_constructible<TType,TArguments...>] platia nasledujuce fakty.
   A. USING [is_constructible<TType,TArguments...>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim CONSTRUCTOR s AGRUMENTS [TArguments...]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_constructible<TType,TArguments...>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim CONSTRUCTOR s AGRUMENTS [TArguments...].
   !!! C. Ak USING [is_constructible<TType,TArguments...>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_destructible<TType>::value] vrati VALUE [true].
59. Pre TYPE TRAIT [is_trivially_constructible<TType,TArguments...>] platia nasledujuce fakty.
   A. USING [is_trivially_constructible<TType,TArguments...>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) CONSTRUCTOR s AGRUMENTS [TArguments...]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_trivially_constructible<TType,TArguments...>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim TRIVIAL CONSTRUCTOR s AGRUMENTS [TArguments...].
   !!! C. Ak USING [is_trivially_constructible<TType,TArguments...>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_trivially_destructible<TType>::value] vrati VALUE [true].
60. Pre TYPE TRAIT [is_nothrow_constructible<TType,TArguments...>] platia nasledujuce fakty.
   A. USING [is_nothrow_constructible<TType,TArguments...>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim CONSTRUCTOR s AGRUMENTS [TArguments...] pricom CONSTRUCTOR je oznaceny pomocou KEYWORD [noexcept]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_nothrow_constructible<TType,TArguments...>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim CONSTRUCTOR s AGRUMENTS [TArguments...], alebo dany CONSTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!! C. Ak USING [is_nothrow_constructible<TType,TArguments...>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_nothrow_destructible<TType>::value] vrati VALUE [true].
61. Pre TYPE TRAIT [is_default_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_default_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim DEFAULT CONSTRUCTOR.
   B. USING [is_default_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim DEFAULT CONSTRUCTOR.
   !!! C. Ak USING [is_default_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_default_constructible<TType>::value] vracia tu istu VALUE ako USING [is_constructible<TType>::value].
62. Pre TYPE TRAIT [is_trivially_default_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_default_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) DEFAULT CONSTRUCTOR.
   B. USING [is_trivially_default_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim TRIVIAL DEFAULT CONSTRUCTOR.
   !!! C. Ak USING [is_trivially_default_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_trivially_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_trivially_default_constructible<TType>::value] vracia tu istu VALUE ako USING [is_trivially_constructible<TType>::value].
63. Pre TYPE TRAIT [is_nothrow_default_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_default_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim DEFAULT CONSTRUCTOR pricom CONSTRUCTOR je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_default_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim DEFAULT CONSTRUCTOR, alebo dany CONSTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!! C. Ak USING [is_nothrow_default_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_nothrow_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_nothrow_default_constructible<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_constructible<TType>::value].
64. Pre TYPE TRAIT [is_copy_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_copy_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim COPY CONSTRUCTOR.
   B. USING [is_copy_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim COPY CONSTRUCTOR.
   !!! C. Ak USING [is_copy_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_copy_constructible<TType>::value] vracia tu istu VALUE ako USING [is_constructible<TType,const TType&>::value].
65. Pre TYPE TRAIT [is_trivially_copy_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_copy_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) COPY CONSTRUCTOR.
   B. USING [is_trivially_copy_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim TRIVIAL COPY CONSTRUCTOR.
   !!! C. Ak USING [is_trivially_copy_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_trivially_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_trivially_copy_constructible<TType>::value] vracia tu istu VALUE ako USING [is_trivially_constructible<TType,const TType&>::value].
66. Pre TYPE TRAIT [is_nothrow_copy_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_copy_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim COPY CONSTRUCTOR pricom CONSTRUCTOR je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_copy_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim COPY CONSTRUCTOR, alebo dany CONSTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!! C. Ak USING [is_nothrow_copy_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_nothrow_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_nothrow_copy_constructible<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_constructible<TType,const TType&>::value].
67. Pre TYPE TRAIT [is_move_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_move_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim MOVE CONSTRUCTOR.
   B. USING [is_move_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim MOVE CONSTRUCTOR.
   !!! C. Ak USING [is_move_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_move_constructible<TType>::value] vracia tu istu VALUE ako USING [is_constructible<TType,TType&&>::value].
68. Pre TYPE TRAIT [is_trivially_move_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_move_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) MOVE CONSTRUCTOR.
   B. USING [is_trivially_move_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim TRIVIAL MOVE CONSTRUCTOR.
   !!! C. Ak USING [is_trivially_move_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_trivially_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_trivially_move_constructible<TType>::value] vracia tu istu VALUE ako USING [is_trivially_constructible<TType,TType&&>::value].
69. Pre TYPE TRAIT [is_nothrow_move_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_move_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim MOVE CONSTRUCTOR pricom CONSTRUCTOR je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_move_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim MOVE CONSTRUCTOR, alebo dany CONSTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!! C. Ak USING [is_nothrow_move_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_nothrow_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_nothrow_move_constructible<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_constructible<TType,TType&&>::value].
70. Pre TYPE TRAIT [is_assignable<TTo,TFrom>] platia nasledujuce fakty.
   A. USING [is_assignable<TTo,TFrom>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TFrom] je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou OPERATOR [OPERATOR=].
   B. USING [is_assignable<TTo,TFrom>::value] vracia VALUE [false] RVALUE REFERENCE TYPE [TFrom] NIE je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou OPERATOR [OPERATOR=].
   !!!!! C. USING [is_assignable<TTo,TFrom>::value] vracia VALUE [false] aj vtedy, ak TYPE [TFrom] a TYPE [TTo] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [10=10], ktory v C++ je neplatny.
71. Pre TYPE TRAIT [is_trivially_assignable<TTo,TFrom>] platia nasledujuce fakty.
   A. USING [is_trivially_assignable<TTo,TFrom>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TFrom] je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou TRIVIAL (NOT DEFINED) OPERATOR [OPERATOR=].
   B. USING [is_trivially_assignable<TTo,TFrom>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TFrom] NIE je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou TRIVIAL (NOT DEFINED) OPERATOR [OPERATOR=].
   !!!!! C. USING [is_trivially_assignable<TTo,TFrom>::value] vracia VALUE [false] aj vtedy, ak TYPE [TFrom] a TYPE [TTo] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [10=10], ktory v C++ je neplatny.
72. Pre TYPE TRAIT [is_nothrow_assignable<TTo,TFrom>] platia nasledujuce fakty.
   A. USING [is_nothrow_assignable<TTo,TFrom>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TFrom] je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou OPERATOR [OPERATOR=], ktory je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_assignable<TTo,TFrom>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TFrom] NIE je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou OPERATOR [OPERATOR=], ktory je oznaceny pomocou KEYWORD [noexcept].
   !!!!! C. USING [is_nothrow_assignable<TTo,TFrom>::value] vracia VALUE [false] aj vtedy, ak TYPE [TFrom] a TYPE [TTo] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [10=10], ktory v C++ je neplatny.
73. Pre TYPE TRAIT [is_copy_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_copy_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je mozne volat COPY OPERATOR [OPERATOR=].
   B. USING [is_copy_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat COPY OPERATOR [OPERATOR=]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED COPY OPERATOR [OPERATOR=].
   !!! C. USING [is_copy_assignable<TType>::value] vracia tu istu VALUE ako USING [is_assignable<TType&,const TType&>::value].
74. Pre TYPE TRAIT [is_trivially_copy_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_copy_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je mozne volat TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) COPY OPERATOR [OPERATOR=].
   B. USING [is_trivially_copy_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat TRIVIAL COPY OPERATOR [OPERATOR=]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED COPY OPERATOR [OPERATOR=].
   !!! C. USING [is_trivially_copy_assignable<TType>::value] vracia tu istu VALUE ako USING [is_trivially_assignable<TType&,const TType&>::value].
75. Pre TYPE TRAIT [is_nothrow_copy_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_copy_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je volat COPY OPERATOR [OPERATOR=] pricom COPY OPERATOR [OPERATOR=] je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_copy_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat COPY OPERATOR [OPERATOR=], alebo dany COPY OPERATOR [OPERATOR=] NIE JE oznaceny pomocou KEYWORD [noexcept]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED COPY OPERATOR [OPERATOR=].
   !!! C. USING [is_nothrow_copy_assignable<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_assignable<TType&,const TType&>::value].
76. Pre TYPE TRAIT [is_move_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_move_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je mozne volat MOVE OPERATOR [OPERATOR=].
   B. USING [is_move_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat MOVE OPERATOR [OPERATOR=]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED MOVE OPERATOR [OPERATOR=].
   !!! C. USING [is_move_assignable<TType>::value] vracia tu istu VALUE ako USING [is_assignable<TType&,TType&&>::value].
77. Pre TYPE TRAIT [is_trivially_move_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_move_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je mozne volat TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) MOVE OPERATOR [OPERATOR=].
   B. USING [is_trivially_move_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat TRIVIAL MOVE OPERATOR [OPERATOR=]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED MOVE OPERATOR [OPERATOR=].
   !!! C. USING [is_trivially_move_assignable<TType>::value] vracia tu istu VALUE ako USING [is_trivially_assignable<TType&,TType&&>::value].
78. Pre TYPE TRAIT [is_nothrow_move_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_move_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je volat MOVE OPERATOR [OPERATOR=] pricom MOVE OPERATOR [OPERATOR=] je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_move_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat MOVE OPERATOR [OPERATOR=], alebo dany MOVE OPERATOR [OPERATOR=] NIE JE oznaceny pomocou KEYWORD [noexcept]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED MOVE OPERATOR [OPERATOR=].
   !!! C. USING [is_nothrow_move_assignable<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_assignable<TType&,TType&&>::value].
79. Pre TYPE TRAIT [is_destructible<TType>] platia nasledujuce fakty.
   A. USING [is_destructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne uvolnit volanim DESTRUCTOR.
   B. USING [is_destructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne uvolnit volanim DESTRUCTOR. VALUE [false] je vratena aj pre TYPE [void], UNBOUNDED C-ARRAYS a FUNCTION TYPES.
80. Pre TYPE TRAIT [is_trivially_destructible<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_destructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne uvolnit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) DESTRUCTOR.
   B. USING [is_trivially_destructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne uvolnit volanim TRIVIAL DESTRUCTOR. VALUE [false] je vratena aj pre TYPE [void], UNBOUNDED C-ARRAYS a FUNCTION TYPES a takisto vtedy ak ma TYPE BASE CLASSES, alebo FIELDS, ktore NEMAJU TRIVIAL DESTRUCTOR.
81. Pre TYPE TRAIT [is_nothrow_destructible<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_destructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne uvolnit volanim DESTRUCTOR pricom DESTRUCTOR je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_destructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne uvolnit volanim DESTRUCTOR, alebo dany DESTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!!!! C. USING [is_nothrow_destructible<TType>::value] vracia VALUE [true], aj ked DESTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept]. Je to preto, lebo v C++ DESTRUCTORS NESMU hadzat EXCEPTIONS, a ak niektory DESTRUCTOR hodi EXCEPTION, tak je PROGRAM okamzite TERMINATED.
82. Pre TYPE TRAIT [is_swappable_with<TType1,TType2>] platia nasledujuce fakty.
   A. USING [is_swappable_with<TType1,TType2>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TType1] je SWAPPABLE (ma definovanu FUNCTION void swap(TType1&,TType2&)) s RVALUE REFERENCE TYPE [TType2].
   B. USING [is_swappable_with<TType1,TType2>::value] vracia VALUE [false] RVALUE REFERENCE TYPE [TType1] NIE je je SWAPPABLE s RVALUE REFERENCE TYPE [TType2].
   !!!!! C. USING [is_swappable_with<TType1,TType2>::value] vracia VALUE [false] aj vtedy, ak TYPE [TType1] a TYPE [TType2] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [swap(10,10)], ktory v C++ je neplatny.
83. Pre TYPE TRAIT [is_nothrow_swappable_with<TType1,TType2>] platia nasledujuce fakty.
   A. USING [is_nothrow_swappable_with<TType1,TType2>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TType1] je NO-THROW SWAPPABLE (ma definovanu FUNCTION void swap(TType1&,TType2&)) s RVALUE REFERENCE TYPE [TType2].
   B. USING [is_nothrow_swappable_with<TType1,TType2>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TType1] NIE je NO-THROW SWAPPABLE s RVALUE REFERENCE TYPE [TType2].
   !!!!! C. USING [is_nothrow_swappable_with<TType1,TType2>::value] vracia VALUE [false] aj vtedy, ak TYPE [TType1] a TYPE [TType2] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [swap(10,10)], ktory v C++ je neplatny.
84. Pre TYPE TRAIT [is_swappable<TType>] platia nasledujuce fakty.
   A. USING [is_swappable<TType>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TType] je SWAPPABLE (ma definovanu FUNCTION void swap(TType&,TType&)) s RVALUE REFERENCE TYPE [TType].
   B. USING [is_swappable<TType>::value] vracia VALUE [false] RVALUE REFERENCE TYPE [TType] NIE je je SWAPPABLE s RVALUE REFERENCE TYPE [TType].
   !!! C. USING [is_swappable<TType>::value] vracia tu istu VALUE ako USING [is_swappable_with<TType&,TType&>::value].
85. Pre TYPE TRAIT [is_nothrow_swappable<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_swappable<TType>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TType] je NO-THROW SWAPPABLE (ma definovanu FUNCTION void swap(TType&,TType&)) s RVALUE REFERENCE TYPE [TType].
   B. USING [is_nothrow_swappable<TType>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TType] NIE je NO-THROW SWAPPABLE s RVALUE REFERENCE TYPE [TType].
   !!! C. USING [is_nothrow_swappable<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_swappable_with<TType&,TType&>::value].
86. Pre TYPE TRAIT [is_same<TType1,TType2>] platia nasledujuce fakty.
   A. USING [is_same<TType1,TType2>::value] vracia VALUE [true] ak TYPE [TType1] je zhodny s TYPE [TType2]. TYPE TRAIT berie do uvahy aj CONST a VOLATILE MODIFIERS, alebo ak TYPES su ALIASES na tie iste TYPES.
   B. USING [is_same<TType1,TType2>::value] vracia VALUE [false] ak TYPE [TType1] je ROZDIELNY od TYPE [TType2]. TYPE TRAIT vracia VALUE [false], aj ked TYPES odkazuju na sice rozne LAMBDA EXPRESSIONS, ktore vsak maju ten isty CODE.
87. Pre TYPE TRAIT [is_base_of<TBase,TDerived>] platia nasledujuce fakty.
   A. USING [is_base_of<TBase,TDerived>::value] vracia VALUE [true] ak TYPE [TBase] je BASE CLASS TYPE [TDerived], alebo su obe TYPES zhodne.
   B. USING [is_base_of<TBase,TDerived>::value] vracia VALUE [false] ak TYPE [TBase] NIE je BASE CLASS TYPE [TDerived], alebo nie su oba TYPES zhodne. VALUE [false] je tiez vratena pre NON-CLASS TYPES ako PRIMITIVE TYPES, C-ARRAYS, POINTERS ci REFERENCES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
   D. TYPE TRAIT IGNORUJE ACCESS MODIFIER BASE CLASSES.
88. Pre TYPE TRAIT [is_convertible<TFrom,TTo>] platia nasledujuce fakty.
   A. USING [is_convertible<TFrom,TTo>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TFrom] je konvertovatelna na TYPE [TType2].
   B. USING [is_convertible<TFrom,TTo>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TFrom] NIE JE konvertovatelna na TYPE [TType2].
89. Pre TYPE TRAIT [remove_const<TType>] platia nasledujuce fakty.
   A. USING [remove_const<TType>::type] vracia TYPE z ktoreho je odstraneny najvyssi MODIFIER [const].
   B. TYPE TRAIT NEODSTRANUJE MODIFIER [const] z NON-CONST POINTER TYPE, alebo NON-CONST REFERENCE TYPE odkazujuci sa na CONST POINTER, alebo CONST REFERENCE.
90. Pre TYPE TRAIT [remove_volatile<TType>] platia nasledujuce fakty.
   A. USING [remove_volatile<TType>::type] vracia TYPE z ktoreho je odstraneny najvyssi MODIFIER [volatile].
   B. TYPE TRAIT NEODSTRANUJE MODIFIER [volatile] z NON-VOLATILE POINTER TYPE, alebo NON-VOLATILE REFERENCE TYPE odkazujuci sa na VOLATILE POINTER, alebo VOLATILE REFERENCE.
91. Pre TYPE TRAIT [remove_cv<TType>] platia nasledujuce fakty.
   A. USING [remove_cv<TType>::type] vracia TYPE z ktoreho je odstraneny najvyssi MODIFIER [const] a MODIFIER [volatile].
   B. TYPE TRAIT NEODSTRANUJE MODIFIER [const] z NON-CONST POINTER TYPE, alebo NON-CONST REFERENCE TYPE odkazujuci sa na CONST POINTER, alebo CONST REFERENCE.
   C. TYPE TRAIT NEODSTRANUJE MODIFIER [volatile] z NON-VOLATILE POINTER TYPE, alebo NON-VOLATILE REFERENCE TYPE odkazujuci sa na VOLATILE POINTER, alebo VOLATILE REFERENCE.
92. Pre TYPE TRAIT [add_const<TType>] platia nasledujuce fakty.
   A. USING [add_const<TType>::type] vracia TYPE do ktoreho je pridany MODIFIER [const].
   B. Pre REFERENCE a FUNCTION TYPES, TYPE TRAIT NEPRIDAVA MODIFIER [const].
93. Pre TYPE TRAIT [add_volatile<TType>] platia nasledujuce fakty.
   A. USING [add_volatile<TType>::type] vracia TYPE do ktoreho je pridany MODIFIER [volatile].
   B. Pre REFERENCE a FUNCTION TYPES, TYPE TRAIT NEPRIDAVA MODIFIER [volatile].
94. Pre TYPE TRAIT [add_cv<TType>] platia nasledujuce fakty.
   A. USING [add_cv<TType>::type] vracia TYPE do ktoreho je pridany MODIFIER [const] a MODIFIER [volatile].
   B. Pre REFERENCE a FUNCTION TYPES, TYPE TRAIT NEPRIDAVA MODIFIER [const] a MODIFIER [volatile].
95. Pre TYPE TRAIT [make_signed<TType>] platia nasledujuce fakty.
   A. USING [make_signed<TType>::type] pre INTEGER TYPES okrem TYPE [bool] a pre ENUMERATION TYPES vracia SIGNED INTEGER TYPE TYPE [TType].
   B. USING [make_signed<TType>::type] ostatne TYPES sposobi COMPILATION ERROR.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
96. Pre TYPE TRAIT [make_unsigned<TType>] platia nasledujuce fakty.
   A. USING [make_unsigned<TType>::type] pre INTEGER TYPES okrem TYPE [bool] a pre ENUMERATION TYPES vracia UNSIGNED INTEGER TYPE TYPE [TType].
   B. USING [make_unsigned<TType>::type] ostatne TYPES sposobi COMPILATION ERROR.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
97. Pre TYPE TRAIT [remove_reference<TType>] platia nasledujuce fakty.
   A. USING [remove_reference<TType>::type] pre REFERENCE TYPES vrati NON-REFERENCE TYPE TYPE [TType].
   B. USING [remove_reference<TType>::type] ostatne TYPES vrati povodny TYPE.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
98. Pre TYPE TRAIT [add_lvalue_reference<TType>] platia nasledujuce fakty.
   A. USING [add_lvalue_reference<TType>::type] pre REFERENCABLE TYPES pridava k TYPE LVALUE REFERENCE.
   B. USING [add_lvalue_reference<TType>::type] pre NON-REFERENCABLE TYPES (TYPE [void]) vracia povodny TYPE.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
   !!! D. Na vysledny TYPE sa aplikuju REFERENCE COLLAPSING RULES.
99. Pre TYPE TRAIT [add_rvalue_reference<TType>] platia nasledujuce fakty.
   A. USING [add_rvalue_reference<TType>::type] pre REFERENCABLE TYPES pridava k TYPE RVALUE REFERENCE.
   B. USING [add_rvalue_reference<TType>::type] pre NON-REFERENCABLE TYPES (TYPE [void]) vracia povodny TYPE.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
   !!! D. Na vysledny TYPE sa aplikuju REFERENCE COLLAPSING RULES.
100. Pre TYPE TRAIT [remove_pointer<TType>] platia nasledujuce fakty.
   A. USING [remove_pointer<TType>::type] pre POINTER TYPES odstranuje POINTER z TYPE [TType].
   B. USING [remove_pointer<TType>::type] pre NON-POINTER TYPES (TYPE [void]) vracia povodny TYPE.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
101. Pre TYPE TRAIT [add_pointer<TType>] platia nasledujuce fakty.
   A. USING [add_pointer<TType>::type] pre TYPES pre ktore je mozne ziskat POINTER pridava POINTER k TYPE [TType]. Pre REFERENCE TYPES su REFERENCES ODSTRANENE.
   B. USING [add_pointer<TType>::type] pre ostatne TYPES vracia povodny TYPE.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
102. Pre TYPE TRAIT [remove_extent<TType>] platia nasledujuce fakty.
   A. USING [remove_extent<TType>::type] pre C-ARRAY TYPES vracia TYPE z ktoreho je najvyssia uroven C-ARRAY odstranena.
   B. USING [remove_extent<TType>::type] pre NON C-ARRAY TYPES vracia povodny TYPE.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
103. Pre TYPE TRAIT [remove_all_extents<TType>] platia nasledujuce fakty.
   A. USING [remove_all_extents<TType>::type] pre C-ARRAY TYPES vracia TYPE z ktoreho su odstranene vsetky urovne C-ARRAYS.
   B. USING [remove_all_extents<TType>::type] pre NON C-ARRAY TYPES vracia povodny TYPE.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
104. Pre TYPE TRAIT [decay<TType>] platia nasledujuce fakty.
   A. TYPE TRAIT [decay<TType>] NAJPRV aplikuje TYPE TRAIT [remove_reference<TType>].
   B. Ak vysledny TYPE je C-ARRAY TYPE, tak USING [decay<TType>::type] vracia POINTER TYPE na NON C-ARRAY POINTER TYPE.
   C. Ak vysledny TYPE je FUNCTION TYPE, tak USING [decay<TType>::type] vracia TYPE [add_pointer<TType>::type].
   D. Pre vsetky ostatne TYPES su z TYPE odstranene MODIFIER [const] a MODIFIER [volatile].
105. Pre TYPE TRAIT [enable_if<CONDITION,TType>] platia nasledujuce fakty.
   A. USING [enable_if<CONDITION,TType>::type] vracia TYPE [TType], ak CONDITION vracia VALUE [true].
   B. USING [enable_if<CONDITION,TType>::type] NIE JE DEFINED, ak CONDITION vracia VALUE [false].
106. Pre TYPE TRAIT [conditional<CONDITION,TTrue,TFalse>] platia nasledujuce fakty.
   A. USING [conditional<CONDITION,TTrue,TFalse>::type] vracia TYPE [TTrue], ak CONDITION vracia VALUE [true].
   B. USING [conditional<CONDITION,TTrue,TFalse>::type] vracia TYPE [TFalse], ak CONDITION vracia VALUE [false].
   !!! C. TYPE TRAIT [conditional<CONDITION,TTrue,TFalse>] robi VZDY EVALUATION TYPE [TTrue], aj TYPE [TFalse], takze obe BRANCHES MUSIA vraciat VALIDNE TYPES.
107. Pre TYPE TRAIT [common_type<TTypes...>] platia nasledujuce fakty.
   A. USING [common_type<TTypes...>::type] vracia COMMON TYPE zo vsetkych TYPES [TTypes]. Na vysledny TYPE je aplikovany TYPE TRAIT decay<TType>.
   B. USING [common_type<TTypes...>::type] je UNDEFINED, ake NEEXISTUJE COMMON TYPE zo vsetkych TYPES [TTypes].
   C. Pre CUSTOM TYPES je mozne definovat SPECIALIZATIONS, ktore urcia COMMON TYPES.
108. Pre TYPE TRAIT [conjunction<CONDITIONS...>] platia nasledujuce fakty.
   A. VALUE [conjunction<CONDITIONS...>::type] vracia VALUE [true], ak vsetky CONDITIONS [CONDITIONS] maju VALUE [true].
   B. VALUE [conjunction<CONDITIONS...>::type] vracia VALUE [false], ak aspon 1 z CONDITIONS [CONDITIONS] ma VALUE [false].
   !!! C. TEMPLATE PARAMETERS MUSIA definovat INTERNAL TYPE [CONDITIONS::value].
   D. VALUE [conjunction<CONDITIONS...>::type] logicky zodpoveda OPERATOR [OPERATOR&&].
   !!! E. TYPE TRAIT nevykonava EVALUATION vsetkych CONDITIONS, ak zisti vysledok.
   !!!!! F. TYPE TRAIT ma vyznam, ak by EVALUATION niektorej z CONDITION sposobil UNDEFINED BEHAVIOR. Pri pouziti TYPE TRAIT je mozne tomu zabranit tym, ze sa vysledok urci este pred EVALUATION danej CONDITION. Alternativne pouzitie OPERATOR [OPERATOR&&] by sposobilo COMPILATION ERROR.
109. Pre TYPE TRAIT [disjunction<CONDITIONS...>] platia nasledujuce fakty.
   A. VALUE [disjunction<CONDITIONS...>::type] vracia VALUE [true], ak aspon 1 z CONDITIONS [CONDITIONS] ma VALUE [true].
   B. VALUE [disjunction<CONDITIONS...>::type] vracia VALUE [false], ak vsetky CONDITIONS [CONDITIONS] maju VALUE [false].
   !!! C. TEMPLATE PARAMETERS MUSIA definovat INTERNAL TYPE [CONDITIONS::value].
   D. VALUE [disjunction<CONDITIONS...>::type] logicky zodpoveda OPERATOR [OPERATOR||].
   !!! E. TYPE TRAIT nevykonava EVALUATION vsetkych CONDITIONS, ak zisti vysledok.
   !!!!! F. TYPE TRAIT ma vyznam, ak by EVALUATION niektorej z CONDITION sposobil UNDEFINED BEHAVIOR. Pri pouziti TYPE TRAIT je mozne tomu zabranit tym, ze sa vysledok urci este pred EVALUATION danej CONDITION. Alternativne pouzitie OPERATOR [OPERATOR||] by sposobilo COMPILATION ERROR.
110. Pre TYPE TRAIT [negation<CONDITION>] platia nasledujuce fakty.
   A. VALUE [negation<CONDITION>::type] vracia VALUE [true], ak CONDITION [CONDITION] ma VALUE [false].
   B. VALUE [negation<CONDITION>::type] vracia VALUE [false], ak CONDITION [CONDITION] ma VALUE [true].
   !!! C. TEMPLATE PARAMETER MUSI definovat INTERNAL TYPE [CONDITION::value].
   D. VALUE [negation<CONDITION>::type] logicky zodpoveda OPERATOR [OPERATOR!].
111. Pre TYPE TRAIT [declval<TType>] platia nasledujuce fakty.
   A. TYPE TRAIT je definovany v LIBRARY [utility].
   B. VALUE [declval<TType>::type] pre NON-REFERENCE TYPES a pre RVALUE REFERENCE TYPES vracia TYPE [TType&&].
   C. VALUE [declval<TType>::type] pre LVALUE REFERENCE TYPES vracia TYPE [TType&].
   D. VALUE [declval<TType>::type] pre TYPE [void] vracia TYPE [void].
   !!! E. VALUE [declval<TType>::type] vracia TYPE aj pre NON CONSTRUCTIBLE TYPES, ako napriklad TYPES, ktore maju DELETED CONSTRUCTORS.
   !!!!! F. TYPE TRAIT je mozne pouzit IBA v UNEVALUATED CONTEXTS. Typickym pouzitim je pouzitie v OPERATOR [decltype()].
112. TEMPLATE FUNCTION [template<typename TType> constexpr T* addressof(TType& Parameter) noexcept] vracia ADDRESS zadaneho OBJECT a to aj vtedy, ak pre dany OBJECT je pretazeny OPERATOR [OPERATOR&]. TEMPLATE FUNCTION je definovana v LIBRARY [memory].
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
C++ vykonava REFERENCE COLLAPSING. Pre REFERENCE COLLAPSING platia nasledujuce fakty.

1. LVAUE REFERENCE na LVALUE REFERENCE sa transformuje na LVALUE REFERENCE. To znamena, ze TYPE [int& &] sa transformuje na TYPE [int&].
2. RVLAUE REFERENCE na LVALUE REFERENCE sa transformuje na LVALUE REFERENCE. To znamena, ze TYPE [int& &&] sa transformuje na TYPE [int&].
3. LVAUE REFERENCE na RVALUE REFERENCE sa transformuje na LVALUE REFERENCE. To znamena, ze TYPE [int&& &] sa transformuje na TYPE [int&].
!!! 4. RVLAUE REFERENCE na RVALUE REFERENCE sa transformuje na RVALUE REFERENCE. To znamena, ze TYPE [int& &&] sa transformuje na TYPE [int&&].
!!!!! 5. Pri REFERENCE COLLAPSING plati, ze IBA RVLAUE REFERENCE na RVALUE REFERENCE sa transformuje na RVALUE REFERENCE. Vsetky ostatne REFERENCES sa transformuju na LVALUE REFERNCES.
//----------------------------------------------------------------------------------------------------------------------