//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie TEMPLATES a CLASS INHERITANCE.
2. EMPTY CLASSES, ktore nemaju ziadne FIELDS, ani VIRTUAL METHODS maju v C++ VZDY NENULOVU DLZKU.
3. C++ COMPILER moze pre EMPTY CLASSES implementovat EMPTY BASE CLASS OPTIMIZATION. Pre tuto OPTIMIZATION platia nasledujuce fakty.
   A. EMPTY CLASS nesmie mat NIKDY 0 dlzku.
   B. Ak je EMPTY CLASS [BASE] BASE CLASS DERIVED CLASS [DERIVED], COMPILER MOZE vykonat OPTIMIZATION, kedy dlzka tejto BASE CLASS [BASE] v DERIVED CLASS [DERIVED] MOZE mat DLZKU 0. No ak sa EMPTY CLASS [BASE] pouzije samostatne, MUSI mat NENULOVU DLZKU.
   !!! C. Ak sa EMPTY CLASS [BASE] v dedicskej hierarchii DERIVED CLASS [DERIVED] nachadza VIACNASOBNE, pretoze EMPTY CLASS [BASE] bola DERIVED z viacerych vetiev dedicskej hierarchii, tak EMPTY CLASS [BASE] ani v jednom pripade NESMIE mat 0 DLZKU. Tym je zabezpecene, ze ak sa na viacero OBJECTS EMPTY CLASS [BASE] v OBJECT TYPE DERIVED CLASS [DERIVED] referuje CODE pomocou jej ADDRES, jednotlive ADDRESSES budu ROZNE.
   !!! D. EMPTY BASE CLASS OPTIMIZATION sa NEAPLIKUJE na CLASSES, ktore ako FIELDS maju EMPTY TYPES. Je to preto, ze ak by sa tieto FIELDS zlucili, nebolo by pre kazdy FIELD moze ziskat unikatny POINTER na MEMBER.
4. CURIOUSLY RECURRING TEMPLATE PATTERN je PATTERN, ked DERIVED CLASS ma za BASE CLASS TEMPLATE CLASS, ktorej TEMPLATE PARAMETER je TYPE DERIVED CLASS. Pre CURIOUSLY RECURRING TEMPLATE PATTERN platia nasledujuce fakty.
   A. DERIVED CLASS moze byt TEMPLATE CLASS, alebo NON-TEMPLATE CLASS.
   B. BASE CLASS MUSI byt TEMPLATE CLASS, ktorej TEMPLATE PARAMETER je TYPE DERIVED CLASS.
   C. PATTERN sa vyuziva napriklad pre implementaciu spolocnej funkcionality ako napriklad OBJECT COUNTER, ktoru je mozne implementovat v BASE CLASS bez nutnosti volat VIRTUAL METHODS DERIVED CLASS.
5. RESTRICTED TEMPLATE EXPANSION PATTERN je PATTERN, vyuziva fakt, ze FRIEND FUNCTIONS definovane v TEMPLATE CLASSES su viditelne aj v PARENT SCOPE ako je PARENT CLASS, alebo PARENT NAMESPACE. RESTRICTED TEMPLATE EXPANSION PATTERN sa implementuje nasledovne.
   A. TEMPLATE CLASS definuje v CLASS SCOPE (v BODY danej CLASS) INLINE FRIEND FUNCTION, ktora ma aspon 1 PARAMETER TYPE TEMPLATE CLASS v ktorej je FRIEND FUNCTION DEFINED.
   B. Takato FRIEND FUNCTION je pomocou ARGUMENT DEPENDENT LOOKUP viditelna aj v PARENT SCOPE danej TEMPLATE CLASS co je bud PARENT CLASS SCOPE, alebo NAMESPACE SCOPE.
   !!! C. FRIEND FUNCTION vsak NIE JE VIDITELNA v PARENT SCOPE AUTOMATICKY, ale iba na zaklade aplikovania ARGUMENT DEPENDENT LOOKUP. ARGUMENT DEPENDENT LOOKUP vyzaduje, aby aspon 1 PARAMETER FRIEND FUNCTION bol TYPE TEMPLATE CLASS v ktorej je FRIEND FUNCTION definovana. Ak je, tak takuto FRIEND FUNCTION C++ pomocou ARGUMENT DEPENDENT LOOKUP najde.
!!! 6. CURIOUSLY RECURRING TEMPLATE PATTERN je mozne pouzit aj na implementaciu FACADE PATTERN. Pre FACADE PATTERN platia nasledujuce fakty.
   A. FACADE PATTERN umoznuje implementovat PUBLIC INTERFACE v BASE CLASS, ktory vyuziva maly SUBSET METHODS, ktore musi DERIVED CLASS implementovat, aby bol implementovany cely PUBLIC INTERFACE.
   B. BASE CLASS je implementovany pomocou CURIOUSLY RECURRING TEMPLATE PATTERN co znamena, ze obsahuje TYPE DERIVED CLASS.
   !!! C. BASE CLASS definuje vsetky METHODS PUBLIC INTERFACE. METHODS nie su v BASE CLASS iba DECLARED, ale DEFINED. To znamena, ze BASE CLASS obsahuje implementaciu tychto METHODS PUBLIC INTERFACE.
   !!!!! D. Pri implementacii METHODS PUBLIC INTERFACE je pouzivany maly PRIVATE INTERFACE z DERIVED CLASS, ktory BASE CLASS ocakava, ze DERIVED CLASS bude implementovat. BASE CLASS teda pri implementacii METHODS PUBLIC INTERFACE interne vola METHODS DERIVED CLASS, ktore musia vsetky DERIVED CLASSES implementovat.
   E. DERIVED CLASS dedi z BASE CLASS a implementuje iba daleko mensi INTERFACE tvoreny METHODS, ktore BASE CLASS vyzaduje od DERIVED CLASS.
   !!! F. PRIVATE INTERFACE implementovany v DERIVED CLASS by mal byt PUBLIC, aby k nemu mohol BASE CLASS pristupovat. No implementovanim STATIC INTERFACE CLASS, ktora ma PRIVATE METHODS a je FRIEND voci BASE CLASS a DERIVED CLASS z nej robi svoj FRIEND je mozne implementovat PRIVATE INTERFACE ako PRIVATE METHODS DERIVED CLASS.
   G. FACADE PATTERN umoznuje vytvorit ADAPTERS, ktore modifikuju povodnu implementaciu FACADE. ADAPTERS sa implementuju ako DERIVED CLASSES, ktore modifikuju implementuju METHODS PRIVATE INTERFACE tak, aby vykonavali cinnost ADAPTERS.
7. MIXINS je PATTERN, kedy je mozne CLASS nadizajnovat tak, aby mohla byt rozsirena o ine CLASSES bez nutnosti, aby tieto ine CLASSES, boli DERIVED z povodnej CLASS. MIXINS sa vyuzivaju vtedy, ak je potrebne aby povodnu CLASS bolo mozne rozsirit bez aplikovania INHERITANCE. Pre MIXINS platia nasledujuce fakty.
   A. Definuje sa MIXIN CLASS, ktora je VARIADIC TEMPLATE CLASS. MIXIN CLASS ma ako TEMPLATE PARAMETER typu TYPE TEMPLATE PARAMETER PACK, ktory moze obsahovat <0-N> TYPE TEMPLATE PARAMETERS.
   B. MIXIN CLASS je DERIVED zo vsetkych TYPES v PARAMETER PACK. Vdaka tomu je zarucene, ze MIXIN CLASS je mozne rozsirovat o dalsie CLASSES.
   C. Ak je MIXIN CLASS potrebne rozsirit o dalsie ADDITIONAL CLASSES, definuju sa tieto ADDITIONAL CLASSES a nasledne sa pouziju ako TEMPLATE ARGUMENTS v PARAMETER PACK MIXIN CLASS. ADDITIONAL CLASSES NIE SU DERIVED z MIXIN CLASS a rozsiruju ju tak, ze MIXIN CLASS dedi z tychto ADDITIONAL CLASSES.
8. MIXINS PATTERN je mozne kombinovat s CURIOUSLY RECURRING TEMPLATE PATTERN. V takom pripade ADDITIONAL CLASSES maju ako TYPE TEMPLATE PARAMETER MIXIN CLASS. Platia nasledujuce fakty.
   A. Definuje sa MIXIN CLASS, ktora je VARIADIC TEMPLATE CLASS. MIXIN CLASS ma ako TEMPLATE PARAMETER typu TEMPLATE TEMPLATE PARAMETER PACK, ktory moze obsahovat <0-N> TEMPLATE TEMPLATE PARAMETERS. TEMPLATE TEMPLATE PARAMETERS predstavuju ADDITIONAL CLASSES, ktore su implementovane ako TEMPLATE CLASSES s TYPE TEMPLATE PARAMETER obsahujuci MIXIN (DERIVED) CLASS.
   !!!!! B. MIXIN CLASS je DERIVED zo vsetkych TEMPLATE TEMPLATE PARAMETERS v TEMPLATE PARAMETER PACK. Vdaka tomu je zarucene, ze MIXIN CLASS je mozne rozsirovat o dalsie ADDITIONAL CLASSES, ktore vsak musia byt TEMPLATE CLASSES a ich TYPE TEMPLATE PARAMETER je MIXIN (DERIVED) CLASS.
   !!! C. Ak je MIXIN CLASS potrebne rozsirit o dalsie ADDITIONAL CLASSES, definuju sa tieto ADDITIONAL CLASSES ako TEMPLATE CLASSES, ktore maju ako TYPE TEMPLATE PARAMETER MIXIN (DERIVED) CLASS. Nasledne sa tieto TEMPLATE CLASSES pouziju ako TEMPLATE ARGUMENTS v TEMPLATE PARAMETER PACK MIXIN CLASS. Kedze TEMPLATE CLASSES maju ako TEMPLATE PARAMETER MIXIN (DERIVED) CLASS, mozu ju vyuzivat a vyuzivat vyhody CURIOUSLY RECURRING TEMPLATE PATTERN.
9. MIXINS PATTERN moze ovplyvnovat aj to ci jednotlive METHODS MIXIN (DERIVED) CLASS budu VIRTUAL, alebo NON-VIRTUAL. MIXINS PATTERN mozne pre tento ucel vyuzit v nasledujucich krokoch.
   A. Definuje sa MIXIN CLASS, ktora sluzi ako BASE CLASS. V MIXIN CLASS sa definuju METHODS, ktore mozu byt VIRTUAL, alebo mozu byt NON-VIRTUAL. Tieto METHODS NIE su oznacene pomocou KEYWORD [virtual].
   B. Definuje sa DERIVED CLASS, ktora dedi z MIXIN CLASS. V DERIVED CLASS sa definuju METHODS s tymi istymi PROTOTYPES ako v MIXIN CLASS, ktore mozu byt VIRTUAL, alebo mozu byt NON-VIRTUAL. METHODS NIE su oznacene pomocou KEYWORD [virtual].
   !!! C. Definuju sa ADDITIONAL CLASSES. V tychto ADDITIONAL CLASSES sa definuju METHODS s tymi istymi PROTOTYPES ako v MIXIN CLASS. Tie ktore maju byt volane ako VIRTUAL su oznacene KEYWORD [virtual], a tie METHODS, ktore maju byt volane ako NON-VIRTUAL NIE su oznacene pomocou KEYWORD [virtual].
   !!!!! D. Na zaklade toho, ktore ADDITIONAL CLASSES aplikovali v v MIXIN CLASS a ci svoje METHODS maju, alebo nemaju oznacene pomocou KEYWORD [virtual] sa METHODS v MIXIN CLASS a DERIVED CLASS bud budu vola ako VIRTUAL, alebo ako NON-VIRTUAL.
10. C++ umoznuje aby DERIVED CLASS mala ako BASE CLASS rovnaku TEMPLATE CLASS, ak sa TEMPLATE ARGUMENTS vsetkych TEMPLATE CLASSES rovnakeho TYPE vzajomne lisia.
11. NAMED TEMPLATE ARGUMENTS PATTERN je technika, ktora umoznuje v TEMPLATE CLASS, ktora v TEMPLATE PARAMETER LIST ma pre viacere TYPE TEMPLATE PARAMETERS definovane DEFAULT VALUES, aby tieto DEFAULT VALUES mohli byt nahradene za ine TYPES bez ohladu na poradie v akom su DEFAULT VALUES nastavene v TEMPLATE PARAMETER LIST. Pre NAMED TEMPLATE ARGUMENTS PATTERN platia nasledujuce fakty.
   A. NAMED TEMPLATE ARGUMENTS PATTERN vyuziva to, ze TEMPLATE CLASS moze byt DERIVED z TYPE TEMPLATE PARAMETERS. Pouzitie INHERITANCE umoznuje zmenit lubovolny DEFAULT VALUE TYPE bez ohladu na poradie v akom su DEFAULT VALUES v TEMPLATE PARAMETER LIST ulozene.
   B. NAMED TEMPLATE ARGUMENTS CLASS ma pre kazdy TEMPLATE PARAMETER z TEMPLATE PARAMETER LIST ako DEFAULT VALUE instanciu DEFAULT POLICY ARGUMENTS HELPER CLASS. DEFAULT POLICY ARGUMENTS HELPER CLASS je VIRTUALLY DERIVED z DEFAULT POLICIES HELPER CLASS. DEFAULT POLICIES HELPER CLASS definuje USINGS pre jednotlive DEFAULT VALUES z TEMPLATE PARAMETER LIST.
   C. NAMED TEMPLATE ARGUMENTS CLASS, ktora implementuje NAMED TEMPLATE ARGUMENTS PATTERN musi pomocou KEYWORD [using] definovat POLICY SELECTOR CLASS, ktora ma definovane TYPE TEMPLATE PARAMETERS pomocou KEYWORD [using].
   D. POLICY SELECTOR CLASS je DERIVED zo vsekych TYPE TEMPLATE PARAMETERS, ktore NAMED TEMPLATE ARGUMENTS CLASS definuje. Casto sa pouziva DISCRIMINATOR HELPER CLASS, aby POLICY SELECTOR CLASS mohla dedit z TYPE TEMPLATE PARAMETERS aj v pripade, ze 2 TYPE TEMPLATE PARAMETERS su ROVNAKEHO TYPE. DISCRIMINATOR HELPER CLASS pouziva VALUE TEMPLATE PARAMETER na to, aby sa vytvoril unikatny TYPE, ktory je nezavisly na inych TYPE TEMPLATE PARAMETERS a NAMED TEMPLATE ARGUMENTS CLASS z neho mohla byt DERIVED.
   !!! E. Pre definovanie CUSTOM DEFAULT ARGUMENTS je nutne definovat samotnu CUSTOM CLASS a nasledne aj USE POLICY HELPER CLASS. USE POLICY HELPER CLASS je VIRTUALLY DERIVED z DEFAULT POLICIES HELPER CLASS a zaroven meni niektory USING, ktory definovala DEFAULT POLICIES HELPER CLASS.
   !!!!! F. C++ vdaka aplikovaniu DOMINATION RULE pre USINGS v DERIVED CLASS aplikuje USING definovany v USE POLICY HELPER CLASS, a nie povodny USING definovany v DEFAULT POLICIES HELPER CLASS.
//----------------------------------------------------------------------------------------------------------------------