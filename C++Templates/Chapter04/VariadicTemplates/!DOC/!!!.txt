//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie VARIADIC TEMPLATES v C++.
2. C++ od verzie C++11 umoznuje definovat VARIADIC TEMPLATES. VARIADIC TEMPLATES su TEMPLATES, ktore mozu mat lubovolny POCET a TYPES svojich TEMPLATE PARAMETERS.
3. C++ umoznuje definovat nasledujuce typy VARIADIC TEMPLATES.
   A. VARIADIC TEMPLATE CLASSES.
   B. VARIADIC TEMPLATE FUNCTIONS.
   C. VARIADIC TEMPLATE VARIABLES.
   D. VARIADIC TEMPLATE ALIASES.
4. VARIADIC TEMPLATES su TEMPLATES, ktore obsahuju TEMPLATE PARAMETER PACK. Pre TEMPLATE PARAMETER PACK platia nasledujuce fakty.
   A. TEMPLATE PARAMETER PACK obsahuje 0-N TEMPLATE ARGUMENTS.
   B. TEMPLATE PARAMETER PACK pouzity v TEMPLATE FUNCTION PROTOTYPE definuje 0-N FUNCTION ARGUMENTS.
   C. Ak TEMPLATE PARAMETER PACK obsahuje TYPE TEMPLATE PARAMETERS ma SYNTAX [typename... NAME], kde VALUE 'NAME' predstavuje nazov TEMPLATE PARAMETER PACK.
   D. Ak TEMPLATE PARAMETER PACK obsahuje NON-TYPE TEMPLATE PARAMETERS ma SYNTAX [TYPE... NAME], kde VALUE 'TYPE' je TYPE NON-TYPE TEMPLATE PARAMETERS a VALUE 'NAME' predstavuje nazov TEMPLATE PARAMETER PACK.
5. VARIADIC TEMPLATES vychadzaju z nasledujucich principov.
   A. VARIADIC TEMPLATES mozu mat variabliny pocet TEMPLATE PARAMETERS.
   !!! B. VARIADIC TEMPLATES spracovaju TEMPLATE PARAMETERS REKURZIVNE. To znamena, ze VARIADIC TEMPLATE spracuje 1. PARAMETER a nasledne rekurzivne vola VARIADIC TEMPLATE pre ostatne TEMPLATE PARAMETERS.
   C. VARIADIC TEMPLATES maju TEMPLATE PARAMETERS ulozene v TEMPLATE PARAMETER PACK.
   D. TEMPLATE PARAMETER PACK moze byt rozbaleny pomocou OPERATOR [...].
!!! 6. VARIADIC TEMPLATE CLASSES sa definuju v nasledujucich krokoch.
   A. Vykona sa DECLARATION (nie DEFINITION) VARIADIC TEMPLATE CLASS.
   B. Vykona sa DEFINITION VARIADIC TEMPLATE CLASS SPECIALIZATION pre RECURSIVE CASE.
   C. Vykona sa DEFINITION VARIADIC TEMPLATE CLASS SPECIALIZATION pre FINAL RECURSION CASE.
!!! 7. DECLARATION (nie DEFINITION) VARIADIC TEMPLATE CLASS sa vykonava na nasledujucich krokoch.
   A. DECLARATION sa vykonava pomocou SYNTAX [template<typename... TYPES> class CLASS_NAME], kde VALUE 'TYPES' reprezentuje TEMPLATE PARAMETER PACK a zaroven urcuje, ze sa jedna o VARIADIC TEMPLATE CLASS a VALUE 'CLASS_NAME' je nazov CLASS.
   B. Vykona sa iba DECLARATION, NIE DEFINITION VARIADIC TEMPLATE CLASS, kedze CODE VARIADIC TEMPLATE CLASS je definovany az vo VARIADIC TEMPLATE CLASS SPECIALIZATIONS.
!!! 8. DEFINITION VARIADIC TEMPLATE CLASS SPECIALIZATION pre RECURSIVE CASE sa vykonava na nasledujucich krokoch.
   A. DEFINITION sa vykonava pomocou SYNTAX [template<typename THIS, typename... TYPES> class CLASS_NAME<THIS,TYPES...>], kde VALUE 'THIS' reprezentuje 1. TEMPLATE TYPE PARAMETER, VALUE 'TYPES' je TEMPLATE PARAMETER PACK obsahujuci vsetky ostatne TEMPLATE TYPE PARAMETERS a VALUE 'CLASS_NAME' je nazov CLASS.
   B. VARIADIC TEMPLATE CLASS SPECIALIZATION pre RECURSIVE CASE obsahuje DEFINITION FIELDS a vsetkych METHODS, ktore dana VARIADIC TEMPLATE CLASS definuje.
   !!! C. Ak su METHODS definovane MIMO SCOPE VARIADIC TEMPLATE CLASS SPECIALIZATION, tak sa pouziva SYNTAX [template<typename THIS, typename... TYPES> RETURN_VALUE_TYPE CLASS_NAME<THIS,TYPES...>::METHOD_PROTOTYPE], kde VALUE 'THIS' reprezentuje 1. TEMPLATE TYPE PARAMETER, VALUE 'TYPES' je TEMPLATE PARAMETER PACK obsahujuci vsetky ostatne TEMPLATE TYPE PARAMETERS, VALUE 'RETURN_VALUE_TYPE' je RETURN VALUE TYPE danej METHOD, VALUE 'CLASS_NAME' je nazov CLASS a VALUE 'METHOD_PROTOTYPE' je METHOD PROTOTYPE.
   !!!!! D. METHODS VARIADIC TEMPLATE CLASS SPECIALIZATION pre RECURSIVE CASE MUSIA vo svojom CODE po spracovani 1. TEMPLATE PARAMETER REKURZIVNE volat SAMI SEBA, aby spracovali ostatne TEMPLATE PARAMETERS. Na rekurzivne volanie METHODS sa pouziva OPERATOR [TYPES...], kde VALUE 'TYPES' je TEMPLATE PARAMETER PACK obsahujuci vsetky ostatne TEMPLATE TYPE PARAMETERS.
!!! 9. DEFINITION VARIADIC TEMPLATE CLASS SPECIALIZATION pre FINAL RECURSION CASE sa vykonava na nasledujucich krokoch.
   A. DEFINITION sa vykonava pomocou SYNTAX [template<> class CLASS_NAME<>], kde VALUE 'CLASS_NAME' je nazov CLASS.
   B. VARIADIC TEMPLATE CLASS SPECIALIZATION pre FINAL RECURSION CASE obsahuje DEFINITION vsetkych METHODS, ktore dana VARIADIC TEMPLATE CLASS definuje.
   !!! C. Ak su METHODS definovane MIMO SCOPE VARIADIC TEMPLATE CLASS SPECIALIZATION, tak sa pouziva SYNTAX [template<> RETURN_VALUE_TYPE CLASS_NAME<>::METHOD_PROTOTYPE], kde VALUE 'RETURN_VALUE_TYPE' je RETURN VALUE TYPE danej METHOD, VALUE 'CLASS_NAME' je nazov CLASS a VALUE 'METHOD_PROTOTYPE' je METHOD PROTOTYPE.
   !!!!! D. METHODS VARIADIC TEMPLATE CLASS SPECIALIZATION pre FINAL RECURSION CASE su volane na konci RECURSION, a preto NEMAJU ZIADNE PARAMETERS.
!!! 10. VARIADIC TEMPLATE FUNCTIONS sa definuju v nasledujucich krokoch.
   A. Vykona sa DEFINITION VARIADIC TEMPLATE FUNCTION pre RECURSIVE CASE.
   B. Vykona sa DEFINITION NON-TEMPLATE FUNCTION pre FINAL RECURSION CASE.
!!! 11. DEFINITION VARIADIC TEMPLATE FUNCTION pre RECURSIVE CASE sa vykonava na nasledujucich krokoch.
   A. DEFINITION sa vykonava pomocou SYNTAX [template<typename THIS, typename... TYPES> FUNCTION_PROTOTYPE], kde VALUE 'THIS' reprezentuje 1. TEMPLATE TYPE PARAMETER, VALUE 'TYPES' je TEMPLATE PARAMETER PACK obsahujuci vsetky ostatne TEMPLATE TYPE PARAMETERS a VALUE 'FUNCTION_PROTOTYPE' je FUNCTION PROTOTYPE.
   !!!!! B. VARIADIC TEMPLATE FUNCTION pre RECURSIVE CASE MUSI vo svojom CODE po spracovani 1. TEMPLATE PARAMETER REKURZIVNE volat SAMU SEBA, aby boli spracovane ostatne TEMPLATE PARAMETERS. Na rekurzivne volanie FUNCTION sa pouziva OPERATOR [TYPES...], kde VALUE 'TYPES' je TEMPLATE PARAMETER PACK obsahujuci vsetky ostatne TEMPLATE TYPE PARAMETERS.
!!! 12. DEFINITION NON-TEMPLATE FUNCTION pre FINAL RECURSION CASE sa vykonava na nasledujucich krokoch.
   A. DEFINITION sa vykonava pomocou SYNTAX [FUNCTION_PROTOTYPE], kde VALUE 'FUNCTION_PROTOTYPE' je FUNCTION PROTOTYPE.
   B. NON-TEMPLATE FUNCTION pre FINAL RECURSION CASE je volana na konci RECURSION, a preto NEMA ZIADNE PARAMETERS.
!!!!! 13. C++ 17 umoznuje OVERLOADING VARIADIC TEMPLATES. Pre OVERLOADING VARIADIC TEMPLATES platia nasledujuce fakty.
   !!! A. Ak existuju 2 OVERLOADED VARIADIC TEMPLATES, kde jedna VARIADIC TEMPLATE ma TEMPLATE PARAMETER PACK a druha VARIADIC TEMPLATE nema TEMPLATE PARAMETER PACK, tak je preferovana verzia, ktora NEMA TEMPLATE PARAMETER PACK.
   B. OVERLOADING VARIADIC TEMPLATES sa aplikuje na VARIADIC TEMPLATE CLASSES a VARIADIC TEMPLATE FUNCTIONS.
   !!!!! C. OVERLOADING VARIADIC TEMPLATES umoznuje definovat VARIADIC TEMPLATES pre FINAL RECURSION CASE nie ako BEZPARAMETRICKE VARIADIC TEMPLATE CLASS SPECIALIZATIONS, alebo BEZPARAMETRICKE VARIADIC TEMPLATE FUNCTIONS, ale ako VARIADIC TEMPLATES s 1 PARAMETER. Ak sa pouziva VARIADIC TEMPLATE s 1 PARAMETER, tak C++ uprednostni TEMPLATE, ktora ma iba 1 TEMPLATE PARAMETER a NEMA definovany TEMPLATE PARAMETER PACK.
14. C++ definuje OPERATOR [sizeof...()]. Pre OPERATOR [sizeof...()] platia nasledujuce fakty.
   A. OPERATOR [sizeof...(EXPRESSION)] pre EXPRESSION 'EXPRESSION' vracia pocet TEMPLATE PARAMETERS, alebo TEMPLATE FUNCTION PARAMETERS, ktore su TYPE TEMPLATE PARAMETER PACK.
   B. OPERATOR [sizeof...(EXPRESSION)] moze byt aplikovany na TEMPLATE PARAMETER definovany v KEYWORD [template<>], alebo na TEMPLATE FUNCTION PARAMETERS, ktore su TYPE TEMPLATE PARAMETER PACK.
   !!!!! C. Pomocou OPERATOR [sizeof...(EXPRESSION)] a COMPILE TIME KEYWORD [if constexpr] je mozne implementovat VARIADIC TEMPLATES aj BEZ DEFINICIE VARIADIC TEMPLATES pre FINAL RECURSION CASE.
15. C++ 17 umoznuje definovat VARIADIC TEMPLATES bez nutnosti definicie specializovanych VARIADIC TEMPLATES pre FINAL RECURSION CASE.
   A. VARIADIC TEMPLATE FUNCTIONS su definovane pre VSETKY RECURSION CASES, vratane FINAL RECURSION CASE.
   !!!!! B. Vo VARIADIC TEMPLATE FUNCTIONS je pomocou KEYWORD [if constexpr] vykonany test ci FUNCTION ma volat dalsiu RECURSION. V pripade, ze pocet TEMPLATE PARAMETERS je rovny 0, tak sa dalsia RECURSION NEVYKONA. Vdaka KEYWORD [if constexpr] sa KOMPILUJE bud iba TRUE BRANCH, alebo FALSE BRANCH. To umoznuje volat dalsiu RECURSION iba ak je pocet VARIADIC TEMPLATE PARAMETERS vacsi ako 1, pricom pre FINAL RECURSION CASE sa CODE volajuci FUNCTION s 0 TEMPLATE PARAMETERS VOBEC NEKOMPILUJE a tym padom COMPILER ani NEHODI COMPILARION ERROR.
   !!! C. Tento postup je mozne aplikovat na VARIADIC TEMPLATE CLASSES aj VARIADIC TEMPLATE FUNCTIONS.
16. C++ 17 podporuje FOLD EXPRESSIONS. Pre FOLD EXPRESSIONS platia nasledujuce fakty.
   A. FOLD EXPRESSIONS umonzuju volat pre TEMPLATE PARAMETER PACK BINARY OPERATORS.
   B. Pri FOLD EXPRESSIONS je TEMPLATE PARAMETER PACK rozlozeny na jednotlive PARAMETERS medzi ktore je aplikovany definovany BINARY OPERATOR.
   C. FOLD EXPRESSIONS podporuju BINARY OPERATORS [OPERATOR+], [OPERATOR-], [OPERATOR*], [OPERATOR/], [OPERATOR%], [OPERATOR^], [OPERATOR&], [OPERATOR|], [OPERATOR=], [OPERATOR<], [OPERATOR>], [OPERATOR<<], [OPERATOR>>], [OPERATOR+=], [OPERATOR-=], [OPERATOR*=], [OPERATOR/=], [OPERATOR%=], [OPERATOR^=], [OPERATOR&=], [OPERATOR|=], [OPERATOR<<=], [OPERATOR>>=], [OPERATOR==], [OPERATOR!=], [OPERATOR<=], [OPERATOR>=], [OPERATOR&&], [OPERATOR||], [OPERATOR,], [OPERATOR.*] a [OPERATOR->*].
   D. FOLD EXPRESSIONS umoznuju definovat aj INITIAL VALUES.
17. C++ 17 definuje nasledujuce FOLD EXPRESSIONS.
   A. UNARY LEFT PACK FOLD EXPRESSIONS.
   B. UNARY RIGHT PACK FOLD EXPRESSIONS.
   C. BINARY LEFT PACK FOLD EXPRESSIONS.
   D. BINARY RIGHT PACK FOLD EXPRESSIONS.
18. Pre UNARY LEFT PACK FOLD EXPRESSIONS platia nasledujuce fakty.
   A. UNARY LEFT PACK FOLD EXPRESSION ma SYNTAX [(... OPERATOR PACK)], kde VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS a VALUE 'PACK' je TEMPLATE PARAMETER PACK.
   B. UNARY LEFT PACK sa interpretuje ako CODE [((((PARAMETER_1 OPERATOR PARAMETER_2) OPERATOR PARAMETER_3) ...) OPERATOR PARAMETER_N)], kde VALUES 'PARAMETER_X' reprezentuju jednotlive PARAMETERS TEMPLATE PARAMETER PACK a VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS.
   !!! C. Ak je TEMPLATE PARAMETER PACK PRAZDNY tak FOLD EXPRESSION pre [OPERATOR&&] vracia VALUE [true], pre [OPERATOR||] vracia VALUE [false], pre [OPERATOR,] vracia VALUE [void()] a pre vsetky ostatne BINARY OPERATORS hodi COMPILER ERROR.
19. Pre UNARY RIGHT PACK FOLD EXPRESSIONS platia nasledujuce fakty.
   A. UNARY RIGHT PACK FOLD EXPRESSION ma SYNTAX [(PACK OPERATOR ...)], kde VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS a VALUE 'PACK' je TEMPLATE PARAMETER PACK.
   B. UNARY RIGHT PACK sa interpretuje ako CODE [(PARAMETER_1 OPERATOR (... OPERATOR (PARAMETER_N-2 OPERATOR (PARAMETER_N-1 OPERATOR PARAMETER_N))))], kde VALUES 'PARAMETER_X' reprezentuju jednotlive PARAMETERS TEMPLATE PARAMETER PACK a VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS.
   !!! C. Ak je TEMPLATE PARAMETER PACK PRAZDNY tak FOLD EXPRESSION pre [OPERATOR&&] vracia VALUE [true], pre [OPERATOR||] vracia VALUE [false], pre [OPERATOR,] vracia VALUE [void()] a pre vsetky ostatne BINARY OPERATORS hodi COMPILER ERROR.
20. Pre BINARY LEFT PACK FOLD EXPRESSIONS platia nasledujuce fakty.
   A. BINARY LEFT PACK FOLD EXPRESSION ma SYNTAX [(INIT ... OPERATOR PACK)], kde VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS, VALUE 'PACK' je TEMPLATE PARAMETER PACK a VALUE 'INIT' je INIT VALUE.
   B. BINARY LEFT PACK sa interpretuje ako CODE [(((((INIT OPERATOR PARAMETER_1) OPERATOR PARAMETER_2) OPERATOR PARAMETER_3) ...) OPERATOR PARAMETER_N)], kde VALUES 'PARAMETER_X' reprezentuju jednotlive PARAMETERS TEMPLATE PARAMETER PACK, VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS a VALUE 'INIT' je INIT VALUE.
   !!! C. Ak je TEMPLATE PARAMETER PACK PRAZDNY tak FOLD EXPRESSION vracia VALUE 'INIT'.
21. Pre BINARY RIGHT PACK FOLD EXPRESSIONS platia nasledujuce fakty.
   A. BINARY RIGHT PACK FOLD EXPRESSION ma SYNTAX [(PACK OPERATOR ... INIT)], kde VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS, VALUE 'PACK' je TEMPLATE PARAMETER PACK a VALUE 'INIT' je INIT VALUE.
   B. BINARY RIGHT PACK sa interpretuje ako CODE [(PARAMETER_1 OPERATOR (... OPERATOR (PARAMETER_N-2 OPERATOR (PARAMETER_N-1 OPERATOR (PARAMETER_N OPERATOR INIT)))))], kde VALUES 'PARAMETER_X' reprezentuju jednotlive PARAMETERS TEMPLATE PARAMETER PACK, VALUE 'OPERATOR' je niektory z podporovanych BINARY OPERATORS a VALUE 'INIT' je INIT VALUE.
   !!! C. Ak je TEMPLATE PARAMETER PACK PRAZDNY tak FOLD EXPRESSION vracia VALUE 'INIT'.
!!!!! 22. TEMPLATE PARAMETER PACK ARGUMENT v FOLD EXPRESSIONS moze obsahovat LUBOVOLNE EXPRESSIONS ako napriklad tieto EXPRESSIONS.
   A. Volanie FUNCTION pomocou CODE [... + FUNCTION(PACK)].
   B. Volanie OPERATOR pomocou CODE [... + (PACK+10)].
   C. Volanie CONSTRUCTOR pomocou CODE [... + CLASS(PACK)].
23. TEMPLATE PARAMETER PACK je mozne prenasat nasledujucim sposobmi.
   A. BY VALUE.
   B. BY LVALUE REFERENCE.
   C. BY RVALUE REFERENCE.
24. C++ podporuje VARIADIC EXPRESSIONS. Pre VARIADIC EXPRESSIONS platia nasledujuce fakty.
   A. VARIADIC EXPRESSIONS umoznuju aplikovat PACK EXPANSION OPERATOR [OPERATOR...] v EXPRESSIONS v ktorych sa nachadza TEMPLATE PARAMETER PACK.
   !!!!! B. PACK EXPANSION OPERATOR [OPERATOR...] vykonava TEMPLATE PARAMETER PACK, kedy sa EXPRESSION rozlozi na SUBEXPRESSIONS, kde kazda SUBEXPRESSION obsahuje 1 PARAMETER z TEMPLATE PARAMETER PACK a jednotlive SUBEXPRESSION su oddelene pomocou OPERATOR [OPERATOR,].
   !!! C. To znamena, ze CODE [(PACK+PACK)...] sa rozlozi na CODE [PARAMETER_1+PARAMETER_1,PARAMETER_2+PARAMETER_2,...,PARAMETER_N+PARAMETER_N]. To znaci, ze TEMPLATE PARAMETER PACK sa rozlozi SUBEXPRESSIONS obsahujuce jednotlive PARAMETERS, kde kazda SUBEXPRESSION je oddelena od seba pomocou OPERATOR [OPERATOR,].
   !!!!! D. VARIADIC EXPRESSIONS berie CELU EXPRESSION a opakuje ju N-krat, pricom v kazdej iteracii pouzije iny TYPE PARAMETER. Preto sa vo VARIADIC EXPRESSIONS moze vyskytovat TEMPLATE PARAMETER PACK aj VIACKRAT.
25. C++ umoznuje definovat aj NON-TYPE VARIADIC TEMPLATE PARAMETERS. Pre NON-TYPE VARIADIC TEMPLATE PARAMETERS platia nasledujuce fakty.
   A. NON-TYPE VARIADIC TEMPLATE PARAMETERS sa definuju pomocou SYNTAX [TYPE... PARAMETER_NAME], kde VALUE 'TYPE' je TYPE NON-TYPE VARIADIC TEMPLATE PARAMETER a VALUE 'PARAMETER_NAME' je nazov NON-TYPE VARIADIC TEMPLATE PARAMETER.
   B. NON-TYPE VARIADIC TEMPLATE PARAMETERS podporuju vsetky TYPES ako NON-TYPE VARIADIC PARAMETERS.
26. C++ umoznuje aplikovat VARIADIC TEMPLATE PARAMETERS aj pre DEDUCTION GUIDES.
27. VARIADIC TEMPLATES sa daju aplikovat aj na KEYWORD [using].
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
Priklad pouzitia VARIADIC EXPRESSIONS.

1. VARIADIC EXPRESSION [CVariadicTemplateClassDeductionGuides<conditional_t<is_same_v<TTypes,const wchar_t*>,wstring,TTypes>...>] je VARIADIC EXPRESSION pretoze obsahuje TEMPLATE PARAMETER PACK a PACK EXPANSION OPERATOR [OPERATOR...].
2. VARIADIC EXPRESSION sa rozlozi na EXPRESSION [CVariadicTemplateClassDeductionGuides<conditional_t<is_same_v<TYPE_PARAMETER_1,const wchar_t*>,wstring,TYPE_PARAMETER_1>>,CVariadicTemplateClassDeductionGuides<conditional_t<is_same_v<TYPE_PARAMETER_2,const wchar_t*>,wstring,TYPE_PARAMETER_2>>,...,CVariadicTemplateClassDeductionGuides<conditional_t<is_same_v<TYPE_PARAMETER_N,const wchar_t*>,wstring,TYPE_PARAMETER_N>>].
3. VARIADIC EXPRESSION sa teda cela rozklada na SUBEXPRESSIONS oddelene pomocou OPERATOR [OPERATOR,] pricom v kazdej SUBEXPRESSION sa nahradzuje iba TEMPLATE PARAMETER PACK za jednotlive TYPE PARAMETERS.
//----------------------------------------------------------------------------------------------------------------------