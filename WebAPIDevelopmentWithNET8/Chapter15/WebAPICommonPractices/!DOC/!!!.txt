//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje niektore LIBRARIES, ktore sa pouzivaju vo WEB API.
2. Vo WEB PROGRAMS by sa VZDY mal pouzivat PROTOCOL [HTTPS] namiesto PROTOCOLU [HTTP].
3. Volanie METHOD [IApplicationBuilder UseHttpsRedirection(this IApplicationBuilder App)] sposobi, ze kazde volanie WEB PROGRAM cez PROTOCOL [HTTP] bude automaticky REDIRECTED, aby sa pouzil PROTOCOL [HTTPS].
4. HTTP STATUS CODES sa rozdelene do nasledujucich CATEGORIES.
   A. CATEGORY [INFORMATIONAL]. Obsahuje CODES v RANGE <100,199>.
   B. CATEGORY [SUCCESS]. Obsahuje CODES v RANGE <200,299>.
   C. CATEGORY [REDIRECTION]. Obsahuje CODES v RANGE <300,399>.
   D. CATEGORY [CLIENT ERRORS]. Obsahuje CODES v RANGE <400,499>.
   E. CATEGORY [SERVER ERRORS]. Obsahuje CODES v RANGE <500,599>.
5. Zoznam dolezitych HTTP STATUS CODES.
   A. STATUS CODE [200]. STATUS CODE DESCRIPTION [OK].
   B. STATUS CODE [201]. STATUS CODE DESCRIPTION [CREATED].
   C. STATUS CODE [202]. STATUS CODE DESCRIPTION [ACCEPTED].
   D. STATUS CODE [204]. STATUS CODE DESCRIPTION [NO CONTENT].
   E. STATUS CODE [301]. STATUS CODE DESCRIPTION [MOVED PERMANENTLY].
   F. STATUS CODE [302]. STATUS CODE DESCRIPTION [FOUND].
   G. STATUS CODE [304]. STATUS CODE DESCRIPTION [NOT MODIFIED].
   H. STATUS CODE [400]. STATUS CODE DESCRIPTION [BAD REQUEST].
   I. STATUS CODE [401]. STATUS CODE DESCRIPTION [UNAUTHORIZED].
   J. STATUS CODE [403]. STATUS CODE DESCRIPTION [FORBIDDEN].
   K. STATUS CODE [404]. STATUS CODE DESCRIPTION [NOT FOUND].
   L. STATUS CODE [405]. STATUS CODE DESCRIPTION [METHOD NOT ALLOWED].
   M. STATUS CODE [409]. STATUS CODE DESCRIPTION [CONFLICT].
   N. STATUS CODE [410]. STATUS CODE DESCRIPTION [GONE].
   O. STATUS CODE [415]. STATUS CODE DESCRIPTION [UNSUPPORTED MEDIA TYPE].
   P. STATUS CODE [422]. STATUS CODE DESCRIPTION [UNPROCESSABLE ENTITY].
   Q. STATUS CODE [429]. STATUS CODE DESCRIPTION [TOO MANY REQUESTS].
   R. STATUS CODE [500]. STATUS CODE DESCRIPTION [INTERNAL SERVER ERROR].
   S. STATUS CODE [501]. STATUS CODE DESCRIPTION [NOT IMPLEMENTED].
   T. STATUS CODE [503]. STATUS CODE DESCRIPTION [SERVICE UNAVAILABLE].
   U. STATUS CODE [504]. STATUS CODE DESCRIPTION [GATEWAY TIMEOUT].
6. HTTP definuje nasledujuce VERBS.
   A. VERB [GET]. Pouziva sa na ziskavanie obsahu RESOURCE ci RESOURCES.
   B. VERB [POST]. Pouziva sa na vlozenie noveho RESOURCE ci RESOURCES. Moze sa pouzit aj na modifikaciu obsahu RESOURCE ci RESOURCES.
   C. VERB [PUT]. Pouziva sa na modifikaciu obsahu RESOURCE ci RESOURCES.
   D. VERB [DELETE]. Pouziva sa na odstranenie existujuce RESOURCE ci RESOURCES. Moze sa pouzit aj na modifikaciu obsahu RESOURCE ci RESOURCES.
7. .NET podporuje SYNCHRONOUS a ASYNCHRONOUS PROGRAMMING MODEL. Pre ASYNCHRONOUS PROGRAMMING MODEL platia nasledujuce fakty.
   A. ASYNCHRONOUS PROGRAMMING MODEL je zalozeny na TASKS.
   B. TASK je implementovany pomocou CLASS [Task].
   C. TASKS mozu byt naviazane na ine TASKS. V taktom pripade po skonceni danej TASK sa spusti TASK, ktora je naviazana na povodny TASK.
   D. Pre METHODS pouzivajuce TASKS platia nasledujuce fakty.
      A. METHOD musi vratit TYPE [Task], alebo TYPE [Task<TTask>].
      B. METHOD musi byt oznacena pomocou KEYWORD [async].
      C. METHOD musi pri volani ASYNCHRONOUS METHOD pouzit KEYWORD [await].
   E. CLASS [Task<TResult>] vracia TASK RESULT v PROPERTY [TResult Result]. Ak TASK este neskoncil CURRENT THREAD je BLOCKED, az kym TASK neskonci.
!!! 8. CLASS [DbContext] NEPODPORUJE vykonavanie viacerych ASYNCHRONOUS OPERATIONS nad tou istou instanciu CLASS [DbContext].
9. Ak API potrebuje vrati velku COLLECTION dat, je vzdy odporucane nevracat celu COLLECTION, ale pouzit PAGINATION pre navrat RESULTS po PAGES.
10. ASP.NET CORE umoznuje oznacit ACTION METHODS pomocou ATTRIBUTE [ProducesResponseType]. Pre ATTRIBUTE [ProducesResponseType] platia nasledujuce fakty.
   A. ATTRIBUTE [ProducesResponseType] umoznuje vlozit do ACTION METHODS DESCRIPTION ake STATUS CODES a ake RESPONSE BODIES moze dana ACTION METHOD vracat.
   B. ATTRIBUTE [ProducesResponseType] moze byt na ACTION METHOD aplikovany viacnasobne, ak ACTION METHOD vracia rozne STATUS CODES a rozne RESPONSE BODIES.
   C. ATTRIBUTE [ProducesResponseType] je vyuzivany SWAGGER pre generovnie API DOCUMENTATION.
   D. Aplikaciu ATTRIBUTE [ProducesResponseType] je mozne vyziadat vlozenim OPEN API ANALYZERS do PROJECT FILE. Pre OPEN API ANALYZERS platia nasledujuce fakty.
     A. OPEN API ANALYZERS sa vklada do PROJECT vlozenim CODE [<IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>] do SECTION [PropertyGroup] PROJECT FILE.
     B. OPEN API ANALYZERS zobrazuju WARNING, ak niektore ACTION METHOD nema aplikovany ATTRIBUTE [ProducesResponseType].
11. ASP.NET CORE umoznuje automaticky generovat DOCUMENTATION pre ACTION METHODS, REQUEST TYPES a RESPONSE TYPES. Pre automaticky generovanu DOCUMETATION platia nasledujuce fakty.
   A. DOCUMENTATION sa vklada do ACTION METHODS a TYPES aplikaciou COMMENT [///].
   B. COMMENTS [///] mozu byt aplikovane na PROTOTYPES ACTION METHODS i REQUEST TYPES a RESPONSE TYPES.
   C. Automaticke generovanie DOCUMENTATION sa povoluje vlozenim vlozenim CODE [<GenerateDocumentationFile>true</GenerateDocumentationFile>] do SECTION [PropertyGroup] PROJECT FILE.
   D. SWAGGER umoznuje z COMMENTS [///] generovat SWAGGER DOCUMENTATION. Platia nasledujuce fakty.
      A. V SWAGGER SETTING je nutne zavolat METHOD [void IncludeXmlComments(this SwaggerGenOptions WwaggerGenOptions, string FilePath, bool IncludeControllerXmlComments)], aby sa povolilo automaticke generovanie SWAGGER DOCUMENTATION z COMMENTS [///].
      B. V SWAGGER SETTING OPTIONALLY mozne volat METHOD [void SwaggerDoc(this SwaggerGenOptions SwaggerGenOptions, string Name, OpenApiInfo Info)] na generovanie popisu API.
12. .NET implementuje JSON LIBRARY [System.Text.Json], ktora je nahradou za LIBRARY [Newtonsoft.Json]. Pre LIBRARY [System.Text.Json] platia nasledujuce fakty.
   A. LIBRARY [System.Text.Json] je rychlejsia ako LIBRARY [Newtonsoft.Json].
   B. LIBRARY [System.Text.Json] ma MENEJ FEATURES ako LIBRARY [Newtonsoft.Json].
   C. LIBRARY [System.Text.Json] je pouzivana ako DEFAULT LIBRARY pre ASP.NET PROJECTS.
13. ASP.NET CORE podporuje nasledujuce typy CACHING.
   A. IN MEMORY CACHING. Pri IN MEMORY CACHING su CACHED DATA ulozene v MEMORY daneho WEB PROGRAM. Pri restarte PROGRAMU dochadza k strate CACHED DATA.
   B. DISTRIBUTED CACHING. Pri DISTRIBUTED CACHING su CACHED DATA ulozene v SHARED STORAGE ako je napriklad REDIS ci SQL DATABASE. SHARED STORAGE je SHARED medzi viacerymi beziacimi instanciami WEB PROGRAM a je vhodny pre WEB FARMS, CONTAINER ORCHESTRATION ci SERVERLESS COMPUTING.
   C. RESPONSE CACHING. Pri RESPONSE CACHING je vyuzity CACHING MECHANISM HTTP PROTOCOL.
   D. OUTPUT CACHING. Pri OUTPUT CACHING su CACHED DATA ulozene v MIDDLEWARE COMPONENT na SERVER SIDE.
14. Pre IN MEMORY CACHING platia nasledujuce fakty.
   A. IN MEMORY CACHING uklada CACHE ENTRIES do LOCAL MEMORY.
   B. IN MEMORY CACHING je implementovany v LIBRARY [Microsoft.Extensions.Caching.Memory].
   C. IN MEMORY CACHING je implementovany pomocou INTERFACE [IMemoryCache].
   D. IN MEMORY CACHING umoznuje ukladat KEY VALUE PAIRS, kde kazday KEY VALUE ma definovanu EXPIRATION POLICY.
   E. IN MEMORY CACHING umoznuje definovat nasledujuce typy EXPIRATION POLICY.
      A. EXPIRATION POLICY [ABSOLUTE EXPIRATION]. Pri tejto EXPIRATION POLICY je RECORD v CACHE drzany definovany cas a po jeho uplynuti sa z CACHE odstrani.
      B. EXPIRATION POLICY [SLIDING EXPIRATION]. Pri tejto EXPIRATION POLICY je EXPIRATION TIME daneho CACHE RECORD automaticky predlzovany o stanoveny cas pri kazdej dalsej poziadavke na ziskanie CACHE RECORD z CACHE. No je mozne definovat maximalny cas po ktorom bude CACHE RECORD z CACHE odstraneny.
   F. IN MEMORY CACHING vyzaduje vlozenie SERVICES pomocou METHOD [IServiceCollection AddMemoryCache(this IServiceCollection Services)].
15. INTERFACE [IMemoryCache] reprezentuje IN MEMORY CACHE. Pre CLASS platia nasledujuce fakty.
   A. INTERFACE implementuje INTERFACE [IDisposable], ktory umoznuje uvolnenie RESOURCES.
   B. METHOD [void Dispose()] uvolnuje RESOURCES pouzivane IN MEMORY CACHE.
   C. METHOD [bool TryGetValue(object Key, out object Value)] sa pokusa pre dany KEY ziskat VALUE z CACHE.
   D. METHOD [ICacheEntry CreateEntry(object Key)] vytvara alebo prepisuje existujuci KEY VALUE PAIR v CACHE.
   E. METHOD [void Remove(object Key)] odstranuje existujuci KEY VALUE PAIR z CACHE.
   F. METHOD [MemoryCacheStatistics GetCurrentStatistics()] vracia CACHE STATISTICS.
   G. EXTENSION METHOD [object Get(this IMemoryCache Cache, object Key)] vracia VALUE pre dany KEY.
   H. EXTENSION METHOD [TItem Get<TItem>(this IMemoryCache Cache, object Key)] vracia TYPED VALUE pre dany KEY.
   I. EXTENSION METHOD [bool TryGetValue<TItem>(this IMemoryCache Cache, object Key, out TItem Value)] sa pokusa pre dany KEY ziskat TYPED VALUE z CACHE.
   J. EXTENSION METHOD [TItem Set<TItem>(this IMemoryCache Cache, object Key, TItem Value)] nastavuje TYPED VALUE pre dany KEY.
   K. EXTENSION METHOD [TItem Set<TItem>(this IMemoryCache Cache, object Key, TItem Value, DateTimeOffset AbsoluteExpiration)] nastavuje TYPED VALUE pre dany KEY. Pre KEY VALUE PAIR sa nastavi ABSOLUTE EXPIRATION TIME.
   L. EXTENSION METHOD [TItem Set<TItem>(this IMemoryCache Cache, object Key, TItem Value, TimeSpan AbsoluteExpirationRelativeToNow)] nastavuje TYPED VALUE pre dany KEY. Pre KEY VALUE PAIR sa nastavi RELATIVE EXPIRATION TIME od NOW.
   M. EXTENSION METHOD [TItem Set<TItem>(this IMemoryCache Cache, object Key, TItem Value, IChangeToken ExpirationToken)] nastavuje TYPED VALUE pre dany KEY. Pre KEY VALUE PAIR sa nastavi EXPIRATION TOKEN.
   N. EXTENSION METHOD [TItem Set<TItem>(this IMemoryCache Cache, object Key, TItem Value, MemoryCacheEntryOptions Options)] nastavuje TYPED VALUE pre dany KEY. Pre KEY VALUE PAIR sa nastavi EXPIRATION TIME na podla instancie CLASS [MemoryCacheEntryOptions].
   O. EXTENSION METHOD [TItem GetOrCreate<TItem>(this IMemoryCache Cache, object Key, Func<ICacheEntry,TItem> Factory)] sa pokusi ziskat TYPED VALUE pre dany KEY, a ak neexistuje vola DELEGATE na jeho vytvorenie.
   P. EXTENSION METHOD [Task<TItem> GetOrCreateAsync<TItem>(this IMemoryCache Cache, object Key, Func<ICacheEntry,Task<TItem>> Factory)] sa pokusi ziskat TYPED VALUE pre dany KEY, a ak neexistuje ASYNCHRONNE vola DELEGATE na jeho vytvorenie.
16. INTERFACE [ICacheEntry] reprezentuje IN MEMORY CACHE ENTRY. Pre CLASS platia nasledujuce fakty.
   A. INTERFACE implementuje INTERFACE [IDisposable], ktory umoznuje uvolnenie RESOURCES.
   B. PROPERTY [object Key] obsahuje KEY danej CACHE ENTRY.
   C. PROPERTY [object Value] obsahuje VALUE danej CACHE ENTRY.
   D. PROPERTY [DateTimeOffset? AbsoluteExpiration] obsahuje ABSOLUTE EXPIRATION DATE danej CACHE ENTRY.
   E. PROPERTY [TimeSpan? AbsoluteExpirationRelativeToNow] obsahuje ABSOLUTE EXPIRATION DATE danej CACHE ENTRY, ktory je relativny k NOW.
   F. PROPERTY [TimeSpan? SlidingExpiration] obsahuje SLIDING EXPIRATION DATE danej CACHE ENTRY.
   G. PROPERTY [IList<IChangeToken> ExpirationTokens] obsahuje CHANGE TOKENS danej CACHE ENTRY.
   H. PROPERTY [IList<PostEvictionCallbackRegistration> PostEvictionCallbacks] obsahuje CALLBACKS, ktore budu spustene ak CACHE ENTRY je EXPIRED.
   I. PROPERTY [CacheItemPriority Priority] obsahuje PRIORITY danej CACHE ENTRY. PRIORITY sa pouziva pri CLEANUP danej MEMORY CACHE, ktora sa spusta pri nedostatku MEMORY.
   J. PROPERTY [long? Size] obsahuje velkost danej CACHE ENTRY. SIZE sa pouziva pri CACHE CLEANUP, ak je nedostatok MEMORY.
   K. METHOD [void Dispose()] uvolnuje RESOURCES pouzivane IN MEMORY CACHE ENTRY.
17. CLASS [MemoryCacheEntryOptions] reprezentuje IN MEMORY CACHE ENTRY OPTIONS. Pre CLASS platia nasledujuce fakty.
   A. PROPERTY [DateTimeOffset? AbsoluteExpiration] obsahuje ABSOLUTE EXPIRATION DATE danej CACHE ENTRY.
   B. PROPERTY [TimeSpan? AbsoluteExpirationRelativeToNow] obsahuje ABSOLUTE EXPIRATION DATE danej CACHE ENTRY, ktory je relativny k NOW.
   C. PROPERTY [TimeSpan? SlidingExpiration] obsahuje SLIDING EXPIRATION DATE danej CACHE ENTRY.
   D. PROPERTY [IList<IChangeToken> ExpirationTokens] obsahuje CHANGE TOKENS danej CACHE ENTRY.
   E. PROPERTY [IList<PostEvictionCallbackRegistration> PostEvictionCallbacks] obsahuje CALLBACKS, ktore budu spustene ak CACHE ENTRY je EXPIRED.
   F. PROPERTY [CacheItemPriority Priority] obsahuje PRIORITY danej CACHE ENTRY. PRIORITY sa pouziva pri CLEANUP danej MEMORY CACHE, ktora sa spusta pri nedostatku MEMORY.
   G. PROPERTY [long? Size] obsahuje velkost danej CACHE ENTRY. SIZE sa pouziva pri CACHE CLEANUP, ak je nedostatok MEMORY.
18. Pre DISTRIBUTED CACHING platia nasledujuce fakty.
   A. DISTRIBUTED CACHING umoznuje uklada CACHE RECORDS do REMOTE PERSISTENT STORAGE.
   B. DISTRIBUTED CACHING je implementovana pre viacere REMOTE PERSISTENT STORAGES.
      A. REDIS CACHE je implementovana v LIBRARY [Microsoft.Extensions.Caching.StackExchangeRedis].
      B. SQL SERVER CACHE je implementovana v LIBRARY [package Microsoft.Extensions.Caching.SqlServer].
      C. REDIS CACHE je implementovana v LIBRARY [NCache.Microsoft.Extensions.Caching.OpenSource].
   C. DISTRIBUTED CACHING je v .NET implementovana pomocou INTERFACE [IDistributedCache].
   D. IN MEMORY CACHING umoznuje ukladat KEY VALUE PAIRS, kde kazday KEY VALUE ma definovanu EXPIRATION POLICY. KEY ma TYPE [string] a VALUE ma TYPE [byte[]].
   E. IN MEMORY CACHING umoznuje definovat nasledujuce typy EXPIRATION POLICY.
      A. EXPIRATION POLICY [ABSOLUTE EXPIRATION]. Pri tejto EXPIRATION POLICY je RECORD v CACHE drzany definovany cas a po jeho uplynuti sa z CACHE odstrani.
      B. EXPIRATION POLICY [SLIDING EXPIRATION]. Pri tejto EXPIRATION POLICY je EXPIRATION TIME daneho CACHE RECORD automaticky predlzovany o stanoveny cas pri kazdej dalsej poziadavke na ziskanie CACHE RECORD z CACHE. No je mozne definovat maximalny cas po ktorom bude CACHE RECORD z CACHE odstraneny.
19. Pre REDIS DISTRIBUTED CACHING platia nasledujuce fakty.
   A. REDIS DISTRIBUTED CACHING je implementovana v LIBRARY [Microsoft.Extensions.Caching.StackExchangeRedis].
   B. REDIS DISTRIBUTED CACHING SERVER je distribuovany ako DOCKER CONTAINER. REDIS DOCKER CONTAINER sa stahuje pomocou COMMAND [docker pull redis].
   C. REDIS DISTRIBUTED CACHING SERVER sa spusta pomocou COMMAND [docker run --name redis -p 6379:6379 -d redis].
   D. REDIS DISTRIBUTED CACHING SERVER CLI sa spusta pomocou COMMAND [docker exec -it redis redis-cli].
   E. Do REDIS DISTRIBUTED CACHING SERVER sa novy CACHE RECORD zapisuje pomocou COMMAND [set KEY_NAME RECORD_VALUE], kde VALUE [KEY_NAME] je nazov KEY CACHE RECORD a VALUE [RECORD_VALUE] je VALUE CACHE RECORD.
   F. Z REDIS DISTRIBUTED CACHING SERVER sa VALUE existujuceho CACHE RECORD cita pomocou COMMAND [get KEY_NAME], kde VALUE [KEY_NAME] je nazov KEY.
   G. Z REDIS DISTRIBUTED CACHING SERVER sa existujucehu CACHE RECORD (obsahuje VALUE i EXPIRATION TIME) cita pomocou COMMAND [hgetall KEY_NAME], kde VALUE [KEY_NAME] je nazov KEY.
   H. REDIS DISTRIBUTED CACHING SERVER vracia zoznam KEY pomocou COMMAND [keys *].
   !!! I. V ASP.NET CORE REDIS DISTRIBUTED CACHING vyzaduje vlozenie SERVICES pomocou METHOD [IServiceCollection AddStackExchangeRedisCache(this IServiceCollection Services, Action<RedisCacheOptions> SetupAction)].
20. INTERFACE [IDistributedCache] reprezentuje DISTRIBUTED CACHE. Pre CLASS platia nasledujuce fakty.
   A. METHOD [byte[] Get(string Key)] pre dany KEY SYNCHRONNE vracia VALUE z CACHE.
   B. METHOD [Task<byte[]> GetAsync(string Key, CancellationToken Token)] pre dany KEY ASYNCHRONNE vracia VALUE z CACHE.
   C. METHOD [void Set(string Key, byte[] Value, DistributedCacheEntryOptions Options)] SYNCHRONNE nastavuje KEY VALUE PAIR v CACHE.
   D. METHOD [Task SetAsync(string Key, byte[] Value, DistributedCacheEntryOptions Options, CancellationToken Token)] ASYNCHRONNE nastavuje KEY VALUE PAIR v CACHE.
   E. METHOD [void Refresh(string Key)] SYNCHRONNE vykona REFRESH KEY VALUE PAIRS v CACHE. REFRESH znamena, ze sa vykona REFRESH SLIDING EXPIRATION, ak existuju CACHE RECORDS, ktore SLIDING EXPIRATION pouzivaju.
   F. METHOD [Task RefreshAsync(string Key, CancellationToken Token)] ASYNCHRONNE vykona REFRESH KEY VALUE PAIRS v CACHE. REFRESH znamena, ze sa vykona REFRESH SLIDING EXPIRATION, ak existuju CACHE RECORDS, ktore SLIDING EXPIRATION pouzivaju.
   G. METHOD [void Remove(string Key)] SYNCRHONNE odstranuje existujuci KEY VALUE PAIR z CACHE.
   H. METHOD [Task RemoveAsync(string Key, CancellationToken Token)] ASYNCRHONNE odstranuje existujuci KEY VALUE PAIR z CACHE.
   I. EXTENSION METHOD [void Set(this IDistributedCache Cache, string Key, byte[] Value)] SYNCHRONNE nastavuje KEY VALUE PAIR do CACHE.
   J. EXTENSION METHOD [Task SetAsync(this IDistributedCache Cache, string Key, byte[] Value, CancellationToken Token)] ASYNCHRONNE nastavuje KEY VALUE PAIR do CACHE.
   K. EXTENSION METHOD [void SetString(this IDistributedCache Cache, string Key, string Value)] SYNCHRONNE nastavuje KEY VALUE PAIR, kde VALUE je TYPE [string] do CACHE.
   M. EXTENSION METHOD [void SetString(this IDistributedCache Cache, string Key, string Value, DistributedCacheEntryOptions Options)] SYNCHRONNE nastavuje KEY VALUE PAIR, kde VALUE je TYPE [string] do CACHE.
   N. EXTENSION METHOD [Task SetStringAsync(this IDistributedCache Cache, string Key, string Value, CancellationToken Token)] ASYNCHRONNE nastavuje KEY VALUE PAIR, kde VALUE je TYPE [string] do CACHE.
   O. EXTENSION METHOD [Task SetStringAsync(this IDistributedCache Cache, string Key, string Value, DistributedCacheEntryOptions Options, CancellationToken Token)] ASYNCHRONNE nastavuje KEY VALUE PAIR, kde VALUE je TYPE [string] do CACHE.
   P. EXTENSION METHOD [string GetString(this IDistributedCache Cache, string Key)] SYNCHRONNE vracia VALUE TYPE [string] pre dany KEY z CACHE.
   Q. EXTENSION METHOD [Task<string> GetStringAsync(this IDistributedCache Cache, string Key, CancellationToken Token)] ASYNCHRONNE vracia VALUE TYPE [string] pre dany KEY z CACHE.
21. CLASS [DistributedCacheEntryOptions] reprezentuje DISTRIBUTED CACHE ENTRY OPTIONS. Pre CLASS platia nasledujuce fakty.
   A. PROPERTY [DateTimeOffset? AbsoluteExpiration] obsahuje ABSOLUTE EXPIRATION DATE danej CACHE ENTRY.
   B. PROPERTY [TimeSpan? AbsoluteExpirationRelativeToNow] obsahuje ABSOLUTE EXPIRATION DATE danej CACHE ENTRY, ktory je relativny k NOW.
   C. PROPERTY [TimeSpan? SlidingExpiration] obsahuje SLIDING EXPIRATION DATE danej CACHE ENTRY.
22. Pre RESPONSE CACHING platia nasledujuce fakty.
   A. RESPONSE CACHING je vlastnost HTTP PROTOCOL a umoznuje HTTP CLIENTS ukladat CACHED RESPONSES v svojej internej CACHE.
   B. RESPONSE CACHING je implementovany pomocou HTTP HEADER [cache-control], ktory ma nasledujuce DIRECTIVES.
      A. DIRECTIVE [public]. DIRECTIVE znamena, ze RESPONSE moze byt CACHED na CLIENTS aj INTERMEDIATE PROXIES.
      B. DIRECTIVE [private]. DIRECTIVE znamena, ze RESPONSE moze byt CACHED iba na CLIENTS.
      C. DIRECTIVE [no-cache]. DIRECTIVE znamena, ze pre REQUESTS musi CLIENT poslat na SERVER VALIDATION REQUEST a iba ak ten uspeje, moze pouzit CACHED RESPONSE. Pre RESPONSES CLIENTS nesmu pouzit CACHED RESPONSES predtym ako vykonaju VALIDATION na SERVERI.
      D. DIRECTIVE [no-store]. DIRECTIVE znamena, ze ziadna cast REQUESTS, ani RESPONSES nesmie byt ulozena do CACHE.
      E. DIRECTIVE [max-age]. DIRECTIVE definuje pocet sekund pocas ktorych je CACHED RESPONSE validna.
   C. RESPONSE CACHING je zalezitost CLIENT SIDE a teda kazdy CLIENT ma vlastnu verziu CACHE.
   D. RESPONSE CACHING sa definuje aplikovanim ATTRIBUTE [ResponseCache] na ACTION METHOD.
   !!! E. Vacsina BROWSERS posiela v REQUEST HTTP HEADER [cache-control] s DIRECTIVE [max-age=0] ci sa vypina RESPONSE CACHING.
23. Pre OUTPUT CACHING platia nasledujuce fakty.
   A. OUTPUT CACHING je implementovany ako MIDDLEWARE COMPONENT, ktory sa vklada do ASP.NET PIPELINE a uklada vysledky do internej CACHE.
   B. OUTPUT CACHING moze na ukladanie CACHE RECORDS pouzivat aj DISTRIBUTED SYSTEMS, ako REDIS.
   C. OUTPUT CACHING umoznuje vykona CACHE INVALIDATION, ak CACHE RECORDS uz nie su aktualne.
   !!! D. OUTPUT CACHING uklada do CACHE CACHE RECORDS pre rozlicne REQUESTS. Ak sa REQUESTS lisia ta pre kazdy REQUEST je do CACHE ulozeny osobitny CACHE RECORD.
   !!! E. OUTPUT CACHING funguje iba pre HTTP GET a STATUS CODE 200. OUTPUT CACHING NEFUNGUJE pre HEADER [Authorization] a HEADER [Set-Cookie].
   F. OUTPUT CACHING sa aplikuje aplikovanim ATTRIBUTE [OutputCache] na ACTION METHOD.
   G. OUTPUT CACHING umoznuje definovat POLICIES, ktore nastavuju EXPIRATION TIMES. POLICIES je mozne aplikovat na ACTION METHODS.
   H. OUTPUT CACHING vyzaduje vlozenie SERVICES do DEPENDENCY INJECTION CONTAINER volanim METHOD [IServiceCollection AddOutputCache(this IServiceCollection Services, Action<OutputCacheOptions> ConfigureOptions)].
   I. OUTPUT CACHING vyzaduje vlozenie MIDDLEWARE COMPONENT do ASP.NET PIPELINE volanim METHOD [IApplicationBuilder UseOutputCache(this IApplicationBuilder App)].
24. CLASS [HttpClient] reprezentuje HTTP CLIENT. Pre CLASS platia nasledujuce fakty.
   A. CLASS je DERIVED z CLASS [HttpMessageInvoker], ktora implementuje INTERFACE [IDisposable].
   B. CONSTRUCTOR vytvara instanciu CLASS.
   C. STATIC PROPERTY [IWebProxy DefaultProxy] DEFAULT PROXY OBJECT.
   D. PROPERTY [HttpRequestHeaders DefaultRequestHeaders] obahuje DEFAULT HEADERS.
   E. PROPERTY [Version DefaultRequestVersion] obahuje DEFAULT REQUEST VERSION.
   F. PROPERTY [HttpVersionPolicy DefaultVersionPolicy] obahuje DEFAULT REQUEST VERSION POLICY.
   G. PROPERTY [Uri BaseAddress] obahuje BASE ADDRESS.
   H. PROPERTY [TimeSpan Timeout] obahuje OPERATION TIMEOUT.
   I. PROPERTY [long MaxResponseContentBufferSize] obahuje maximalnu dlzu RESPONSE CONTENT BUFFER.
   J. METHOD [HttpResponseMessage Send(HttpRequestMessage Request, HttpCompletionOption CompletionOption, CancellationToken CancellationToken)] SYNCHRONNE odosiela HTTP REQUEST MESSAGE a vracia HTTP RESPONSE MESSAGE.
   K. METHOD [Task<HttpResponseMessage> SendAsync(HttpRequestMessage Request, HttpCompletionOption CompletionOption, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE a vracia HTTP RESPONSE MESSAGE.
   L. METHOD [void CancelPendingRequests()] vykona CANCELLATION PENDING REQUESTS.
   M. METHOD [Task<string> GetStringAsync(string RequestUri, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE s VERB GET a vracia HTTP RESPONSE MESSAGE v ako TYPE [string].
   N. METHOD [Task<byte[]> GetByteArrayAsync(Uri RequestUri, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE s VERB GET a vracia HTTP RESPONSE MESSAGE v ako TYPE [byte[]].
   O. METHOD [Task<Stream> GetStreamAsync(Uri RequestUri, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE s VERB GET a vracia HTTP RESPONSE MESSAGE v ako TYPE [Stream].
   P. METHOD [Task<HttpResponseMessage> GetAsync(Uri RequestUri, HttpCompletionOption CompletionOption, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE s VERB GET a vracia HTTP RESPONSE MESSAGE.
   Q. METHOD [Task<HttpResponseMessage> PostAsync(Uri RequestUri, HttpContent Content, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE s VERB POST a vracia HTTP RESPONSE MESSAGE.
   R. METHOD [Task<HttpResponseMessage> PutAsync(Uri RequestUri, HttpContent Content, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE s VERB PUT a vracia HTTP RESPONSE MESSAGE.
   S. METHOD [Task<HttpResponseMessage> PatchAsync(Uri RequestUri, HttpContent Content, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE s VERB PATCH a vracia HTTP RESPONSE MESSAGE.
   T. METHOD [Task<HttpResponseMessage> DeleteAsync(Uri RequestUri, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE s VERB DELETE a vracia HTTP RESPONSE MESSAGE.
25. CLASS [HttpMessageInvoker] reprezentuje HTTP CLIENT INVOKER. Pre CLASS platia nasledujuce fakty.
   A. CLASS implementuje INTERFACE [IDisposable].
   B. CONSTRUCTOR vytvara instanciu CLASS. Ako PARAMETER ma TYPE [HttpMessageHandler].
   C. METHOD [void Dispose()] uvolnuje RESOURCES pouzivane danou CLASS.
   D. METHOD [HttpResponseMessage Send(HttpRequestMessage Request, CancellationToken CancellationToken)] SYNCHRONNE odosiela HTTP REQUEST MESSAGE a vracia HTTP RESPONSE MESSAGE.
   E. METHOD [Task<HttpResponseMessage> SendAsync(HttpRequestMessage Request, CancellationToken CancellationToken)] ASYNCHRONNE odosiela HTTP REQUEST MESSAGE a vracia HTTP RESPONSE MESSAGE.
26. ABSTRACT CLASS [HttpContent] reprezentuje BASE CLASS pre HTTP CONTENT. Pre CLASS platia nasledujuce fakty.
   A. CLASS implementuje INTERFACE [IDisposable].
   B. PROPERTY [HttpContentHeaders Headers] obsahuje CONTENT HEADERS.
   C. METHOD [void Dispose()] uvolnuje RESOURCES pouzivane danou CLASS.
   D. PROTECTED METHOD [Stream CreateContentReadStream(CancellationToken CancellationToken)] SYNCHRONNE serializuje HTTP CONTENT do MEMORY STREAM.
   E. PROTECTED METHOD [Task<Stream> CreateContentReadStreamAsync(CancellationToken CancellationToken)] ASYNCHRONNE serializuje HTTP CONTENT do MEMORY STREAM.
   F. PROTECTED METHOD [void SerializeToStream(Stream Stream, TransportContext Context, CancellationToken CancellationToken)] SYNCHRONNE serializuje HTTP CONTENT do definovaneho STREAM.
   G. PROTECTED METHOD [Task SerializeToStreamAsync(Stream Stream, TransportContext Context, CancellationToken CancellationToken)] ASYNCHRONNE serializuje HTTP CONTENT do definovaneho STREAM.
   H. PROTECTED METHOD [bool TryComputeLength(out long Length)] vracia informaciu ci je mozne vypocitat dlzku HTTP CONTENT, ak ano, tak ju vypocita a vrati v OUTPUT PARAMETER.
   I. METHOD [void CopyTo(Stream Stream, TransportContext Context, CancellationToken CancellationToken)] SYNCHRONNE vykona kopiu HTTP CONTENT do STREAM.
   J. METHOD [Task CopyToAsync(Stream Stream, TransportContext Context, CancellationToken CancellationToken)] ASYNCHRONNE vykona kopiu HTTP CONTENT do STREAM.
   K. METHOD [Task LoadIntoBufferAsync(long MaxBufferSize)] ASYNCHRONNE nacita HTTP CONTENT do BUFFER.
   M. METHOD [Stream ReadAsStream(CancellationToken CancellationToken)] SYNCHRONNE nacita HTTP CONTENT a vrati ho ako STREAM.
   N. METHOD [Task<Stream> ReadAsStreamAsync(CancellationToken CancellationToken)] ASYNCHRONNE nacita HTTP CONTENT a vrati ho ako STREAM.
   O. METHOD [Task<byte[]> ReadAsByteArrayAsync(CancellationToken CancellationToken)] ASYNCHRONNE nacita HTTP CONTENT a vrati ho ako TYPE [byte[]].
   P. METHOD [Task<string> ReadAsStringAsync(CancellationToken CancellationToken)] ASYNCHRONNE nacita HTTP CONTENT a vrati ho ako TYPE [string].
29. Pre ABSTRACT CLASS [HttpContent] su definovane nasledujuce DERIVED CLASSES.
   A. CLASS [ByteArrayContent] reprezentuje BYTE ARRAY HTTP CONTENT.
   B. CLASS [FormUrlEncodedContent] reprezentuje FORM URL ENCODED HTTP CONTENT.
   C. CLASS [MultipartContent] reprezentuje MULTIPART HTTP CONTENT.
   D. CLASS [StreamContent] reprezentuje STREAM HTTP CONTENT.
   E. CLASS [StringContent] reprezentuje STRING HTTP CONTENT.
30. INTERFACE [IHttpClientFactory] reprezentuje HTTP CLIENT FACTORY, ktora umoznuje efektivne vytvaranie instancie CLASS [HttpClient] bez toho, aby bolo nutne neustale vytvarat a uvolnovat instancie CLASS [HttpClient]. Pre CLASS platia nasledujuce fakty.
   A. METHOD [HttpClient CreateClient(string Name)] vracia instanciu CLASS [HttpClient] pre definovany NAME.
   B. EXTENSION METHOD [HttpClient CreateClient(this IHttpClientFactory Factory)] vracia instanciu CLASS [HttpClient] bez definovaneho NAME.
31. HTTP CLIENT FACTORY vyzaduju pridat do DEPENDENCY INJECTION CONTAINER SERVICES pomocou METHOD [IServiceCollection AddHttpClient(this IServiceCollection Services)].
32. HTTP CLIENT FACTORY moze pouzivat aj HTTP CLIENT FACTORY NAMED INSTANCES. Pre HTTP CLIENT FACTORY NAMED INSTANCES platia nasledujuce fakty.
   A. HTTP CLIENT FACTORY NAMED INSTANCES maju kazda vlastnu specificku SETTINGS, ktora napriklad moze obsahovat BASE ADDRESS.
   B. HTTP CLIENT FACTORY NAMED INSTANCES maju kazda vlastny NAME.
   C. HTTP CLIENT FACTORY NAMED INSTANCES vyzaduju registraciu SERVICES v DEPENDENCY INJECTION CONTAINER co sa robi volanim METHOD [IHttpClientBuilder AddHttpClient(this IServiceCollection Services, string Name, Action<HttpClient> ConfigureClient)].
   D. HTTP CLIENT FACTORY NAMED INSTANCES sa ziskavaju volanim METHOD [HttpClient IHttpClientFactory.CreateClient(string Name)].
33. HTTP CLIENT FACTORY podporuje TYPED HTTP CLIENTS. Pre TYPED HTTP CLIENTS platia nasledujuce fakty.
   A. TYPED HTTP CLIENTS su CUSTOM CLASSES, ktore maju ako CONSTRUCTOR PARAMETER instanciu CLASS [HttpClient], ktory naplna HTTP CLIENT FACTORY.
   B. TYPED HTTP CLIENTS mozu obsahovat lubovolne operacie nad instanciou CLASS [HttpClient].
   C. TYPED HTTP CLIENTS sa pre HTTP CLIENT FACTORY registruju volanim METHOD [IHttpClientBuilder AddHttpClient<TClient>(this IServiceCollection Services)].
//----------------------------------------------------------------------------------------------------------------------