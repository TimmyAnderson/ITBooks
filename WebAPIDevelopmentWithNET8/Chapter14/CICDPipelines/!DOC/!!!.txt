//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie CI/CD PIPELINES a pouzitie DOCKER.
2. CONTINOUS INTEGRATION AND CONTINOUS DEPLOYMENT (CI/CD) je proces, ktory umoznuje integrovat zmeny v CODE, ktory je vyvijany viacerymi DEVELOPERS a ich nasadenie do roznych ENVIRONMENTS.
   A. CONTINOUS INTEGRATION (CI) je integracia CODE CHANGES do spolocneho REPOSITORY, spustenie TESTS nad zmenenym CODE a BUILD CODE, ktoreho vysledkom su ARTIFACTS (BINARY CODES, CONFIGURATION FILES, DOCKER FILES).
   B. CONTINOUS DEPLOYMENT (CD) je nasadenie ARTIFACTS, ktore vytvoril CONTINOUS INTEGRATION do ENVIRONMENTS.
3. CI/CD PIPELINE je proces, ktory vykona CONTINOUS INTEGRATION a CONTINOUS DEPLOYMENT.
4. CI/CD PIPELINES su klucovym komponentom procesu DEVELOPMENT AND OPERATIONS (DEVOPS), ktory casto realizuje specializovany tim ludi.
5. CI/CD PIPELINE pozostava z nasledujucich krokov.
   A. DEVELOPER vykona CODE CHANGES. Tieto CHANGES su COMMITED do SHARED DEVELOPMENT BRANCH.
   B. COMMIT do SHARED DEVELOPMENT BRANCH spusti CONTINOUS INTEGRATION PIPELINE nad DEVELOPMENT BRANCH.
   C. CONTINOUS INTEGRATION PIPELINE vykona CODE BUILD a nasledne spusti TESTS. Ak niektore TESTS zlyhaju, DEVELOPER ich opravit ERRORS.
   D. Po uspesnom vykonani TESTS v DEVELOPMENT BRANCH, DEVELOPER vytvori PULL REQUEST, ktory poziada o MERGE CODE CHANGES do MAIN BRANCH.
   E. Po schvaleni PULL REQUEST spravidla inym DEVELOPER su CODE CHANGES MERGED do MAIN BRANCH.
   F. MERGE do MAIN BRANCH sousti CONTINOUS INTEGRATION PIPELINE nad MAIN BRANCH.
   G. CONTINOUS INTEGRATION PIPELINE vykona nad MAIN BRANCH BUILD, spusti TESTS a vytvori ARTIFACTS (BINARY FILES, CONFIGURATIONS, DOCKER FILES), ktory publikuje do ARTIFACT REPOSITORY.
   H. Po publikovani ARTIFACTS do ARTIFACT REPOSITORY je mozne (manualne, alebo automaticky) spustit CONTINOUS DEPLOYMENT PIPELINE.
   I. CONTINOUS DEPLOYMENT PIPELINE vykona nasadenie PROGRAMU do prislusneho TARGET ENVIRONMENT.
6. CI/CD definuje nasledujuce pojmy.
   A. PIPELINE.
      A. PIPELINE je automatizovany proces, ktory umoznuje BUILD, TEST a DEPLOY PROGRAMS.
	  B. PIPELINES mozu byt spustene automaticky, alebo manualne.
	  C. PIPELINES mozu byt spustene ako reakcia na ukoncenie inej PIPELINE.
   B. BUILD.
      A. BUILD je proces kompilacie SOURCE CODES.
	  B. Vysledkom BUILD su BINARY FILES, CONFIGURATIONS, DOCKER FILES a ine FILES potrebne pre beh PROGRAMU.
   C. TEST.
      A. PIPELNE moze obsahovat spustenie TEST, ktore otestuju CODE.
	  B. TESTS mozu pozostavat z UNIT TESTS, INTEGRATION TESTS, PERFORMANCE TESTS, alebo END TO END TESTS.
   D. ARTIFACT.
      A. ARTIFACT je FILE, alebo kolekcia FILES, ktore su vystupom BUILD PROCESS.
	  B. ARTIFACTS su vstupom do DEPOLYMENT PROCESS.
   E. CONTAINERIZATION.
      A. CONTAINERIZATION je sposob ulozenia PROGRAMS a vsetkych ich DEPEDENCIES do CONTAINER IMAGE, ktory moze byt DEPLOYED bez ohladu na HOST OPERATION SYSTEM.
	  B. CONTAINERIZATION umoznuje DEPOLYMENT na lubovolny pocet MACHINES.
	  C. CONTAINERIZATION je spravidla realizovany pomocou DOCKER TOOL.
   F. VERSION CONTROL SYSTEM.
      A. VERSION CONTROL SYSTEM umoznuje ukladat CODE a CODE CHANGES a monitorovat zmeny v CODE.
	  B. Najpouzivanejsim VERSION CONTROL SYSTEM je GIT.
   G. DEPLOYMENT.
      A. DEPLOYMENT je proces nasadenia PROGRAMU do TARGET ENVIRONMENT.
	  B. DEPLOYMENT zahrna konfigurovanie PROGRAMU, aby mohol byt DEPLOYED do TARGET ENVIRONMENT.
   H. TRIGGER.
      A. TRIGGER je EVENT, ktoru spusti vykonanie PIPELINE.
	  B. TRIGGER moze byt automaticky, alebo manualny.
	  C. Typickymi prikladmi TRIGGERS su MERGE do BRANCH, vykonanie PULL REQUEST, alebo dokoncenie inej PIPELINE.
7. CONTAINER je ISOLATED, LIGHWEIGHTED a PORTABLE ENVIRONMENT, ktory obsahuje vsetky potrebne DEPENDENCY na bez PROGRAMU.
8. Medzi CONTAINERS a VIRTUAL MACHINES existuju nasledujuce rozdiely.
   A. Pre VIRTUAL MACHINES platia nasledujuce fakty.
      A. VIRTUAL MACHINE je plnohodnoty GUEST OPERATING SYSTEM, ktory bezi v HOST OPERATING SYSTEM.
	  B. Kedze VIRTUAL MACHINE je nezavisla na GUEST OPERATION SYSTEM, musi obsahovat plny OPERATING SYSTEM.
	  C. Beh VIRTUAL MACHINES je narocny na RESOURCES.
   B. Pre CONTAINERS platia nasledujuce fakty.
      A. CONTAINERS zdielaju KERNEL HOST OPERATING SYSTEM s GUEST OPERATING SYSTEM.
	  B. CONTAINERS su daleko menej narocne na RESOURCES ako VIRTUAL MACHINES.
9. DOCKER je najpouzivanejsi TOOL realizujuci CONTAINERIZATION. Pre DOCKER platia nasledujuce fakty.
   A. DOCKER podporuje WINDOWS, LINUX a MAC OS.
   B. DOCKER je kompatibilny s COULD PLATFORMS vratane AZURE, AMAZON WEB SERVICE a GOOGLE CLOUD PLATFORM.
10. DOCKER rozlisuje nasledujuce pojmy.
   A. DOCKER FILE. DOCKER FILE je TEXT FILE, ktory obsahuje instrukcie potrebne pre vytvorenie DOCKER IMAGE.
   B. DOCKER IMAGE. DOCKER IMAGE je FILE vytvoreny v BUILD PROCESS z DOCKER FILE. DOCKER IMAGE obsahuje vsetky potrebne FILES pre spustenie DOCKER CONTAINER.
   C. DOCKER CONTAINER. DOCKER CONTAINER vytvoreny z DOCKER FILE je beziaca instancia GUEST OPERATING SYSTEMU v ktorej bezi dany PROGRAM.
11. Pre DOCKER FILES platia nasledujuce fakty.
   A. DOCKER FILE je TEXT FILE, ktory obsahuje instrukcie potrebne pre vytvorenie DOCKER IMAGE.
   B. DOCKER FILE sa pouziva na vytvorenie DOCKER IMAGES.
   C. DOCKER FILE ma DEFAULT NAME [Dockerfile].
   !!!!! D. DOCKER FILES obsahuju <1,N> BUILD STAGES, kde kazdy BUILD STAGE zacina COMMAND [FROM]. COMMAND [FROM] urcuje IMAGE, ktory sa pouzije. Vsetky nasledujuce COMMANDS su vykonane nad danym IMAGE.
   E. DOCKER FILES su spracovavane sekvencne od prveho riadku po posledny.
12. Pre DOCKER IMAGES platia nasledujuce fakty.
   A. DOCKER IMAGES je FILE, ktory obsahuje vsetky potrebne FILES pre spustenie DOCKER CONTAINER.
   B. DOCKER IMAGE moze obsahovat casti OPERATING SYSTEMU, FRAMEWORKS a LIBRARIES potrebnych pre beh PROGRAMU a samotny PROGRAM aj s prislusnymi CONFIGURATION FILES.
   C. DOCKER IMAGES su IMMUTABLE. Po ich vytvoreni ich nie je mozne zmenit.
   D. DOCKER IMAGES su spravidla ukladane do REGISTRIES. Medzi najpouzivanie REGISTRIES patria DOCKER HUB, AZURE CONTAINER REGISTRY a AWS ELASTIC CONTAINER REGISTRY. DOCKER IMAGES je mozne ulozit aj do PRIVAT REGISTRIES.
   !!! E. FILES v DOCKER IMAGES su STACKABLE. To znamena, ze jednotlive DOCKER IMAGES mozu byt ulozene do STACKS, kde sa pri vytvarani DOCKER CONTAINER postupne aplikuju jednotlive DOCKER IMAGES z daneho STACK.
13. Pre DOCKER CONTAINERS platia nasledujuce fakty.
   A. DOCKER CONTAINER je beziaca instancia GUEST OPERATING SYSTEMU v ktorej bezi dany PROGRAM.
   B. DOCKER CONTAINER je vytvoreny z jedneho ci viacerych DOCKER IMAGES.
   C. DOCKER CONTAINER je izolovany od HOST OPERATING SYSTEM, ako aj dalsich DOCKER CONTAINERS beziacich na tej iste MACHINE.
!!! 14. STACK DOCKER FILES pre .NET PROGRAM typicky obsahuje nasledujuce DOCKER FILES.
   A. KERNEL LAYER. Obsahuje COMPONENTS pre komunikaciu DOCKER CONTAINER s KERNEL HOST OPERATING SYSTEM.
   B. BASE IMAGE FILE. Obsahuje FILES potrebne pre beh GUEST OPERATING SYSTEM.
   C. .NET RUNTIME IMAGE FILE. Obsahuje FILES potrebne pre beh .NET RUNTIME.
   D. APPLICATION IMAGE FILE. Obsahuje FILES potrebne pre beh PROGRAMU v .NET RUNTIME.
   !!!!! E. CONTAINER FILE SYSTEM. Obsahuje CONTAINER FILE SYSTEM, ktory umoznuje zapisovat FILES do DOCKER CONTAINER. Tieto FILES su len docasne a su odstranene po ukonceni behu CONTAINER. Ak FILES maju pretrvat aj po ukonceni behu DOCKER CONTAINER, je nutne ich ukladat do VOLUME, ktory je mapovany na DIRECTORY v HOST OPERATING SYSTEM.
15. DOCKER sa na WINDOWS instaluje v nasledujucich krokoch.
   A. Pomocou COMMAND [wsl --install] sa nainstaluje WINDOWS SUBSYSTEM FOR LINUX 2, ktory umoznuje nativny beh LINUX BINARY EXECUTABLES nad WINDOWS.
   B. Nainstaluje sa DOCKER DESKTOP, kde sa zaskrtne pouzitie WINDOWS SUBSYSTEM FOR LINUX 2.
   C. Instalaciu DOCKER je mozne skontrolovat pomocou COMMAND [wsl -l -v].
   D. V DOCKER DESKTOP je potrebne skontrolovat ci je nastaveny SETTINGS [Settings->Resources->WSL Integration], kde sa zaskrtne CHECKBOX [Enable Intergation With My Default WSL Distro].
16. Pre ASP.NET CORE PROGRAM je mozne vytvorit DOCKER FILE nasledujucim sposobom.
   A. Do ASP.NET CORE PROGRAM ROOT DIRECTORY sa prida DOCKER FILE. Ten je mozne vygenerovat manualne, alebo pomocou VISUAL STUDIO pomocou COMMAD [Solution Explorer->PROJECT->CONTEXT MENU->Add->Docker Support...].
   B. Odporuca sa pouzit LINUX MACHINE, kedze ta je lepsie prisposobena pre DOCKER a generuje mensie IMAGES.
   !!! C. DOCKER FILE ma NAME [Dockerfile] a je pridany do ASP.NET CORE PROGRAM ROOT DIRECTORY. DEFAULT NAME [Dockerfile] ma vyhodu, ze COMMAND [docker build] ho berie ako DEFAULT FILE NAME a netreba jeho NAME specifikovat.
   D. DOCKER FILE sa upravi podla potrieb daneho ASP.NET CORE PROGRAM.
   !!!!! E. Po pridani DOCKER FILE do PROJECT VISUAL STUDIO automaticky upravi FILE [launchSettings.json] tak, ze don prida CONFIGURATION pre DOCKER. 
17. DOCKER IMAGE pre ASP.NET CORE PROGRAM vytvara v nasledujucich krokoch.
   A. Spusti sa DOCKER DESKTOP.
   B. SOLUTION DIRECTORY sa spusti sa DOCKER BUILD pomocou COMMAND [docker build -t TAG_NAME -f PROJECT_DIRECTORY/Dockerfile .]. PARAMETER [TAG_NAME] je nazov TAGU a PARAMETER [PROJECT_DIRECTORY] je PROJECT DIRECTORY v ktorom sa ASP.NET PROGRAM nachadza.
   C. Po skonceni BUILD PROCESS sa vytvoreny DOCKER IMAGE ulozi v DOCKER DESKTOP.
18. FILE [.dockerignore] obsahuje vsetky FILES, ktore maju byt vyradene z DOCKER IMAGE.
!!!!! 19. PROGRAMS beziace v DOCKER NESMU mat ZIADNU INTERAKCIU s USER, ani citat USER INPUT, kedze do DOCKER CONTAINER ziaden USER INPUT nie je mozne zadat. No pokus o citanie USER INPUT z CONSOLE vrati VALUE [null].
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
WSL COMMANDS.

1. COMMAND [wsl --install] instaluje WSL.
2. COMMAND [wsl --help] zobrazi HELP.
3. COMMAND [wsl --list --verbose] zobrazuje zoznam DISTRIBUTIONS s VERBOSE INFORMATION ako je STATE a VERSION kazdej DISTRIBUTION.
4. COMMAND [wsl --distribution DISTRIBUTION_NAME] spusti DISTRIBUTION [DISTRIBUTION_NAME].
5. COMMAND [wsl --shutdown] zastavi vsetky DISTRIBUTIONS.
6. COMMAND [wsl --terminate DISTRIBUTION_NAME] zastavi DISTRIBUTION [DISTRIBUTION_NAME].
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
DOCKER FILE COMMANDS.

1. COMMAND [FROM IMAGE_NAME AS STAGE_NAME].
   A. PARAMETER [IMAGE_NAME] identifikuje IMAGE. VALUE moze obsahovat URL na IMAGE v IMAGE REGISTRY, alebo IMAGE NAME nastaveny v niektorom z predoslych BUILD STAGES.
   B. PARAMETER [STAGE_NAME] je nazov STAGE, ktory je mozne pouzit v nasledujucich COMMANDS.
   !!! C. COMMAND inicializuje BUILD STAGE nastavenim IMAGE, ktory sa bude pouzivat pre vykonanie nasledujucich COMMANDS.
2. COMMAND [USER USER_NAME].
   A. PARAMETER [USER_NAME] je nazov USER.
   B. COMMAND nastavuje USER, ktory sa pouzije pre vykonanie nasledujucich COMMANDS.
3. COMMAND [WORKDIR DIRECTORY_NAME].
   A. PARAMETER [DIRECTORY_NAME] je nazov DIRECTORY.
   B. COMMAND nastavuje WORKING DIRECTORY v ramci vytvaraneho DOCKER CONTAINER.
   !!! C. Ak DIRECTORY NEEXISTUJE, ja AUTOMATICKY VYTVORENY.
   D. CURRENT DIRECTORY je analogiou CHANGE DIRECTORY a aplikuje sa dalsie COMMANDS vykonane nad vytvaranym DOCKER CONTAINER.
4. COMMAND [EXPOSE PORT_NUMBER].
   A. PARAMETER [PORT_NUMBER] obsahuje cislo PORT.
   B. COMMAND urcuje PORT, ktory DOCKER IMAGE vystavi pre DOCKER CONTAINER.
   !!!!! C. PORT je vystaveny IBA z DOCKER IMAGE do DOCKER CONTAINER a nie z DOCKER CONTAINER do HOST MACHINE.
   !!!!! D. VISUAL STUDIO pri pridani DOCKER FILE do PROJECT prida do FILE [launchSettings.json] PROFILE pre DOCKER, ktory obsahuje PORTS na ktorych bude PROGRAM v DOCKER vystaveny.
   E. PORT je BY-DEFAULT TCP PORT.
5. COMMAND [ARG VARIABLE_NAME=VALUE].
   A. PARAMETER [VARIABLE_NAME] je VARIABLE NAME, ktorej VALUE sa nastavuje.
   B. PARAMETER [VALUE] je VALUE na ktoru bude nastavena VARIABLE.
   C. COMMAND nastavuje VARIABLE na VALUE, ktora moze byt pouzita v nasledujucich COMMANDS.
6. COMMAND [COPY [SOURCE_1,...,SOURCE_N,DESTINATION]].
   A. PARAMETER [SOURCE_X] obsahuje SOURCE FILE, alebo DIRECTORY, ktory sa ma kopirovat.
   B. PARAMETER [DESTINATION] obsahuje DESTINATION FILE, alebo DIRECTORY vo vytvaranom DOCKER CONTAINER, kde sa ma FILE, alebo DIRECTORY kopirovat.
   !!! C. OPTION [--from=IMAGE_OR_STAGE] umozuje definovat SOURCE IMAGE, alebo SOURCE STAGE z ktorej sa maju FILES a DIRECTORIES kopirovat.
   D. COMMAND kopiruje FILES, alebo DIRECTORY zo SOURCE PATH do DESTINATION PATH vytvaraneho DOCKER CONTAINER.
   !!!!! E. BY-DEFAULT SOURCE PATH odkazuje na LOCAL FILE SYSTEM.
   !!!!! F. Pouzitim OPTION [--from=IMAGE_OR_STAGE] je mozne nastavit, aby sa SOURCE PATH bral z definovaneho IMAGE, alebo definovanej STAGE.
7. COMMAND [RUN [COMMAND_1,...,COMMAND_N]].
   A. PARAMETER [COMMAND_X] obsahuje COMMAND, ktory sa ma pre dany IMAGE vykonat.
   !!! B. COMMAND vykonava specifikovane COMMANDS nad IMAGE, ktory je pre CURRENT STAGE nastaveny. Nasledne vytvori novy LAYER z vysledkov spustenych COMMANDS. LAYER moze byt pouzity v nasledujucich COMMANDS.
8. COMMAND [ENTRYPOINT [EXECUTABLE,,PARAMETER_1...,PARAMETER_N]].
   A. PARAMETER [EXECUTABLE] urcuje COMMAND, ktory sa ma spustit v DOCKER CONTAINER.
   B. PARAMETER [PARAMETER_X] obsahuje PARAMETER definovaneho COMMAND.
   C. COMMAND umoznuje spustit PROGRAM, ktory bude bezat v danom DOCKER CONTAINER.
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
DOCKER COMMANDS.

1. COMMAND [docker build -t TAG_NAME -f PATH_DOCKER_FILE PATH_BUILD_DIRECTORY].
   A. PARAMETER [TAG_NAME] obsahuje TAG NAME identifikujuci DOCKER IMAGE.
   B. PARAMETER [PATH_DOCKER_FILE] obsahuje PATH k DOCKER FILE.
   C. PARAMETER [PATH_BUILD_DIRECTORY] obsahuje PATH k BUILD DIRECTORY, ktory urcuje pre DOCKER FILE BASE DIRECTORY.
   D. COMMAND vykonava BUILD DOCKER IMAGE z DOCKER FILE.
   !!! E. COMMAND moze byt vykonany IBA, ak je zapnuty DOCKER DESKTOP.
2. COMMAND [docker image list].
   A. COMMAND zobrazuje zoznam vsetkych DOCKER IMAGES.
   B. COMMAND ma ALIAS [docker images].
3. COMMAND [docker image remove IMAGE_ID].
   A. PARAMETER [IMAGE_ID] obsahuje IMAGE IDENTIFIER.
   B. COMMAND odstrani DOCKER IMAGE.
4. COMMAND [docker run -d -p HOST_MACHINE_PORT:DOCKER_CONTAINER_PORT --name CONTAINER_NAME IMAGE_NAME]
   A. PARAMETER [HOST_MACHINE_PORT] obsahuje cislo HOST MACHINE PORT, do ktoreho bude mapovany na DOCKER CONTAINER PORT.
   B. PARAMETER [DOCKER_CONTAINER_PORT] obsahuje cislo DOCKER CONTAINER PORT, ktory mat byt mapovany na HOST MACHINE PORT.
   C. PARAMETER [CONTAINER_NAME] obsahuje CONTAINER NAME.
   D. PARAMETER [IMAGE_NAME] obsahuje IMAGE NAME z ktoreho sa ma spustit CONTAINER.
   E. OPTION [-d] urcuje, ze CONTAINER ma byt spusteny v DETACHED MODE co znamena, ze CONTAINER bude bezat v BACKGROUND.
   F. COMMAND spusta DOCKER CONTAINER z definovaneho DOCKER IMAGE.
5. COMMAND [docker container list -a].
   A. OPTION [-a] zobrazuje vsetky DOCKER CONTAINERS, vratane tych, ktore nebezia.
   B. COMMAND zobrazuje zoznam DOCKER CONTAINERS.
!!! 6. COMMAND [docker container logs DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND zobrazuje LOGS, ktore vygeneroval DOCKER CONTAINER.
!!! 7. COMMAND [docker container remove DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND odstranuje DOCKER CONTAINER.
8. COMMAND [docker container port DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND zobrazuje mapovanie PORTS pre CONTAINER.
9. COMMAND [docker container port DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND zobrazuje mapovanie PORTS pre CONTAINER.
10. COMMAND [docker container start DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND spusta CONTAINER.
11. COMMAND [docker container stop DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND zastavuje CONTAINER.
12. COMMAND [docker container restart DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND vykona restart CONTAINER.
13. COMMAND [docker container stats DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND zobrazuje RESOURCE STATISTICS.
14. COMMAND [docker container top DOCKER_NAME_OR_ID].
   A. PARAMETER [DOCKER_NAME_OR_ID] obsahuje nazov DOCKER CONTAINER, alebo DOCKER CONTAINER ID.
   B. COMMAND zobrazuje zoznam PROCESSES, ktore bezia v danom CONTAINER.
15. COMMAND [docker version]. COMMAND zobrazuje VERSION DOCKER.
16. COMMAND [docker system info]. COMMAND zobrazuje SYSTEM INFORMATION.
//----------------------------------------------------------------------------------------------------------------------