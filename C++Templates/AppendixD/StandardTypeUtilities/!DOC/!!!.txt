//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie TYPE TRAITS v C++.
2. C++ STANDARD LIBRARY definuje TYPE TRAITS v LIBRARY [<type_traits>].
3. Niektore TYPE TRAITS su implementovane za podpory COMPILER, a nie je ich mozne implementovat iba pomocou C++.
4. TYPE TRAITS je mozne rozdelit do nasledujucich kategorii.
   A. TYPE TRAITS vracajuce TYPE.
   B. TYPE TRAITS vracajuce VALUE.
5. TYPE TRAITS vracajuce TYPE mozu vracat kalkulovany TYPE nasledujucimi sposobmi.
   A. CODE [TYPE_TRAIT<TEMPLATE_PARAMETERS>::type], vracia pomocou USING [type] kalkulovany TYPE.
   B. CODE [TYPE_TRAIT_t<TEMPLATE_PARAMETERS>], priamo vracia kalkulovany TYPE.
6. TYPE TRAITS vracajuce VALUE mozu vracat kalkulovanu VALUE nasledujucimi sposobmi.
   A. CODE [TYPE_TRAIT<TEMPLATE_PARAMETERS>::value], vracia pomocou STATIC FIELD [value] kalkulovanu VALUE.
   B. CODE [TYPE_TRAIT_v<TEMPLATE_PARAMETERS>], priamo vracia kalkulovanu VALUE.
   C. CODE [TYPE_TRAIT<TEMPLATE_PARAMETERS>{}] pomocou CONVERSION [OPERATOR bool()] vracia kalkulovanu VALUE.
   D. CODE [TYPE_TRAIT<TEMPLATE_PARAMETERS>()] pomocou OPERATOR [OPERATOR()] vracia kalkulovanu VALUE.
7. Vsetky C++ STANDARD LIBRARY TYPE TRAITS, ktore vracaju VALUE su DERIVED zo STRUCT [template<typename TType, TType VALUE> integral_constant]. STRUCT [template<typename TType, TType Value> integral_constant] ma nasledujuce MEMBERS.
   A. STATIC CONSTEXPR FIELD [TType value] obsahuje VALUE danho TYPE TRAIT.
   B. USING [value_type] obsahuje TYPE danho TYPE TRAIT. Vo vacsine TYPE TRAITS, ktore vracaju VALUE je to TYPE [bool].
   C. USING [type] TYPE samotneho TYPE TRAIT, ktore je nastaveny na TYPE [integral_constant<TType,VALUE>].
   D. CONSTEXPR CONVERSION OPERATOR [constexpr operator value_type() const noexcept] vracia VALUE danho TYPE TRAIT.
   E. CONSTEXPR OPERATOR [constexpr value_type operator()() const noexcept] vracia VALUE danho TYPE TRAIT.
8. Pre TYPE [bool] definuje C++ STANDARD LIBRARY nasledujuce USINGS.
   A. USING [template<bool VALUE> using bool_constant=integral_constant<bool,VALUE>].
   B. USING [using true_type=bool_constant<true>].
   C. USING [using false_type=bool_constant<false>].
!!! 9. C++ STANDARD LIBRARIES TYPE TRAITS vracajuce VALUE TYPE [bool] su implementovane nasledovne.
   A. Ak TYPE TRAITS vracajuce VALUE TYPE [bool] vracaju VALUE [true], tak su DERIVED z TYPE [true_type].
   B. Ak TYPE TRAITS vracajuce VALUE TYPE [bool] vracaju VALUE [false], tak su DERIVED z TYPE [false_type].
10. Pre TYPE TRAIT [is_void<TType>] platia nasledujuce fakty.
   A. USING [is_void<TType>::value] vracia VALUE [true], ake je TYPE 'TType' TYPE [void].
   B. USING [is_void<TType>::value] vracia VALUE [false], ake je TYPE 'TType' NIE JE TYPE [void].
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
11. Pre TYPE TRAIT [is_integral<TType>] platia nasledujuce fakty.
   A. USING [is_integral<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES a INTEGER TYPES.
   B. USING [is_integral<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
12. Pre TYPE TRAIT [is_floating_point<TType>] platia nasledujuce fakty.
   A. USING [is_floating_point<TType>::value] vracia VALUE [true] pre FLOATING POINT TYPES.
   B. USING [is_floating_point<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
13. Pre TYPE TRAIT [is_array<TType>] platia nasledujuce fakty.
   A. USING [is_array<TType>::value] vracia VALUE [true] pre C-ARRAYS, bez ohladu na to ci maju, alebo nemaju definovanu LENGTH.
   B. USING [is_array<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
14. Pre TYPE TRAIT [is_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_pointer<TType>::value] vracia VALUE [true] pre POINTERS, vratane POINTERS na FUNCTIONS.
   B. USING [is_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES, vratane, C-ARRAYS, POINTERS TO MEMBERS (FIELDS a METHODS) a TYPE [nullptr_t].
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
15. Pre TYPE TRAIT [is_null_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_null_pointer<TType>::value] vracia VALUE [true] pre	TYPE [nullptr_t].
   B. USING [is_null_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
16. Pre TYPE TRAIT [is_member_object_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_member_object_pointer<TType>::value] vracia VALUE [true] pre TYPE POINTER na FIELD TYPE 'TType'.
   B. USING [is_member_object_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
17. Pre TYPE TRAIT [is_member_function_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_member_function_pointer<TType>::value] vracia VALUE [true] pre TYPE POINTER na METHOD TYPE 'TType'.
   B. USING [is_member_function_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
18. Pre TYPE TRAIT [is_lvalue_reference<TType>] platia nasledujuce fakty.
   A. USING [is_lvalue_reference<TType>::value] vracia VALUE [true] pre TYPE predstavuje LVALUE REFERENCE.
   B. USING [is_lvalue_reference<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
19. Pre TYPE TRAIT [is_rvalue_reference<TType>] platia nasledujuce fakty.
   A. USING [is_rvalue_reference<TType>::value] vracia VALUE [true] pre TYPE predstavuje RVALUE REFERENCE.
   B. USING [is_rvalue_reference<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
20. Pre TYPE TRAIT [is_enum<TType>] platia nasledujuce fakty.
   A. USING [is_enum<TType>::value] vracia VALUE [true] pre UNSCOPED ENUMS (KEYWORD [enum]) a SCOPED ENUMS (KEYWORD [enum class]).
   B. USING [is_enum<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
21. Pre TYPE TRAIT [is_class<TType>] platia nasledujuce fakty.
   A. USING [is_class<TType>::value] vracia VALUE [true] pre CLASSES, STRUCTURES a LAMBDA EXPRESSIONS, ktore su interne implementovane ako CLASSES.
   B. USING [is_class<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
22. Pre TYPE TRAIT [is_union<TType>] platia nasledujuce fakty.
   A. USING [is_union<TType>::value] vracia VALUE [true] pre UNIONS a UNION TEMPLATES.
   B. USING [is_union<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
23. Pre TYPE TRAIT [is_function<TType>] platia nasledujuce fakty.
   A. USING [is_function<TType>::value] vracia VALUE [true] pre FUNCTIONS a METHODS.
   B. USING [is_function<TType>::value] vracia VALUE [false] pre POINTERS na FUNCTIONS, LAMBDA EXPRESSIONS a pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
24. Pre TYPE TRAIT [is_reference<TType>] platia nasledujuce fakty.
   A. USING [is_reference<TType>::value] vracia VALUE [true] pre TYPE predstavuje REFERENCE TYPE.
   B. USING [is_reference<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
25. Pre TYPE TRAIT [is_member_pointer<TType>] platia nasledujuce fakty.
   A. USING [is_member_pointer<TType>::value] vracia VALUE [true] pre TYPE POINTER na FIELD TYPE 'TType' a pre TYPE POINTER na METHOD TYPE 'TType'.
   B. USING [is_member_pointer<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
26. Pre TYPE TRAIT [is_arithmetic<TType>] platia nasledujuce fakty.
   A. USING [is_arithmetic<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES, INTEGER TYPES a FLOATING POINT TYPES.
   B. USING [is_arithmetic<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
27. Pre TYPE TRAIT [is_fundamental<TType>] platia nasledujuce fakty.
   A. USING [is_fundamental<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES, INTEGER TYPES, FLOATING POINT TYPES, TYPE [void] a TYPE [nullptr_t].
   B. USING [is_fundamental<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
28. Pre TYPE TRAIT [is_scalar<TType>] platia nasledujuce fakty.
   A. USING [is_scalar<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES, INTEGER TYPES, FLOATING POINT TYPES, POINTER TYPES, POINTER TO MEMBER TYPES, ENUM TYPES a TYPE [nullptr_t].
   B. USING [is_scalar<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
29. Pre TYPE TRAIT [is_object<TType>] platia nasledujuce fakty.
   A. USING [is_object<TType>::value] vracia VALUE [true] pre TYPE [bool], CHARACTER TYPES, INTEGER TYPES, FLOATING POINT TYPES, POINTER TYPES, POINTER TO MEMBER TYPES, ENUM TYPES, ARRAY TYPES, CLASS TYPES, STRUCTURE TYPES, UNION TYPES a TYPE [nullptr_t].
   B. USING [is_object<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
30. Pre TYPE TRAIT [is_compound<TType>] platia nasledujuce fakty.
   A. USING [is_compound<TType>::value] vracia VALUE [true] pre ENUM TYPES, ARRAY TYPES, CLASS TYPES, STRUCTUR TYPES, UNION TYPES, REFERENCE TYPES, POINTER TYPES, POINTER TO MEMBER TYPES a FUNCTION TYPES.
   B. USING [is_compound<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
31. Pre TYPE TRAIT [is_signed<TType>] platia nasledujuce fakty.
   A. USING [is_signed<TType>::value] vracia VALUE [true] pre ARITHMETIC TYPES, ktore su SIGNED.
   B. USING [is_signed<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES, vratane ENUM TYPES a TYPE [bool].
   C. USING [is_signed<TType>::value] vracia pre TYPE [char] vracia IMPLEMENTATION DEFINED VALUE.
   D. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
32. Pre TYPE TRAIT [is_unsigned<TType>] platia nasledujuce fakty.
   A. USING [is_unsigned<TType>::value] vracia VALUE [true] pre ARITHMETIC TYPES, ktore su UNSIGNED, vratane TYPE [bool].
   B. USING [is_unsigned<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES, vratane ENUM TYPES.
   C. USING [is_unsigned<TType>::value] vracia pre TYPE [char] vracia IMPLEMENTATION DEFINED VALUE.
   D. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
33. Pre TYPE TRAIT [is_const<TType>] platia nasledujuce fakty.
   A. USING [is_const<TType>::value] vracia VALUE [true] pre CONSTANT TYPES, vratane CONSTANT POINTERS a ARRAYS obsahujucich CONSTANT VALUES.
   B. USING [is_const<TType>::value] vracia VALUE [false] pre NON-CONSTANT TYPES, vratane NON-CONSTANT POINTERS, NON-CONSTANT REFERENCES a ARRAYS obsahujucich NON-CONSTANT VALUES. VALUE [false] je takisto vratena pre NON-CONSTANT POINTERS na CONSTANTS, NON-CONSTANT REFERENCES na CONSTANTS ci ARRAYS obsahujucich NON-CONSTANT VALUES.
34. Pre TYPE TRAIT [is_volatile<TType>] platia nasledujuce fakty.
   A. USING [is_volatile<TType>::value] vracia VALUE [true] pre VOLATILE TYPES, vratane VOLATILE POINTERS a ARRAYS obsahujucich VOLATILE VALUES.
   B. USING [is_volatile<TType>::value] vracia VALUE [false] pre NON-VOLATILE TYPES, vratane NON-VOLATILE POINTERS, NON-VOLATILE REFERENCES a ARRAYS obsahujucich NON-VOLATILE VALUES. VALUE [false] je takisto vratena pre NON-VOLATILE POINTERS na VOLATILES, NON-VOLATILE REFERENCES na VOLATILES ci ARRAYS obsahujucich NON-VOLATILE VALUES.
35. Pre TYPE TRAIT [is_aggregate<TType>] platia nasledujuce fakty.
   A. USING [is_aggregate<TType>::value] vracia VALUE [true] pre AGGREGATE TYPES.
   B. USING [is_aggregate<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
36. AGGREGATE TYPES su bud C-LIKE ARRAYS, alebo USER DEFINED TYPES (CLASSES, STRUCTURES, UNIONS) s nasledujucimi obmedzeniami.
   A. Nemaju definovany CUSTOM CONSTRUCTOR.
   B. Nemaju PRIVATE, alebo PROTECTED FIELDS.
   C. Nemaju NON-PUBLIC BASE CLASSES.
   D. Nemaju VIRTUAL METHODS.
37. Pre TYPE TRAIT [is_trivial<TType>] platia nasledujuce fakty.
   A. USING [is_trivial<TType>::value] vracia VALUE [true] pre SCALAR TYPES, TRIVIAL CLASS TYPES, ARRAYS SCALAR TYPES a ARRAYS TRIVIAL CLASS TYPES.
   B. USING [is_trivial<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
38. TRIVIAL CLASS TYPES su USER DEFINED CLASSES s nasledujucimi obmedzeniami.
   A. Nemaju definovany CUSTOM DEFAULT CONSTRUCTOR, CUSTOM CONSTRUCTOR, CUSTOM COPY CONSTRUCTOR a CUSTOM MOVE CONSTRUCTOR.
   B. Nemaju definovany CUSTOM COPY OPERATOR [OPERATOR=] a CUSTOM MOVE OPERATOR [OPERATOR=].
   C. Nemaju definovany CUSTOM DESTRUCTOR.
   D. Nemaju VIRTUAL METHODS.
   E. Nemaju VIRTUAL BASE CLASSES.
   F. Nemaju NON TRIVIAL FIELDS.
   G. Nemaju VOLATILE FIELDS.
39. Pre TYPE TRAIT [is_trivial<TType>] platia nasledujuce fakty.
   A. USING [is_trivial<TType>::value] vracia VALUE [true] pre SCALAR TYPES, TRIVIALLY COPYABLE CLASS TYPES, ARRAYS SCALAR TYPES a ARRAYS TRIVIALLY COPYABLE CLASS TYPES.
   B. USING [is_trivial<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
40. TRIVIALLY COPYABLE CLASS TYPES su USER DEFINED CLASSES s nasledujucimi obmedzeniami.
   !!! A. Mozu mat definovany CUSTOM DEFAULT 
   B. Nemaju definovany CUSTOM CONSTRUCTOR, CUSTOM COPY CONSTRUCTOR a CUSTOM MOVE CONSTRUCTOR.
   C. Nemaju definovany CUSTOM COPY OPERATOR [OPERATOR=] a CUSTOM MOVE OPERATOR [OPERATOR=].
   D. Nemaju definovany CUSTOM DESTRUCTOR.
   E. Nemaju VIRTUAL METHODS.
   F. Nemaju VIRTUAL BASE CLASSES.
   G. Nemaju NON TRIVIAL FIELDS.
   H. Nemaju VOLATILE FIELDS.
41. Pre TYPE TRAIT [is_standard_layout<TType>] platia nasledujuce fakty.
   A. USING [is_standard_layout<TType>::value] vracia VALUE [true] pre SCALAR TYPES, STANDARD LAYOUT CLASS TYPES, ARRAYS SCALAR TYPES a ARRAYS STANDARD LAYOUT CLASS TYPES.
   B. USING [is_standard_layout<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
42. STANDARD LAYOUT CLASS TYPES su USER DEFINED CLASSES s nasledujucimi obmedzeniami.
   A. Maju rovnaky ACCESS MODIFIER pre vsetky FIELDS.
   B. Nemaju VIRTUAL METHODS.
   C. Nemaju NON STANDARD LAYOUT BASE CLASSES.
   D. Nemaju VIRTUAL BASE CLASSES.
   E. Nemaju NON STANDARD LAYOUT NON STATIC FIELDS.
   F. Nemaju NON STATIC REFERENCE FIELDS.
43. Pre TYPE TRAIT [is_empty<TType>] platia nasledujuce fakty.
   A. USING [is_empty<TType>::value] vracia VALUE [true] pre CLASS TYPES, ktore nemaju NON-STATIC FIELDS, nemaju VIRTUAL METHODS, nemaju VIRTUAL BASE CLASSES a maju iba EMTPY BASE CLASSES.
   B. USING [is_empty<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
44. Pre TYPE TRAIT [is_polymorphic<TType>] platia nasledujuce fakty.
   A. USING [is_polymorphic<TType>::value] vracia VALUE [true] pre CLASSES, ktore maju VIRTUAL METHODS.
   B. USING [is_polymorphic<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
45. Pre TYPE TRAIT [is_abstract<TType>] platia nasledujuce fakty.
   A. USING [is_abstract<TType>::value] vracia VALUE [true] pre CLASSES, ktore maju PURE VIRTUAL METHODS.
   B. USING [is_abstract<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
46. Pre TYPE TRAIT [is_final<TType>] platia nasledujuce fakty.
   A. USING [is_final<TType>::value] vracia VALUE [true] pre FINAL CLASSES.
   B. USING [is_final<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
47. Pre TYPE TRAIT [has_virtual_destructor<TType>] platia nasledujuce fakty.
   A. USING [has_virtual_destructor<TType>::value] vracia VALUE [true] pre CLASSES, ktore maju VIRTUAL DESTRUCTORS.
   B. USING [has_virtual_destructor<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
48. Pre TYPE TRAIT [has_unique_object_representations<TType>] platia nasledujuce fakty.
   A. USING [has_unique_object_representations<TType>::value] vracia VALUE [true] pre TYPES, ktore su TRIVIALLY COPIABLE a ktorych BINARY REPRESENTATION je ROVNAKA, ak obsahuju ich FIELDS tie iste VALUES. Takisto pre ARRAYS takychto CLASSES vracia TYPE TRAIT VALUE [true].
   B. USING [has_unique_object_representations<TType>::value] vracia VALUE [false] pre vsetky ostatne TYPES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
   !!! D. Pre CLASSES, pre ktore TYPE TRAIT [has_unique_object_representations<TType>::value] vracia VALUE [true] je plati, ze vzdy je pre ne mozne vypocitat validny HASH CODE.
   !!!!! E. To, ktore SCALAR TYPES splnaju tuto podmienku je IMPLEMENTATION DEFINED.
49. Pre TYPE TRAIT [alignment_of<TType>] platia nasledujuce fakty.
   A. USING [alignment_of<TType>::value] TYPE [size_t] vracia pocet BYTES potrebnych na zarovnanie daneho TYPE.
   B. USING [alignment_of<TType>::value] vracia tu istu VALUE ako OPERATOR [alignof(TYPE)].
50. Pre TYPE TRAIT [rank<TType>] platia nasledujuce fakty.
   A. USING [rank<TType>::value] TYPE [size_t] pre C-ARRAYS vracia pocet DIMENSIONS daneho C-ARRAY.
   B. USING [rank<TType>::value] TYPE [size_t] vracia VALUE [0] pre vsetky ostatne TYPES.
51. Pre TYPE TRAIT [extent<TType,INDEX>] platia nasledujuce fakty.
   A. USING [extent<TType,INDEX>::value] TYPE [size_t] pre C-ARRAYS vracia velkost C-ARRAY pre DIMENSION [INDEX]. Ak dany ARRAY nema danu DIMENSION, tak TYPE TRAIT vracia VALUE [0].
   B. USING [extent<TType,INDEX>::value] TYPE [size_t] vracia VALUE [0] pre vsetky ostatne TYPES.
52. Pre TYPE TRAIT [underlying_type<TType>] platia nasledujuce fakty.
   A. USING [underlying_type<TType>::type] vracia UNDERLYING TYPE ENUM TYPE.
   B. USING [underlying_type<TType>::type] pre NON-ENUM TYPES je UNDEFINED.
53. Pre TYPE TRAIT [is_invocable<TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [is_invocable<TFunction,TArguments...>::value] vracia VALUE [true] ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_invocable<TFunction,TArguments...>::value] vracia VALUE [false] ak TYPE [TFunction] NIE JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...].
54. Pre TYPE TRAIT [is_nothrow_invocable<TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [is_nothrow_invocable<TFunction,TArguments...>::value] vracia VALUE [true] ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...] a zaroven FUNCTION [TFunction] nehadze EXCEPTIONS. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_nothrow_invocable<TFunction,TArguments...>::value] vracia VALUE [false] ak TYPE [TFunction] NIE JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...], alebo ak FUNCTION [TFunction] moze hodit EXCEPTIONS.
55. Pre TYPE TRAIT [is_invocable_r<TReturnValue,TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [is_invocable_r<TReturnValue,TFunction,TArguments...>::value] vracia VALUE [true] ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...] a zaroven RETURN VALUE TYPE je CONVERTIBLE na TYPE [TReturnValue]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_invocable_r<TReturnValue,TFunction,TArguments...>::value] vracia VALUE [false] ak TYPE [TFunction] NIE JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...], ktorej RETURN VALUE TYPE je CONVERTIBLE na TYPE [TReturnValue].
56. Pre TYPE TRAIT [is_nothrow_invocable_r<TReturnValue,TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [is_nothrow_invocable_r<TReturnValue,TFunction,TArguments...>::value] vracia VALUE [true] ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...], RETURN VALUE TYPE je CONVERTIBLE na TYPE [TReturnValue] a zaroven FUNCTION [TFunction] nehadze EXCEPTIONS. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_nothrow_invocable_r<TReturnValue,TFunction,TArguments...>::value] vracia VALUE [false] ak TYPE [TFunction] NIE JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...], ktorej RETURN VALUE TYPE je CONVERTIBLE na TYPE [TReturnValue], alebo ak FUNCTION [TFunction] moze hodit EXCEPTIONS.
57. Pre TYPE TRAIT [invoke_result<TFunction,TArguments...>] platia nasledujuce fakty.
   A. USING [invoke_result<TFunction,TArguments...>::type] vracia RETURN VALUE TYPE, ak TYPE [TFunction] JE mozne volat ako FUNCTION s ARGUMENTS [TArguments...]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [invoke_result<TFunction,TArguments...>::type] nie je DEFINED ak FUNCTION [TFunction] nie je CALLABLE pre ARGUMENTS [TArguments...].
58. Pre TYPE TRAIT [is_constructible<TType,TArguments...>] platia nasledujuce fakty.
   A. USING [is_constructible<TType,TArguments...>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim CONSTRUCTOR s AGRUMENTS [TArguments...]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_constructible<TType,TArguments...>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim CONSTRUCTOR s AGRUMENTS [TArguments...].
   !!! C. Ak USING [is_constructible<TType,TArguments...>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_destructible<TType>::value] vrati VALUE [true].
59. Pre TYPE TRAIT [is_trivially_constructible<TType,TArguments...>] platia nasledujuce fakty.
   A. USING [is_trivially_constructible<TType,TArguments...>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) CONSTRUCTOR s AGRUMENTS [TArguments...]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_trivially_constructible<TType,TArguments...>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim TRIVIAL CONSTRUCTOR s AGRUMENTS [TArguments...].
   !!! C. Ak USING [is_trivially_constructible<TType,TArguments...>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_trivially_destructible<TType>::value] vrati VALUE [true].
60. Pre TYPE TRAIT [is_nothrow_constructible<TType,TArguments...>] platia nasledujuce fakty.
   A. USING [is_nothrow_constructible<TType,TArguments...>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim CONSTRUCTOR s AGRUMENTS [TArguments...] pricom CONSTRUCTOR je oznaceny pomocou KEYWORD [noexcept]. ARGUMENTS mozu byt na PARAMETERS aj CONVERTIBLE.
   B. USING [is_nothrow_constructible<TType,TArguments...>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim CONSTRUCTOR s AGRUMENTS [TArguments...], alebo dany CONSTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!! C. Ak USING [is_nothrow_constructible<TType,TArguments...>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_nothrow_destructible<TType>::value] vrati VALUE [true].
61. Pre TYPE TRAIT [is_default_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_default_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim DEFAULT CONSTRUCTOR.
   B. USING [is_default_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim DEFAULT CONSTRUCTOR.
   !!! C. Ak USING [is_default_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_default_constructible<TType>::value] vracia tu istu VALUE ako USING [is_constructible<TType>::value].
62. Pre TYPE TRAIT [is_trivially_default_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_default_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) DEFAULT CONSTRUCTOR.
   B. USING [is_trivially_default_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim TRIVIAL DEFAULT CONSTRUCTOR.
   !!! C. Ak USING [is_trivially_default_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_trivially_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_trivially_default_constructible<TType>::value] vracia tu istu VALUE ako USING [is_trivially_constructible<TType>::value].
63. Pre TYPE TRAIT [is_nothrow_default_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_default_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim DEFAULT CONSTRUCTOR pricom CONSTRUCTOR je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_default_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim DEFAULT CONSTRUCTOR, alebo dany CONSTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!! C. Ak USING [is_nothrow_default_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_nothrow_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_nothrow_default_constructible<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_constructible<TType>::value].
64. Pre TYPE TRAIT [is_copy_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_copy_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim COPY CONSTRUCTOR.
   B. USING [is_copy_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim COPY CONSTRUCTOR.
   !!! C. Ak USING [is_copy_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_copy_constructible<TType>::value] vracia tu istu VALUE ako USING [is_constructible<TType,const TType&>::value].
65. Pre TYPE TRAIT [is_trivially_copy_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_copy_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) COPY CONSTRUCTOR.
   B. USING [is_trivially_copy_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim TRIVIAL COPY CONSTRUCTOR.
   !!! C. Ak USING [is_trivially_copy_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_trivially_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_trivially_copy_constructible<TType>::value] vracia tu istu VALUE ako USING [is_trivially_constructible<TType,const TType&>::value].
66. Pre TYPE TRAIT [is_nothrow_copy_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_copy_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim COPY CONSTRUCTOR pricom CONSTRUCTOR je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_copy_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim COPY CONSTRUCTOR, alebo dany CONSTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!! C. Ak USING [is_nothrow_copy_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_nothrow_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_nothrow_copy_constructible<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_constructible<TType,const TType&>::value].
67. Pre TYPE TRAIT [is_move_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_move_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim MOVE CONSTRUCTOR.
   B. USING [is_move_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim MOVE CONSTRUCTOR.
   !!! C. Ak USING [is_move_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_move_constructible<TType>::value] vracia tu istu VALUE ako USING [is_constructible<TType,TType&&>::value].
68. Pre TYPE TRAIT [is_trivially_move_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_move_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) MOVE CONSTRUCTOR.
   B. USING [is_trivially_move_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim TRIVIAL MOVE CONSTRUCTOR.
   !!! C. Ak USING [is_trivially_move_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_trivially_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_trivially_move_constructible<TType>::value] vracia tu istu VALUE ako USING [is_trivially_constructible<TType,TType&&>::value].
69. Pre TYPE TRAIT [is_nothrow_move_constructible<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_move_constructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne vytvorit volanim MOVE CONSTRUCTOR pricom CONSTRUCTOR je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_move_constructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne vytvorit volanim MOVE CONSTRUCTOR, alebo dany CONSTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!! C. Ak USING [is_nothrow_move_constructible<TType>::value] vracia VALUE [true], tak aj TYPE TRAIT [is_nothrow_destructible<TType>::value] vrati VALUE [true].
   !!! D. USING [is_nothrow_move_constructible<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_constructible<TType,TType&&>::value].
70. Pre TYPE TRAIT [is_assignable<TTo,TFrom>] platia nasledujuce fakty.
   A. USING [is_assignable<TTo,TFrom>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TFrom] je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou OPERATOR [OPERATOR=].
   B. USING [is_assignable<TTo,TFrom>::value] vracia VALUE [false] RVALUE REFERENCE TYPE [TFrom] NIE je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou OPERATOR [OPERATOR=].
   !!!!! C. USING [is_assignable<TTo,TFrom>::value] vracia VALUE [false] aj vtedy, ak TYPE [TFrom] a TYPE [TTo] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [10=10], ktory v C++ je neplatny.
71. Pre TYPE TRAIT [is_trivially_assignable<TTo,TFrom>] platia nasledujuce fakty.
   A. USING [is_trivially_assignable<TTo,TFrom>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TFrom] je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou TRIVIAL (NOT DEFINED) OPERATOR [OPERATOR=].
   B. USING [is_trivially_assignable<TTo,TFrom>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TFrom] NIE je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou TRIVIAL (NOT DEFINED) OPERATOR [OPERATOR=].
   !!!!! C. USING [is_trivially_assignable<TTo,TFrom>::value] vracia VALUE [false] aj vtedy, ak TYPE [TFrom] a TYPE [TTo] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [10=10], ktory v C++ je neplatny.
72. Pre TYPE TRAIT [is_nothrow_assignable<TTo,TFrom>] platia nasledujuce fakty.
   A. USING [is_nothrow_assignable<TTo,TFrom>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TFrom] je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou OPERATOR [OPERATOR=], ktory je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_assignable<TTo,TFrom>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TFrom] NIE je mozne priradit do RVALUE REFERENCE TYPE [TTo] pomocou OPERATOR [OPERATOR=], ktory je oznaceny pomocou KEYWORD [noexcept].
   !!!!! C. USING [is_nothrow_assignable<TTo,TFrom>::value] vracia VALUE [false] aj vtedy, ak TYPE [TFrom] a TYPE [TTo] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [10=10], ktory v C++ je neplatny.
73. Pre TYPE TRAIT [is_copy_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_copy_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je mozne volat COPY OPERATOR [OPERATOR=].
   B. USING [is_copy_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat COPY OPERATOR [OPERATOR=]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED COPY OPERATOR [OPERATOR=].
   !!! C. USING [is_copy_assignable<TType>::value] vracia tu istu VALUE ako USING [is_assignable<TType&,const TType&>::value].
74. Pre TYPE TRAIT [is_trivially_copy_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_copy_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je mozne volat TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) COPY OPERATOR [OPERATOR=].
   B. USING [is_trivially_copy_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat TRIVIAL COPY OPERATOR [OPERATOR=]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED COPY OPERATOR [OPERATOR=].
   !!! C. USING [is_trivially_copy_assignable<TType>::value] vracia tu istu VALUE ako USING [is_trivially_assignable<TType&,const TType&>::value].
75. Pre TYPE TRAIT [is_nothrow_copy_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_copy_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je volat COPY OPERATOR [OPERATOR=] pricom COPY OPERATOR [OPERATOR=] je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_copy_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat COPY OPERATOR [OPERATOR=], alebo dany COPY OPERATOR [OPERATOR=] NIE JE oznaceny pomocou KEYWORD [noexcept]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED COPY OPERATOR [OPERATOR=].
   !!! C. USING [is_nothrow_copy_assignable<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_assignable<TType&,const TType&>::value].
76. Pre TYPE TRAIT [is_move_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_move_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je mozne volat MOVE OPERATOR [OPERATOR=].
   B. USING [is_move_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat MOVE OPERATOR [OPERATOR=]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED MOVE OPERATOR [OPERATOR=].
   !!! C. USING [is_move_assignable<TType>::value] vracia tu istu VALUE ako USING [is_assignable<TType&,TType&&>::value].
77. Pre TYPE TRAIT [is_trivially_move_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_move_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je mozne volat TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) MOVE OPERATOR [OPERATOR=].
   B. USING [is_trivially_move_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat TRIVIAL MOVE OPERATOR [OPERATOR=]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED MOVE OPERATOR [OPERATOR=].
   !!! C. USING [is_trivially_move_assignable<TType>::value] vracia tu istu VALUE ako USING [is_trivially_assignable<TType&,TType&&>::value].
78. Pre TYPE TRAIT [is_nothrow_move_assignable<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_move_assignable<TType>::value] vracia VALUE [true] ak pre TYPE [TType] je volat MOVE OPERATOR [OPERATOR=] pricom MOVE OPERATOR [OPERATOR=] je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_move_assignable<TType>::value] vracia VALUE [false] ak pre TYPE [TType] NIE je mozne volat MOVE OPERATOR [OPERATOR=], alebo dany MOVE OPERATOR [OPERATOR=] NIE JE oznaceny pomocou KEYWORD [noexcept]. VALUE [false] je vratena aj pre C-ARRAYS, TYPES s DELETED MOVE OPERATOR [OPERATOR=].
   !!! C. USING [is_nothrow_move_assignable<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_assignable<TType&,TType&&>::value].
79. Pre TYPE TRAIT [is_destructible<TType>] platia nasledujuce fakty.
   A. USING [is_destructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne uvolnit volanim DESTRUCTOR.
   B. USING [is_destructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne uvolnit volanim DESTRUCTOR. VALUE [false] je vratena aj pre TYPE [void], UNBOUNDED C-ARRAYS a FUNCTION TYPES.
80. Pre TYPE TRAIT [is_trivially_destructible<TType>] platia nasledujuce fakty.
   A. USING [is_trivially_destructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne uvolnit volanim TRIVIAL (IMPLICITNYM, ktory NIE je DEFINOVANY v CODE) DESTRUCTOR.
   B. USING [is_trivially_destructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne uvolnit volanim TRIVIAL DESTRUCTOR. VALUE [false] je vratena aj pre TYPE [void], UNBOUNDED C-ARRAYS a FUNCTION TYPES a takisto vtedy ak ma TYPE BASE CLASSES, alebo FIELDS, ktore NEMAJU TRIVIAL DESTRUCTOR.
81. Pre TYPE TRAIT [is_nothrow_destructible<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_destructible<TType>::value] vracia VALUE [true] ak TYPE [TType] je mozne uvolnit volanim DESTRUCTOR pricom DESTRUCTOR je oznaceny pomocou KEYWORD [noexcept].
   B. USING [is_nothrow_destructible<TType>::value] vracia VALUE [false] ak TYPE [TType] NIE je mozne uvolnit volanim DESTRUCTOR, alebo dany DESTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept].
   !!!!! C. USING [is_nothrow_destructible<TType>::value] vracia VALUE [true], aj ked DESTRUCTOR NIE JE oznaceny pomocou KEYWORD [noexcept]. Je to preto, lebo v C++ DESTRUCTORS NESMU hadzat EXCEPTIONS, a ak niektory DESTRUCTOR hodi EXCEPTION, tak je PROGRAM okamzite TERMINATED.
82. Pre TYPE TRAIT [is_swappable_with<TType1,TType2>] platia nasledujuce fakty.
   A. USING [is_swappable_with<TType1,TType2>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TType1] je SWAPPABLE (ma definovanu FUNCTION void swap(TType1&,TType2&)) s RVALUE REFERENCE TYPE [TType2].
   B. USING [is_swappable_with<TType1,TType2>::value] vracia VALUE [false] RVALUE REFERENCE TYPE [TType1] NIE je je SWAPPABLE s RVALUE REFERENCE TYPE [TType2].
   !!!!! C. USING [is_swappable_with<TType1,TType2>::value] vracia VALUE [false] aj vtedy, ak TYPE [TType1] a TYPE [TType2] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [swap(10,10)], ktory v C++ je neplatny.
83. Pre TYPE TRAIT [is_nothrow_swappable_with<TType1,TType2>] platia nasledujuce fakty.
   A. USING [is_nothrow_swappable_with<TType1,TType2>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TType1] je NO-THROW SWAPPABLE (ma definovanu FUNCTION void swap(TType1&,TType2&)) s RVALUE REFERENCE TYPE [TType2].
   B. USING [is_nothrow_swappable_with<TType1,TType2>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TType1] NIE je NO-THROW SWAPPABLE s RVALUE REFERENCE TYPE [TType2].
   !!!!! C. USING [is_nothrow_swappable_with<TType1,TType2>::value] vracia VALUE [false] aj vtedy, ak TYPE [TType1] a TYPE [TType2] su NON-REFERENCE, NON-CLASS TYPES. Je to preto, lebo taktyto CODE by viedol napriklad ku CODE [swap(10,10)], ktory v C++ je neplatny.
84. Pre TYPE TRAIT [is_swappable<TType>] platia nasledujuce fakty.
   A. USING [is_swappable<TType>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TType] je SWAPPABLE (ma definovanu FUNCTION void swap(TType&,TType&)) s RVALUE REFERENCE TYPE [TType].
   B. USING [is_swappable<TType>::value] vracia VALUE [false] RVALUE REFERENCE TYPE [TType] NIE je je SWAPPABLE s RVALUE REFERENCE TYPE [TType].
   !!! C. USING [is_swappable<TType>::value] vracia tu istu VALUE ako USING [is_swappable_with<TType&,TType&>::value].
85. Pre TYPE TRAIT [is_nothrow_swappable<TType>] platia nasledujuce fakty.
   A. USING [is_nothrow_swappable<TType>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TType] je NO-THROW SWAPPABLE (ma definovanu FUNCTION void swap(TType&,TType&)) s RVALUE REFERENCE TYPE [TType].
   B. USING [is_nothrow_swappable<TType>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TType] NIE je NO-THROW SWAPPABLE s RVALUE REFERENCE TYPE [TType].
   !!! C. USING [is_nothrow_swappable<TType>::value] vracia tu istu VALUE ako USING [is_nothrow_swappable_with<TType&,TType&>::value].
86. Pre TYPE TRAIT [is_same<TType1,TType2>] platia nasledujuce fakty.
   A. USING [is_same<TType1,TType2>::value] vracia VALUE [true] ak TYPE [TType1] je zhodny s TYPE [TType2]. TYPE TRAIT berie do uvahy aj CONST a VOLATILE MODIFIERS, alebo ak TYPES su ALIASES na tie iste TYPES.
   B. USING [is_same<TType1,TType2>::value] vracia VALUE [false] ak TYPE [TType1] je ROZDIELNY od TYPE [TType2]. TYPE TRAIT vracia VALUE [false], aj ked TYPES odkazuju na sice rozne LAMBDA EXPRESSIONS, ktore vsak maju ten isty CODE.
87. Pre TYPE TRAIT [is_base_of<TBase,TDerived>] platia nasledujuce fakty.
   A. USING [is_base_of<TBase,TDerived>::value] vracia VALUE [true] ak TYPE [TBase] je BASE CLASS TYPE [TDerived], alebo su obe TYPES zhodne.
   B. USING [is_base_of<TBase,TDerived>::value] vracia VALUE [false] ak TYPE [TBase] NIE je BASE CLASS TYPE [TDerived], alebo nie su oba TYPES zhodne. VALUE [false] je tiez vratena pre NON-CLASS TYPES ako PRIMITIVE TYPES, C-ARRAYS, POINTERS ci REFERENCES.
   C. TYPE TRAIT IGNORUJE MODIFIER [const] a MODIFIER [volatile].
   D. TYPE TRAIT IGNORUJE ACCESS MODIFIER BASE CLASSES.
88. Pre TYPE TRAIT [is_convertible<TFrom,TTo>] platia nasledujuce fakty.
   A. USING [is_convertible<TFrom,TTo>::value] vracia VALUE [true] ak RVALUE REFERENCE TYPE [TFrom] je konvertovatelna na TYPE [TType2].
   B. USING [is_convertible<TFrom,TTo>::value] vracia VALUE [false] ak RVALUE REFERENCE TYPE [TFrom] NIE JE konvertovatelna na TYPE [TType2].
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
C++ vykonava REFERENCE COLLAPSING. Pre REFERENCE COLLAPSING platia nasledujuce fakty.

1. LVAUE REFERENCE na LVALUE REFERENCE sa transformuje na LVALUE REFERENCE. To znamena, ze TYPE [int& &] sa transformuje na TYPE [int&].
2. RVLAUE REFERENCE na LVALUE REFERENCE sa transformuje na LVALUE REFERENCE. To znamena, ze TYPE [int& &&] sa transformuje na TYPE [int&].
3. LVAUE REFERENCE na RVALUE REFERENCE sa transformuje na LVALUE REFERENCE. To znamena, ze TYPE [int&& &] sa transformuje na TYPE [int&].
!!! 4. RVLAUE REFERENCE na RVALUE REFERENCE sa transformuje na RVALUE REFERENCE. To znamena, ze TYPE [int& &&] sa transformuje na TYPE [int&&].
!!!!! 5. Pri REFERENCE COLLAPSING plati, ze IBA RVLAUE REFERENCE na RVALUE REFERENCE sa transformuje na RVALUE REFERENCE. Vsetky ostatne REFERENCES sa transformuju na LVALUE REFERNCES.
//----------------------------------------------------------------------------------------------------------------------