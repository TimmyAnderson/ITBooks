//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje pracu s MEMORY a RESOURCES v C++.
2. C++ STANDARD LIBRARY definuje niekolko KVAZI-CONTAINERS, ktore ukladaju ITEMS a preto mozu byt povazovane za CONTAINERS, no neimplementuju vsetky funkcnosti, aby mohli byt povazovane za plnohodnotne CONTAINERS. C++ STANDARD LIBRARY definuje nasledujuce KVAZI-CONTAINERS.
   A. C-ARRAY reprezentuje standardny C-ARRAY.
   B. CLASS [class<TItem,Size>] reprezentuje C++ WRAPPER okolo standardnych C-ARRAYS.
   C. CLASS [bitset<Size>] reprezentuje COLLECTION BITS s pevnym poctom BITS.
   D. CLASS [vector<bool,TAllocator>] reprezentuje COLLECTION BITS s variabilnym poctom BITS.
   E. STRUCTURE [pair<TType1,TType2>] reprezentuje COLLECTION 2 VALUES rozlicnych TYPES.
   F. CLASS [tuple<... TTypes>] reprezentuje COLLECTION 'N' VALUES rozlicnych TYPES.
   G. CLASS [basic_string<TChar,TTraits,TAllocator>] reprezentuje COLLECTION ukladajucu CHARACTERS.
   H. CLASS [valarray<TType>] reprezentuje COLLECTION ukladajucu NUMERIC VALUES.
3. CLASS [array<TItem,N>] reprezentuje TEMPLATE CLASS, ktora je WRAPPER nad klasickym C-ARRAY. Pre CLASS [array<TItem,N>] platia nasledujuce fakty.
   A. ARRAY je definovany v LIBRARY <array>.
   B. ARRAY ma konstatny pocet ITEMS, ktory sa definuje ako TEMPLATE PARAMETER a je teda sucastou TYPE.
   C. Do ARRAY nie je mozne ITEMS pridavat, ani ich z nej odstranovat.
   D. ARRAY umoznuje RANDOM ACCESS k ITEMS, ktore su v nom ulozene.
   E. PERFORMANCE ARRAY nie je horsia ako PERFORMANCE C-ARRAY.
   !!!!! F. Instancia ARRAY je spravidla alokovana na STACK a NIE na HEAP. Iba pre velke ARRAYS su tieto alokovane na HEAP.
   !!! G. Pri praci s ARRAY NEDOCHADZA k realokacii MEMORY.
   !!! H. ARRAY GARANTUJE, ze ITEMS su ulozene VZDY v KONTINUALNOM BLOKU MEMORY.
4. CLASS [array<TItem,N>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu ARRAY a vytvara jednotlive ITEMS. COPY CONSTRUCTOR a MOVE CONSTRUCTOR su IMPLICITNE generovane COMPILER.
   2. DESTRUCTOR uvolnuje instanciu ARRAY ako aj jednotlive ITEMS. DESTRUCTOR je IMPLICITNE generovany COMPILER.
   3. TYPE [value_type] urcuje TYPE pre ITEMS ulozene v ARRAY.
   4. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   5. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   6. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v ARRAY.
   7. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v ARRAY.
   8. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v ARRAY.
   9. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v ARRAY.
   10. TYPE [iterator] urcuje TYPE pre ITERATOR daneho ARRAY.
   11. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR daneho ARRAY.
   12. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR daneho ARRAY.
   13. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR daneho ARRAY.
   14. OPERATOR= prepisuje jednotlive ITEMS daneho ARRAY. COPY OPERATOR= a MOVE OPERATOR= su IMPLICITNE generovane COMPILER.
   15. OPERATOR== zistuje ci dve instancie ARRAY su lexikograficky rovne.
   16. OPERATOR!= zistuje ci dve instancie ARRAY su lexikograficky rozne.
   17. OPERATOR< zistuje ci 1. ARRAY je lexikograficky mensi ako 2. ARRAY.
   18. OPERATOR<= zistuje ci 1. ARRAY je lexikograficky mensi, alebo rovny ako 2. ARRAY.
   19. OPERATOR> zistuje ci 1. ARRAY je lexikograficky vacsi ako 2. ARRAY.
   20. OPERATOR>= zistuje ci 1. ARRAY je lexikograficky vacsi, alebo rovny ako 2. ARRAY.
   !!! 21. OPERATOR[] vracia REFERENCES k ITEMS daneho ARRAY. OPERATOR[] NEROBI kontrolu hranic ARRAY.
   !!! 22. METHOD at() vracia REFERENCES k ITEMS daneho ARRAY. METHOD array<TItem,N>.at() ROBI kontrolu hranic ARRAY, a v pripade zistenia chybneho pristupu generuje EXCEPTION [out_of_range].
   23. METHOD front() vracia REFERENCE na PRVY ITEM v ARRAY.
   24. METHOD back() vracia REFERENCE na POSLEDNY ITEM v ARRAY.
   25. METHOD data() vracia POINTER na interny C-ARRAY, ktory instancia ARRAY zapuzdruje.
   26. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM ARRAY.
   27. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM ARRAY.
   28. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM ARRAY.
   29. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM ARRAY.
   30. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM ARRAY.
   31. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM ARRAY.
   32. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM ARRAY.
   33. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM ARRAY.
   34. METHOD empty() vracia informaciu ci ARRAY je prazdne.
   35. METHOD size() vracia pocet ITEMS v ARRAY. Tato hodnota je konstantna a je rovna hodnote TEMPLATE PARAMETER 'N'.
   36. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do ARRAY mozne ulozit.
   37. METHOD fill() nastavuje hodnotu kazdeho ITEM na hodnotu definovanu PARAMETER tejto METHOD.
   !!! 38. METHOD swap() vymiena obsah dvoch instancii ARRAY vymenou kopirovanim VSETKYCH ITEMS ARRAY. To je ZASADNY ROZDIEL oproti implementaciam METHOD swap() pre ine CONTAINERS, ktore su implementovane tak, ze dochadza iba k vymene vnutornych FIELDS a nerobi sa kopirovanie ITEMS.
   !!! 39. FUNCTION swap() vymiena obsah dvoch instancii ARRAY kopirovanim VSETKYCH ITEMS ARRAY. To je ZASADNY ROZDIEL oproti implementaciam FUNCTION swap() pre ine CONTAINERS, ktore su implementovane tak, ze dochadza iba k vymene vnutornych FIELDS a nerobi sa kopirovanie ITEMS.
   40. FUNCTION get<X>() vracia REFERENCE na 'X'-ty ITEM daneho ARRAY.
!!! 5. Kedze CLASS [array<TItem,N>] NEMA EXPLICITNY CONSTRUCTOR ani OPERATOR=, jedinym sposobom ako inicializovat ARRAY je pouzit SYNTAX [{}].
!!! 6. CLASS [array<TItem,N>] ma INTERNY DATA FIELD odkazujuci na C-ARRAY PUBLIC, no C++ STANDARD NEDEFINUJE jeho NAME a tak jeho pouzitie NIE JE PORTABLE. Pre PORTABLE pristup k C-ARRAY je nutne pouzit METHOD array<TItem,N>::data().
!!!!! 7. METHOD array<TItem,N>.swap() na rozdiel od ostatnych CONTAINERS NEVYMIENA POINTER na INTERNAL DATA (v pripade ARRAY je to C-ARRAY), ale vykonava COPY VSETKYCH ITEMS. Je preto ZNACNE NEEFEKTIVNA.
!!!!! 8. CLASS [array<TItem,N>] ma definovany IMPLICITNY MOVE OPERATOR, ktory vykonava MOVE vsetkych ITEMS do ineho ARRAY.
9. CLASS [array<TItem,N>] umoznuje definovat aj ARRAYS s nulovou dlzkou.
!!! 10. CLASS [array<TItem,N>] GARANTUJE, ze ITEMS su ulozene VZDY v KONTINUALNOM BLOKU MEMORY.
!!! 11. CLASS [array<TItem,N>] generuje jedinu EXCEPTION [out_of_range] pri volani METHOD array<TItem,N>.at(). Ostatne METHODS EXCEPTIONS NEGENERUJU. Ak OPERATOR volany CLASS [array<TItem,N>] generuje EXCEPTION, tak je stav ARRAY NEDEFINOVANY.
!!!!! 12. CLASS [array<TItem,N>] definuje TUPLE INTERFACE, ktory umoznuje pristupovat k ARRAY pomocou nasledujucich TEMPLATE CLASSES a TEMPLATE METHODS.
   A. FUNCTION get<INDEX>() pre ARRAY vracia hodnotu ITEM s indexom 'INDEX'.
   B. CLASS [tuple_size<array<TItem,N>>] vracia pocet ITEMS v ARRAY.
   C. CLASS [tuple_element<INDEX,array<TItem,N>>] vracia TYPE ITEM s indexom 'INDEX', ktory je zhodny z ITEM TYPE daneho ARRAY.
13. CLASS [bitset<SIZE>] reprezentuje FIXED SIZE BIT SEQUENCE. Pre CLASS [bitset<SIZE>] platia nasledujuce fakty.
   A. BITSET reprezentuje FIXED SIZE BIT SEQUENCE.
   B. BITSET je definovany v LIBRARY <bitset>.
   C. TEMPLATE PARAMETER 'SIZE' urcuje velkost BIT SEQUENCE v BITS.
   D. BITSET uklada data na STACK a NIE na HEAP.
   E. BITSET umoznuje konvertovat BITS na STRINGS a INTEGERS.
   !!! F. Kedze k jednotlivym BITS v BITSET NIE JE mozne pristupovat pomocou POINTERS ani REFERENCES, pretoze tie su BYTE-ORIENTED, BITSET definuje PROXY CLASS [bitset<SIZE>::reference], ktora reprezentuje VIRTUALNU REFERENCE na BIT.
   G. C++ definuje CLASS [hash<bitset<SIZE>], ktora repreznetuje HASH VALUE danej BITSET.
14. CLASS [bitset<SIZE>] ma nasledujuce MEMBERS.
   1. MEMBER CLASS [bitset<SIZE>::reference] je PROXY CLASS, ktora reprezentuje REFERENCE na BIT.
   2. HELPER CLASS [hash<biset<SIZE>>] umoznuje ziskat HASH VALUE z BITSET.
   3. CONSTRUCTOR vytvara instanciu BITSET. BITSET je mozne vytvorit s INTEGER VALUES, alebo aj zo STRING, kde je mozne definovat aky CHARACTER reprezentuje TRUE a aka FALSE.
   4. OPERATOR== porovnava ci su 2 instancie BITSET rovne.
   5. OPERATOR!= porovnava ci su 2 instancie BITSET rozne.
   !!! 6. OPERATOR[] vracia hodnotu BIT pre zadany INDEX. NON-CONST OVERLOADED VERSION vracia instanciu CLASS [bitset<SIZE>::reference] pomocou ktorej je mozne menit hodnoty jednotlivych BITS.
   7. OPERATOR&= vykonava operaciu BIT AND a vysledok zapise do instancie BITSET pre ktoru je volany.
   8. OPERATOR|= vykonava operaciu BIT OR a vysledok zapise do instancie BITSET pre ktoru je volany.
   9. OPERATOR^= vykonava operaciu BIT XOR a vysledok zapise do instancie BITSET pre ktoru je volany.
   10. OPERATOR~ vykonava operaciu BIT NOT a vysledok zapise do instancie pre ktoru je volany.
   11. OPERATOR& vykonava operaciu BIT AND medzi 2 instanciami BITSET, pricom vysledny BITSET vracia ako RETURN VALUE.
   12. OPERATOR| vykonava operaciu BIT OR medzi 2 instanciami BITSET, pricom vysledny BITSET vracia ako RETURN VALUE.
   13. OPERATOR^ vykonava operaciu BIT XOR medzi 2 instanciami BITSET, pricom vysledny BITSET vracia ako RETURN VALUE.
   14. OPERATOR<< vykonava operaciu BIT SHIFT LEFT nad instanciou BITSET pre ktoru je volany. OPERATOR<< NEMODIFIKUJE povodny BITSET a vysledny BITSET vracia ako RETURN VALUE.
   15. OPERATOR<<= vykonava operaciu BIT SHIFT LEFT nad instanciou BITSET pre ktoru je volany. OPERATOR<<= MODIFIKUJE povodny BITSET a ako RETURN VALUE vracia REFERENCE na volany BITSET.
   16. OPERATOR>> vykonava operaciu BIT SHIFT RIGHT nad instanciou BITSET pre ktoru je volany. OPERATOR>> NEMODIFIKUJE povodny BITSET a vysledny BITSET vracia ako RETURN VALUE.
   17. OPERATOR>>= vykonava operaciu BIT SHIFT RIGHT nad instanciou BITSET pre ktoru je volany. OPERATOR>>= MODIFIKUJE povodny BITSET a ako RETURN VALUE vracia REFERENCE na volany BITSET.
   18. NON-MEMBER OPERATOR<< vykonava zapis BITSET do STREAM.
   19. NON-MEMBER OPERATOR>> vykonava citanie BITSET zo STREAM.
   !!! 20. METHOD test() vracia hodnotu BIT pre zadany INDEX. METHOD vykonava kontrolu ci nedoslo k prekroceniu hranic BITSET a ak je tato prekrocena, generuje EXCEPTION [out_of_range].
   21. METHOD all() vracia TRUE ak su VSETKY BITS nastavene na TRUE. Inak vracia FALSE.
   22. METHOD any() vracia TRUE ak je aspon 1 BIT nastaveny na TRUE. Inak vracia FALSE.
   23. METHOD none() vracia TRUE ak ziaden BIT NIE JE nastaveny na TRUE. Inak vracia FALSE.
   24. METHOD count() vracia pocet BITS, ktore su nastavene na TRUE.
   25. METHOD size() vracia pocet BITS v BITSET. Hodnota je identicka s hodnotu TEMPLATE PARAMETER 'SIZE'.
   26. METHOD set() nastavuje hodnotu BIT so zadanym INDEXOM na TRUE. OVERLOADED VERSION nastavuje VSETKY BITS na TRUE.
   27. METHOD reset() nastavuje hodnotu BIT so zadanym INDEXOM na FALSE. OVERLOADED VERSION nastavuje VSETKY BITS na FALSE.
   28. METHOD flip() bitovo obracia hodnotu BIT so zadanym INDEXOM. OVERLOADED VERSION obracia hodnotu VSETKYCH BITS v BITSET.
   29. METHOD to_string() vracia STRING, kde za kazdu hodnotu FALSE zapise CHARACTER zadany ako 1. PARAMETER METHOD a za kazdu hodnotu TRUE zapise CHARACTER zadany ako 2. PARAMETER METHOD.
   30. METHOD to_ulong() konvertuje BITSET na UNSIGNED LONG hodnotu. V pripade, ze BITSET je prilis dlhy a nie je ho mozne reprezentovat ako UNSIGNED LONG METHOD generuje EXCEPTION [overflow_error].
   31. METHOD to_uulong() konvertuje BITSET na UNSIGNED LONG LONG hodnotu. V pripade, ze BITSET je prilis dlhy a nie je ho mozne reprezentovat ako UNSIGNED LONG LONG METHOD generuje EXCEPTION [overflow_error].
15. CLASS [bitset<SIZE>::reference] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [bitset<SIZE>::reference].
   B. DESTRUCTOR uvolnuje instanciu CLASS [bitset<SIZE>::reference].
   C. OPERATOR= priradzuje jednu instanciu CLASS [bitset<SIZE>::reference] do druhej.
   D. OPERATOR BOOL() vracia hodnotu BIT na ktoru odkazuje instancia CLASS [bitset<SIZE>::reference].
   E. OPERATOR~ vracia NEGOVANU hodnotu BIT na ktoru odkazuje instancia CLASS [bitset<SIZE>::reference].
   F. METHOD flip() obracia hodnotu BIT na ktoru odkazuje instancia CLASS [bitset<SIZE>::reference].
16. CLASS [vector<bool,TAllocator>] je TEMPLATE SPECIALIZATION CLASS [vector<TItem,TAllocator>], ktora nasledujuce vlastnosti.
   A. CLASS [vector<bool,TAllocator>] optimalizovane uklada BIT VALUES do BYTES, kde do kazdeho BYTE uklada 8 BITS.
   !!! B. CLASS [vector<bool,TAllocator>] ma ITERATORS implementovane ako CUSTOM CLASS, pretoze POINTERS ako ITERATORS, ktore spravidla pouziva CLASS [vector<TItem,TAllocator>] NIE JE na urovni BITS mozne pouzit. To vedie k SERII PROBLEMOV pri praci s CLASS [vector<bool,TAllocator>].
   !!! C. CLASS [vector<bool,TAllocator>] NEMA TYPE [vector<bool>::reference] definovany ako skutocnu LVALUE REFERENCE VALUE, pretoze C++ NEUMOZNUJE definovat REFERENCES na BITS.
   !!! D. CLASS [vector<bool,TAllocator>] NEMA RANDOM ACCESS ITERATOR.
   E. CLASS [vector<bool,TAllocator>] ma mnozinu METHODS, ktorymi je mozne pracovat s jednotlivymi BITS.
   !!!!! F. CLASS [vector<bool,TAllocator>] NEMUSI ukladat ITEMS v KONTINUALNOM BLOKU MEMORY.
17. CLASS [vector<bool,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu VECTOR. OVERLOADED verzia umoznuje alokovat zadany pocet ITEMS, pricom pre tieto ITEMS je volany DEFAULT CONSTRUCTOR.
   2. DESTRUCTOR uvolnuje instanciu VECTOR ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [value_type] urcuje TYPE pre ITEMS ulozene vo VECTOR. V pripade CLASS [vector<bool,TAllocator>] je to TYPE [bool].
   4. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   5. TYPE [size_type] je IMPLEMENTATION DEFINED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je IMPLEMENTATION DEFINED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   !!! 7. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene vo VECTOR. Pre CLASS [vector<bool,TAllocator>] je definovany ako PROXY CLASS [std::vector<bool>::reference], ktora ma definovany OPERATOR BOOL() a METHOD std::vector<bool>::reference.flip() na obratenie vyznamu BITU.
   !!! 8. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene vo VECTOR. Pre CLASS [vector<bool,TAllocator>] je definovany TYPE [bool].
   9. TYPE [pointer] urcuje IMPLEMENTATION DEFINED POINTER TYPE pre ITEMS ulozene vo VECTOR.
   10. TYPE [const_pointer] urcuje IMPLEMENTATION DEFINED CONST POINTER TYPE pre ITEMS ulozene vo VECTOR.
   11. TYPE [iterator] urcuje IMPLEMENTATION DEFINED TYPE pre ITERATOR daneho VECTOR.
   12. TYPE [const_iterator] urcuje IMPLEMENTATION DEFINED TYPE pre CONST ITERATOR daneho VECTOR.
   13. TYPE [reverse_iterator] urcuje IMPLEMENTATION DEFINED TYPE pre REVERSE ITERATOR daneho VECTOR.
   14. TYPE [const_reverse_iterator] urcuje IMPLEMENTATION DEFINED TYPE pre CONST REVERSE ITERATOR daneho VECTOR.
   15. OPERATOR= priradzuje do VECTOR ITEMS ineho VECTOR. VECTOR obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   16. OPERATOR== zistuje ci dve instancie VECTOR su lexikograficky rovne.
   17. OPERATOR!= zistuje ci dve instancie VECTOR su lexikograficky rozne.
   18. OPERATOR< zistuje ci 1. VECTOR je lexikograficky mensi ako 2. VECTOR.
   19. OPERATOR<= zistuje ci 1. VECTOR je lexikograficky mensi, alebo rovny ako 2. VECTOR.
   20. OPERATOR> zistuje ci 1. VECTOR je lexikograficky vacsi ako 2. VECTOR.
   21. OPERATOR>= zistuje ci 1. VECTOR je lexikograficky vacsi, alebo rovny ako 2. VECTOR.
   !!! 22. OPERATOR[] vracia REFERENCES k ITEMS daneho VECTOR. OPERATOR[] NEROBI kontrolu hranic VECTOR.
   !!! 23. METHOD at() vracia REFERENCES k ITEMS daneho VECTOR. METHOD vector<bool,TAllocator>.at() ROBI kontrolu hranic VECTOR, a v pripade zistenia chybneho pristupu generuje EXCEPTION [out_of_range].
   24. METHOD assign() priradzuje do VECTOR ITEMS ineho CONTAINER, ktory je definovany pomocou paru ITERATORS. OVERLOADED VERSION umoznuje priradit 'N' krat kopiu zadaneho ITEMS, alebo ITEMS z INITIALIZER LIST.
   25. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS daneho VECTOR.
   26. METHOD front() vracia REFERENCE na PRVY ITEM vo VECTOR.
   27. METHOD back() vracia REFERENCE na POSLEDNY ITEM vo VECTOR.
   28. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM VECTOR.
   29. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM VECTOR.
   30. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM VECTOR.
   31. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM VECTOR.
   32. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM VECTOR.
   33. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM VECTOR.
   34. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM VECTOR.
   35. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM VECTOR.
   36. METHOD empty() vracia informaciu ci VECTOR je prazdny.
   37. METHOD size() vracia pocet ITEMS vo VECTOR.
   38. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do VECTOR mozne ulozit.
   39. METHOD reserve() alokuje INTERNY BUFFER VECTOR na zadanu CAPACITY. Ak zadana velkost je mensia, alebo rovna aktualnemu poctu ITEMS vo VECTOR, METHOD nerobi nic.
   40. METHOD capacity() vracia CAPACITY urcujucu pocet ITEMS na ktory je alokovany INTERNY BUFFER VECTOR.
   41. METHOD clear() odstranuje vsetky ITEMS z VECTOR. CAPACITY METHOD NEMENI.
   42. METHOD insert() pridava 1-N ITEMS PRED stanovenu poziciu vo VECTOR. Pozicie sa urcuju pomocou ITERATORS.
   43. METHOD emplace() pridava ITEM PRED stanovenu poziciu vo VECTOR pomocou PLACEMENT NEW. PARAMETERS METHOD vector<bool,TAllocator>.emplace() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do VECTOR.
   44. METHOD erase() odstranuje 1-N ITEMS na stanovenych poziciach vo VECTOR. Pozicie sa urcuju pomocou ITERATORS.
   45. METHOD push_back() pridava ITEM na koniec VECTOR.
   46. METHOD emplace_back() pridava ITEM na koniec VECTOR pomocou PLACEMENT NEW. PARAMETERS METHOD emplace_back() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do VECTOR.
   47. METHOD pop_back() odstranuje 1 ITEM z konca VECTOR.
   48. METHOD resize() meni pocet ITEMS vo VECTOR na pocet stanoveny PARAMETER METHOD vector<bool,TAllocator>.resize(). V pripade, ze stanoveny pocet je MENSI ako pocet ITEMS vo VECTOR, dochadza k ostraneniu ITEMS z VECTOR. Ak je stanoveny pocet VACSI ako pocet ITEMS vo VECTOR, dochadza k pridavaniu novych ITEMS do VECTOR, pricom OVERLOADED verzia METHOD vector<bool,TAllocator>.resize() umoznuje definovat ITEM, ktoreho kopia za priradi za nove ITEMS.
   49. METHOD swap() vymiena obsah dvoch instancii VECTOR vymenou ich vnutornych FIELDS.
   50. METHOD flip() obracia hodnotu kazdeho BIT vo VECTOR.
   51. STATIC METHOD swap() vymiena obsah dvoch ITEMS daneho VECTOR.
   52. FUNCTION swap() vymiena obsah dvoch instancii VECTOR vymenou ich vnutornych FIELDS.
18. CLASS [std::vector<bool>::reference] predstavuje PROXY CLASS implementujucu funkcnost REFERENCE nad ITEMS CLASS [vector<bool,TAllocator>].
   A. CONSTRUCTOR vytvara instanciu CLASS [std::vector<bool>::reference].
   B. DESTRUCTOR uvolnuje instanciu CLASS [std::vector<bool>::reference].
   C. OPERATOR= priradzuje do ITEM CLASS [vector<bool,TAllocator>] na ktoru REFERENCE referuje novu BIT hodnotu daneho ITEM.
   D. OPERATOR BOOL vracia hodnotu ITEM CLASS [vector<bool,TAllocator>] na ktoru REFERENCE referuje.
   E. METHOD flip() obracia hodnotu ITEM CLASS [vector<bool,TAllocator>] na ktoru REFERENCE referuje.
20. STRUCTURE [pair<T1,T2>] reprezentuje PAIR. Ma nasledujuce MEMBERS.
   A. FIELD [first] obsahuje 1. VALUE.
   B. FIELD [second] obsahuje 2. VALUE.
   C. FIELD [first_type] obsahuje TYPE 1. VALUE.
   D. FIELD [second_type] obsahuje TYPE 2. VALUE.
   E. CONSTRUCTOR umoznuje aj standardne CONVERSIONS.
   F. OPERATOR= umoznuje priradenie jedneho PAIR do druheho. Ma aj MOVE SEMANTICS a umoznuje standardne CONVERSIONS.
   G. OPERATOR== porovnava ci su 2 PAIRS rovne.
   H. OPERATOR!= porovnava ci su 2 PAIRS rozne.
   I. OPERATOR< porovnava ci su 1. PAIR je mensi ako 2. PAIR. Porovnavaju sa FIELDS [first] a ak su rovnake, tak aj FIELDS [second].
   J. OPERATOR<= porovnava ci su 1. PAIR je mensi, alebo rovny ako 2. PAIR. Porovnavaju sa FIELDS [first] a ak su rovnake, tak aj FIELDS [second].
   K. OPERATOR> porovnava ci su 1. PAIR je vacsi ako 2. PAIR. Porovnavaju sa FIELDS [first] a ak su rovnake, tak aj FIELDS [second].
   L. OPERATOR>= porovnava ci su 1. PAIR je vacsi, alebo rovny ako 2. PAIR. Porovnavaju sa FIELDS [first] a ak su rovnake, tak aj FIELDS [second].
   M. METHOD swap() vymiena hodnoty oboch FIELDS medzi 2 PAIRS.
21. FUNCTION get<INDEX>() pre PAIR vracia hodnotu FIELD s indexom 'INDEX'.
22. CLASS [tuple_size<pair<T1,T2>>] vracia pocet ITEMS v PAIR, ktory je vzdy rovny hodnode 2.
23. CLASS [tuple_element<INDEX,pair<T1,T2>>] vracia TYPE FIELD s indexom 'INDEX'.
!!! 24. STRUCTURE [pair<T1,T2>] ma specialny CONSTRUCTOR, ktory ako 1. PARAMETER prijima TYPE [piecewise_construct] a ako dalsie 2 PARAMETERS prijima dvojicu CLASS [tuple<T...>]. CONSTRUCTOR pre OBE TUPLES ROZBALI ich na FIELDS a pre tieto vola VARIADIC CONSTRUCTORS pre TYPE PARAMETER 'T1' a TYPE PARAMETER 'T2'.
25. FUNCTION make_pair() umoznuje vytvorit PAIR bez toho aby sa EXPLICITNE definovali jeho TYPES. TYPES ci COMPILER odvodi z PARAMETERS FUNCTION make_pair().
!!! 26. FUNCTION make_pair() spolu s FUNCTIONS ref() ci cref() umoznuju urcit ci COMPILER ma pre TYPE PARAMETER daneho PAIR generovat REFERENCES na VALUES namiesto VALUES.
!!!!! 27. STRUCTURE [pair<T1,T2>] moze v TYPE PARAMETERS 'T1' a 'T2' obsahovat aj REFERENCES.
28. VARIADIC TEMPLATE CLASS [tuple<T...>] reprezentuje TUPLE. Ma nasledujuce MEMBERS.
   A. CONSTRUCTOR umoznuje aj standardne CONVERSIONS. CLASS ma aj EXPLICIT CONSTRUCTOR, ktory moze preberat lubovolny pocet VALUES. Tento CONSTRUCTOR je mozne vyuzit pri vytvarani TUPLES cez INITIALIZER LISTS.
   B. OPERATOR= umoznuje priradenie jedneho TUPLE do druheho. Ma aj MOVE SEMANTICS a umoznuje standardne CONVERSIONS.
   C. OPERATOR== porovnava ci su 2 TUPLES rovne.
   D. OPERATOR!= porovnava ci su 2 TUPLES rozne.
   E. OPERATOR< porovnava ci su 1. TUPLE je mensi ako 2. TUPLE. FIELDS sa porovnavaju v poradi zlava doprava.
   F. OPERATOR<= porovnava ci su 1. TUPLE je mensi, alebo rovny ako 2. TUPLE. FIELDS sa porovnavaju v poradi zlava doprava.
   G. OPERATOR> porovnava ci su 1. TUPLE je vacsi ako 2. TUPLE. FIELDS sa porovnavaju v poradi zlava doprava.
   H. OPERATOR>= porovnava ci su 1. TUPLE je vacsi, alebo rovny ako 2. TUPLE. FIELDS sa porovnavaju v poradi zlava doprava.
   I. METHOD swap() vymiena hodnoty vsetkych FIELDS medzi 2 TUPLES.
29. FUNCTION get<INDEX>() pre TUPLE vracia hodnotu FIELD s indexom 'INDEX'.
30. CLASS [tuple_size<tuple<T...>>] vracia pocet ITEMS v TUPLE.
31. CLASS [tuple_element<INDEX,tuple<T...>>] vracia TYPE FIELD s indexom 'INDEX'.
32. FUNCTION make_tuple() umoznuje vytvorit TUPLE bez toho aby sa EXPLICITNE definovali jeho TYPES. TYPES ci COMPILER odvodi z PARAMETERS FUNCTION make_tuple().
!!! 33. FUNCTION make_tuple() spolu s FUNCTIONS ref() ci cref() umoznuju urcit ci COMPILER ma pre TYPE PARAMETERS daneho TUPLE generovat REFERENCES na VALUES namiesto VALUES.
!!!!! 34. CLASS [tuple<T...>] moze v TYPE PARAMETERS mat aj REFERENCES.
!!! 35. FUNCTION tie() vytvara instanciu CLASS [tuple<T...>], kde zo VSETKYCH TYPE PARAMETERS spravi REFERENCES. Vdaka tomu je mozne modifikovat povodne hodnoty na ktore sa TUPLE FIELDS referuju.
36. FUNCTION tuple_cat() vytvara instanciu TUPLE z VIACERYCH TUPLES, ktore su zadane ako PARAMETERS, pricom vytvoreny TUPLE ma vsetky FIELDS zo vsetkych TUPLES zadanych ako PARAMETERS.
37. Instanciu CLASS [pair<T1,T2>] je mozne priradit do instancie CLASS [tuple<T...>], ktora ma 2 FIELDS.
!!! 38. Do instancie CLASS [tuple<T...>] je mozne priradit iny TUPLE s ROZLICNYMI TYPES a to vtedy, ak kazdy jeden FIELD je mozne konvertovat.
39. C++ podporuje 2 typy SMART POINTERS.
   A. SHARED SMART POINTERS realizuju funkcionalitu REFERENCE COUNTING a umoznuju, aby POINTER, ktory obsahuju bol pouzity viackrat v rozlicnych CONTEXTS. OBJECT, ktory SHARED SMART POINTER obsahuje je ODSTRANENY z MEMORY, ak je POSLEDNA INSTANCIA SHARED SMART POINTER uvolnena. SHARED SMART POINTER je reprezentovany CLASS [shared_ptr<T>].
   B. UNIQUE SMART POINTERS obaluju POINTER, ktory sa pouziva iba v 1 CONTEXT. Po uvolneni instancie UNIQUE SMART POINTER je uvolneny aj OBJECT na ktory sa UNIQUE SMART POINTER referuje. UNIQUE SMART POINTER je reprezentovany CLASS [unique_ptr<T>].
40. Pre UNIQUE SMART POINTERS platia nasledujuce fakty.
   A. UNIQUE SMART POINTER je reprezentovany CLASS [unique_ptr<T>].
   !!!!! B. CLASS [unique_ptr<T>] EXKLUZIVNE VLASTNI dany OBJECT, co znamena, ze vo svojom DESTRUCTOR UVOLNUJE OBJECT z MEMORY.
   C. CLASS [unique_ptr<T>] umoznuje definovat CUSTOM DELETE FUNCTION, ktora sa zavola pri uvolnovani OBJECT na ktory instancia CLASS [unique_ptr<T>] referovala.
   !!! D. Standardne CLASS [unique_ptr<T>] predpoklada, ze OBJECT bol alokovany pomocou OPERATOR NEW a bez definovania CUSTOM DELETE FUNCTION sa pre OBJECT vola OPERATOR DELETE.
   !!!!! E. CLASS [unique_ptr<T>] ma definovanu TEMPLATE SPECIALIZATION pre ARRAYS, ktora namiesto standardneho OPERATOR DELETE pouziva na uvolnovanie OBJECT, ktory instancia CLASS [unique_ptr<T>] obaluje OPERATOR DELETE[].
41. CLASS [unique_ptr<T>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [unique_ptr<T>] pricom do svojho FIELD ulozi POINTER na OBJECT vlozeny ako PARAMETER.
   B. DESTRUCTOR UVOLNUJE OBJECT na ktory referoval POINTER ulozeny ako FIELD v instancii CLASS [unique_ptr<T>]. Standardne DESTRUCTOR vola OPERATOR DELETE, ale v pripade, ze v CONSTRUCTOR bola zadana aj CUSTOM DELETE FUNCTION, zavola sa tato namiesto OPERATOR DELETE.
   !!! C. OPERATOR= umoznuje priradit instanciu jednej CLASS [unique_ptr<T>] do inej. OPERATOR= funguje IBA pre RVALUES. Priradzovanie LVALUES NIE JE PODPOROVANE a COMPILER pri pokuse priradit LVALUE hodi ERROR. OPERATOR= NEUMOZNUJE priradit PRIAMO POINTER na OBJECT do instancie CLASS [unique_ptr<T>]. Na to je potrebne pouzit METHOD unique_ptr<T>.reset().
   D. OPERATOR* vykonava POINTER DEREFERENCING. Chova sa ako OPERATOR* pre STANDARDNE POINTERS.
   E. OPERATOR-> vykonava POINTER DEREFERENCING. Chova sa ako OPERATOR-> pre STANDARDNE POINTERS.
   E. OPERATOR== porovnava ci 2 instancie CLASS [unique_ptr<T>] referuju na ten isty OBJECT.
   F. OPERATOR!= porovnava ci 2 instancie CLASS [unique_ptr<T>] referuju na ten rozny OBJECT.
   G. OPERATOR< porovnava ci 1. instancia CLASS [unique_ptr<T>] je MENSIA ako druha instancia CLASS [unique_ptr<T>].
   H. OPERATOR<= porovnava ci 1. instancia CLASS [unique_ptr<T>] je MENSIA, alebo ROVNA ako druha instancia CLASS [unique_ptr<T>].
   I. OPERATOR> porovnava ci 1. instancia CLASS [unique_ptr<T>] je VACSIA ako druha instancia CLASS [unique_ptr<T>].
   J. OPERATOR>= porovnava ci 1. instancia CLASS [unique_ptr<T>] je VACSIA, alebo ROVNA ako druha instancia CLASS [unique_ptr<T>].
   K. OPERATOR BOOL vracia hodnotu TRUE, ak instancia CLASS [unique_ptr<T>] referuje na OBJECT, alebo FALSE, ak instancia CLASS [unique_ptr<T>] nereferuje na ziadny OBJECT.
   !!! L. OPERATOR[] je definovany iba pre ARRAY verzie CLASS [unique_ptr<T>] a umoznuje indexovany pristup k ARRAY na ktore referuje instancia CLASS [unique_ptr<T>].
   !!!!! M. METHOD unique_ptr<T>.reset() UVOLNUJE umoznuje OBJECT na ktory referovala instancia CLASS [unique_ptr<T>]. METHOD vola pre dany OBJECT bud OPERATOR DELETE, alebo ak je definovana, tak CUSTOM DELETE FUNCTION.
   !!! N. METHOD unique_ptr<T>.release() rusi REFEROVANIE instancie CLASS [unique_ptr<T>] na OBJECT. OBJECT sa NA ROZDIEL od FUNCTION unique_ptr<T>.reset() NEUVOLNUJE a je ho NUTNE UVOLNIT EXPLICITNE. FUNCTION ako RETURN VALUE vracia POINTER na OBJECT na ktory instancia CLASS [unique_ptr<T>] referovala.
   O. METHOD unique_ptr<T>.swap() umoznuje vzajomne si vymenit POINTERS na OBJECTS na ktore referuju 2 instancie CLASS [unique_ptr<T>].
   P. METHOD unique_ptr<T>.get_deleter() vracia CUSTOM DELETE FUNCTION, ktora bola priradena danej instancii CLASS [unique_ptr<T>].
   !!!!! Q. METHOD unique_ptr<T>.get() vracia POINTER na OBJECT na ktory instancia CLASS [unique_ptr<T>] referuje.
!!! 42. FUNCTION make_unique() vytvara instanciu CLASS [unique_ptr<T>].
!!!!! 43. CLASS [unique_ptr<T>] podporuje IBA MOVE CONSTRUCTOR a OPERATOR= pre MOVE SEMANTICS. COPY CONSTRUCTOR, ani OPERATOR= pre COPY SEMANTICS NIE JE PODPOROVANA, aby sa zabranilo situaciam, kedy by viac ako 1 instancia CLASS [unique_ptr<T>] referovala na TEN ISTY OBJECT, co by viedlo k VIACNASOBNEMU volaniu DESTRUCTOR pre tento OBJECT a tym padom aj k MEMORY ACCESS ERROR.
!!!!! 44. NEEXISTENCIA OPERATOR= pre COPY SEMANTICS, ako aj NEEXISTENCIA COPY CONSTRUCTOR znamena, ze instanciu CLASS [unique_ptr<T>] NIE JE MOZNE PRENASAT ako PARAMETERS FUNCTIONS inak ako pouzitim MOVE SEMANTICS, ktora sposobi, ze povodna instancia CLASS [unique_ptr<T>] nastavi svoju hodnotu na NULL a referovany OBJECT uvolni az instancia CLASS [unique_ptr<T>] pouzita ako ARGUMENT volanej FUNCTION. DESTRUCTOR daneho OBJECT sa potom zavola na konci volanej FUNCTION.
!!!!! 45. KLUCOVOU VYHODOU CLASS [unique_ptr<T>] je, ze umoznuje BEZPECNYM SPOSOBOM, aby FUNCTIONS vracali alokovany OBJECT, ktory same alokovali. Ako RETURN VALUE sa pouzije [unique_ptr<T>], ktory sposobi, ze OBJECT ALOKOVANY vo VOLANEJ FUNCTION bude VZDY UVOLNENY.
!!! 46. CLASS [unique_ptr<T>] je mozne vyuzit v CLASSES namiesto POINTERS, ak tieto CLASSES alokuju vo svojich CONSTRUCTORS OBJECTS, ktore je nutne v DESTRUCTORS uvolnit. Vdaka pouzitiu CLASS [unique_ptr<T>] su tieto OBJECTS uvolnovane AUTOMATICKY.
!!!!! 47. OBROVSKOU VYHODOU pouzitia CLASS [unique_ptr<T>] ako CLASS FIELDS je, ze ak v CONSTRUCTOR pri inicializacii tychto CLASS FIELDS typu [unique_ptr<T>] dojde k hodeniu EXCEPTION, potom C++ AUTOMATICKY zavola DESTRUCTORS pre TIE FIELDS, ktore boli do chvile hodenia EXCEPTION USPESNE VYTVORENE. Tym je mozne predist neprijemnym MEMORY LEAKS.
!!! 48. C++ poskytuje TEMPLATE SPECIALIZATION CLASS [unique_ptr<T>] pre ARRAYS. Pre tuto SPECIALIZATION platia nasledujuce fakty.
   A. Pri deklaracii instancie CLASS [unique_ptr<T>] je nutne pouzit []. To znaci, ze je potrebne definovat instanciu pomocou CODE [unique_ptr<T[]>].
   B. SPECIALIZATION pouziva OPERATOR DELETE[] namiesto OPERATOR DELETE.
   !!! C. SPECIALIZATION NEDEFINUJE OPERATOR* a OPERATOR->.
   D. SPECIALIZATION definuje OPERATOR[] pomocou ktoreho je mozne pristupovat k ITEMS daneho ARRAY. Tento OPERATOR vsak NEKONTROLUJE prekrocenie medzi ARRAY. Ak k nemu dojde, chovanie je UNDEFINED.
49. V pripade, ze uvolnenie OBJECT, ktory je obaleny instanciou CLASS [unique_ptr<T>] potrebuje pri svojom uvolneni vykonat nejaku dodatocnu CUSTOM CINNOST, ktoru nie je vhodne umiestnit do DESTRUCTOR daneho OBJECT, je mozne definovat CUSTOM DELETE FUNCTION. Pre CUSTOM DELETE FUNCTION platia nasledujuce pravidla.
   A. TYPE CUSTOM DELETE FUNCTION sa MUSI EXPLICITNE definovat ako 2. TYPE PARAMETER CLASS [unique_ptr<T>].
   !!!!! B. Kedze volanie CUSTOM DELETE FUNCTION NAHRADZUJE volanie standardnych OPERATOR DELETE a OPERATOR DELETE[] MUSI CUSTOM DELETE FUNCTION jeden z tychto OPERATORS ZVOLAT, aby doslo k uvolneniu OBJECT, ktory obaluje instancia CLASS [unique_ptr<T>].
   !!! C. CUSTOM DELETE FUNCTION NESMIE hodit EXCEPTION, inak je cinnost CLASS [unique_ptr<T>] UNDEFINED.
   D. CUSTOM DELETE FUNCTION MUSI mat ako PARAMETER POINTER, ktory instancia CLASS [unique_ptr<T>] obaluje.
   !!! E. Ako CUSTOM DELETE FUNCTION je VYHODNEJSIE pouzivat FUNCTION OBJECT, alebo LAMBDA EXPRESSION namiesto klasickych FUNCTIONS, pretoze tie dokaze C++ lepsie optimalizovat.
50. Pre SHARED SMART POINTERS platia nasledujuce fakty.
   A. SHARED SMART POINTER je reprezentovany CLASS [shared_ptr<T>].
   !!!!! B. CLASS [shared_ptr<T>] NEVLASTNI exkluzivne dany OBJECT, ale umoznuje, aby OBJECT na ktory POINTER referuje bol SHARED medzi VIACERYMI INSTANCIAMI CLASS [shared_ptr<T>] a bol odstraneny, az ked sa uvolni z MEMORY POSLEDNA INSTANCIA CLASS [shared_ptr<T>], ktora referuje na dany OBJECT.
   !!! C. CLASS [shared_ptr<T>] teda reprezentuje semantiku REFERENCE COUNTING ako COM OBJECTS, pricom ak COUNTER klesne na 0, tak je OBJECT na ktory instancie CLASS [shared_ptr<T>] referovali uvolneny z MEMORY.
   D. CLASS [shared_ptr<T>] umoznuje definovat CUSTOM DELETE FUNCTION, ktora sa zavola pri uvolnovani OBJECT na ktory instancie CLASS [shared_ptr<T>] referovali z MEMORY.
   !!! E. Standardne CLASS [shared_ptr<T>] predpoklada, ze OBJECT bol alokovany pomocou OPERATOR NEW a bez definovania CUSTOM DELETE FUNCTION sa pre OBJECT vola OPERATOR DELETE.
   !!!!! F. Ak CLASS [shared_ptr<T>] obsahuje ARRAY alokovany pomocou OPERATOR NEW[], tak je NEVYHNUTNE definovat CUSTOM DELETE FUNCTION, ktora namiesto standardneho OPERATOR DELETE pouzije OPERATOR DELETE[].
51. CLASS [shared_ptr<T>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [shared_ptr<T>], inkrementuje REFERENCE COUNTER a priradzuje do nej POINTER na OBJECT. CONSTRUCTOR umoznuje zadat aj CUSTOM DELETE FUNCTION, ktora sa bude volat NAMIESTO OPERATOR DELETE, ked REFERENCE COUNTER klesne na hondotu 0.
   B. DESTRUCTOR dekrementuje REFERENCE COUNTER a uvolnuje instanciu CLASS [shared_ptr<T>]. Ak hodnota REFERENCE COUNTER klesne na 0, tak DESTRUCTOR vola bud standardny OPERATOR DELETE, alebo ak je zadefinovana na CUSTOM DELETE FUNCTION, ktora ma za ulohu odstranit OBJECT z MEMORY.
   C. OPERATOR= umoznuje priradit instanciu jednej CLASS [shared_ptr<T>] do inej. OPERATOR= NEUMOZNUJE priradit PRIAMO POINTER na OBJECT do instancie CLASS [shared_ptr<T>]. Na to je potrebne pouzit METHOD shared_ptr<T>.reset().
   D. OPERATOR* vykonava POINTER DEREFERENCING. Chova sa ako OPERATOR* pre STANDARDNE POINTERS.
   E. OPERATOR-> vykonava POINTER DEREFERENCING. Chova sa ako OPERATOR-> pre STANDARDNE POINTERS.
   E. OPERATOR== porovnava ci 2 instancie CLASS [shared_ptr<T>] referuju na ten isty OBJECT.
   F. OPERATOR!= porovnava ci 2 instancie CLASS [shared_ptr<T>] referuju na ten rozny OBJECT.
   G. OPERATOR< porovnava ci 1. instancia CLASS [shared_ptr<T>] je MENSIA ako druha instancia CLASS [shared_ptr<T>].
   H. OPERATOR<= porovnava ci 1. instancia CLASS [shared_ptr<T>] je MENSIA, alebo ROVNA ako druha instancia CLASS [shared_ptr<T>].
   I. OPERATOR> porovnava ci 1. instancia CLASS [shared_ptr<T>] je VACSIA ako druha instancia CLASS [shared_ptr<T>].
   J. OPERATOR>= porovnava ci 1. instancia CLASS [shared_ptr<T>] je VACSIA, alebo ROVNA ako druha instancia CLASS [shared_ptr<T>].
   K. OPERATOR<< zapise hodnotu POINTER do OUTPUT STREAM.
   L. OPERATOR BOOL vracia hodnotu TRUE, ak instancia CLASS [shared_ptr<T>] referuje na OBJECT, alebo FALSE, ak instancia CLASS [shared_ptr<T>] nereferuje na ziadny OBJECT.
   M. METHOD shared_ptr<T>.reset() umoznuje zrusit referovanie instancie CLASS [shared_ptr<T>] na OBJECT.
   N. METHOD shared_ptr<T>.swap() umoznuje vzajomne si vymenit POINTERS na OBJECTS na ktore referuju 2 instancie CLASS [shared_ptr<T>].
   !!! O. METHOD shared_ptr<T>.get() vracia POINTER OBJECT, ktory obsahuje instancia CLASS [shared_ptr<T>].
   !!! P. METHOD shared_ptr<T>.use_count() vracia aktualnu hodnotu REFERENCE COUNTER.
   Q. METHOD shared_ptr<T>.unique() vracia TRUE, ak REFERENCE COUNTER obsahuje hodnotu 1, inak vracia FALSE.
   R. METHOD shared_ptr<T>.owner_before() vracia informacia ci jedna instancia CLASS [shared_ptr<T>] sa nachadza pred inou v IMPLEMENTATION DEFINED ORDER.
52. FUNCTION get_deleter() vracia CUSTOM DELETE FUNCTION, ktora bola priradena danej instancii CLASS [shared_ptr<T>].
!!! 53. FUNCTION make_shared() vytvara instanciu CLASS [shared_ptr<T>]. FUNCTION je EFEKTIVNEJSIM sposobom vytvarania SHARED SMART POINTERS, pretoze ALOKACIA MEMORY sa vykonava IBA RAZ, kde MEMORY alokovana na HEAP obsahuje okrem samotnej instancie OBJECT aj REFERENCE COUNTER, ktory pocitat pocet instancii CLASS [shared_ptr<T>].
54. FUNCTION allocate_shared() je analogiou FUNCTION make_shared(), ktora vsak ako 1. PARAMETER prijima ALLOCATOR OBJECT.
55. C++ obsahuje nasledujuce konverzne TEMPLATE FUNCTIONS, ktore umoznuju aplikovat konverzne OPERATORS na instancie CLASS [shared_ptr<T>].
   A. FUNCTION dynamic_pointer_cast<T1,T2>() aplikuje OPERATOR [dynamic_cast<T>()] na instanciu CLASS [shared_ptr<T2>], pricom vracia instanciu CLASS [shared_ptr<T1>].
   B. FUNCTION static_pointer_cast<T1,T2>() aplikuje OPERATOR [static_cast<T>()] na instanciu CLASS [shared_ptr<T2>], pricom vracia instanciu CLASS [shared_ptr<T1>].
   C. FUNCTION const_pointer_cast<T1,T2>() aplikuje OPERATOR [const_cast<T>()] na instanciu CLASS [shared_ptr<T2>], pricom vracia instanciu CLASS [shared_ptr<T1>].
!!!!! 56. Pri alokacii ARRAYS pomocou CLASS [shared_ptr<T>] je NEVYHNUTNE definovat CUSTOM DELETE FUNCTION v ktorej je NUTNE zavolat OPERATOR DELETE[].
!!! 57. CLASS [shared_ptr<T>] NIE JE mozne pouzit, ak TYPE PARAMETER 'T' je ARRAY. Pre takyto CODE hodi COMPILER ERROR.
!!!!! 58. CUSTOM DELETE FUNCTION NESMIE hodit EXCEPTION, inak je chovanie CLASS [shared_ptr<T>] UNDEFINED.
!!!!! 59. Nevyhodou CLASS [shared_ptr<T>] je v tom, ze v pripade CYCLIC REFERENCES NEDOJDE k uvolnenie OBJECTS, pretoze 2 instancie CLASS [shared_ptr<T>] si vzajomne budu drzat COUNTER na hodnote 1 a tym padom ich DESTRUCTOR NEUVOLNI. Riesenim je pouzitie CLASS [weak_ptr<T>].
60. CLASS [weak_ptr<T>] reprezentuje SMART POINTER, ktory je previazany s CLASS [shared_ptr<T>]. Ma nasledujuce vlastnosti.
   A. Instancia CLASS [weak_ptr<T>] NEVLASTNI OBJECT na ktory referuje. To znaci, ze DESTRUCTOR NIKDY NEUVOLNUJE referovany OBJECT.
   B. Instanciu CLASS [weak_ptr<T>] je mozne vytvorit IBA z instancie CLASS [shared_ptr<T>].
   !!!!! C. CLASS [weak_ptr<T>] NEMA pretazeny OPERATOR* a OPERATOR->. Preto ak sa ma OBJECT na ktory instancia CLASS [weak_ptr<T>] zapuzdruje pouzit je NUTNE vykonat jeho konverziu na instanciu CLASS [shared_ptr<T>] bud jej explicitnym vytvorenim, alebo volanim METHOD weak_ptr<T>.lock(), ktora vracia instanciu CLASS [shared_ptr<T>]. METHOD weak_ptr<T>.lock() vrati PRAZDNU instanciu CLASS [shared_ptr<T>], ak OBJECT uz bol uvolneny. CONSTRUCTOR CLASS [shared_ptr<T>] vrati EXCEPTION [bad_weak_ptr], ak OBJECT uz bol uvolneny.
61. CLASS [weak_ptr<T>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [weak_ptr<T>] z instancie CLASS [weak_ptr<T>].
   B. DESTRUCTOR uvolnuje instanciu CLASS [weak_ptr<T>], pricom vsak NIKDY NEUVOLNUJE referovany OBJECT.
   C. OPERATOR= umoznuje priradit instanciu jednej CLASS [weak_ptr<T>] do inej. OPERATOR= UMOZNUJE priradit aj instanciu CLASS [shared_ptr<T>] do instancie CLASS [weak_ptr<T>].
   D. METHOD weak_ptr<T>.reset() umoznuje zrusit referovanie instancie CLASS [weak_ptr<T>] na OBJECT.
   E. METHOD weak_ptr<T>.swap() umoznuje vzajomne si vymenit POINTERS na OBJECTS na ktore referuju 2 instancie CLASS [weak_ptr<T>].
   !!! F. METHOD weak_ptr<T>.use_count() vracia aktualnu hodnotu REFERENCE COUNTER instancie CLASS [shared_ptr<T>] z ktorej bola instancia CLASS [weak_ptr<T>] vytvorena.
   G. METHOD weak_ptr<T>.owner_before() vracia informacia ci jedna instancia CLASS [weak_ptr<T>] sa nachadza pred inou v IMPLEMENTATION DEFINED ORDER.
   !!! H. METHOD weak_ptr<T>.expire() vracia informaciu ci instancia CLASS [shared_ptr<T>] z ktorej bola instancia CLASS [weak_ptr<T>] vytvorena ma platny OBJECT, alebo je prazdna.
   !!!!! I. METHOD weak_ptr<T>.lock() vracia instanciu CLASS [shared_ptr<T>], ktora zapuzdruje TEN ISTY OBJECT ako zapudzdovala instancia CLASS [shared_ptr<T>] z ktorej bola instancia CLASS [weak_ptr<T>] vytvorena. Pomocou tejto METHOD je mozne pristupit k OBJECT, ktory instancia CLASS [weak_ptr<T>] zapuzdruje.
!!!!! 62. CLASS NESMIE obsahovat FIELDS typu [shared_ptr<T>], ktora referuje na POINTER THIS, pretoze v momente ak by REFERENCE COUNTER sa znizil na 0, zavolal by sa DESTRUCTOR pre CURRENT OBJECT a nasledne pokracovanie CODE v niektorej z METHOD daneho OBJECT by viedlo k MEMORY ACCESS ERROR.
!!!!! 63. CONSTRUCTOR CLASS [shared_ptr<T>], ktory prijima ako PARAMETER POINTER moze byt volany pri splneni tychto podmienok.
   !!! A. POINTER MUSI byt ALOKOVANY pomocou OPERATOR NEW. Ak nie je, potom je NEVYHNUTNE definovat CUSTOM DELETE FUNCTION, ktora dany POINTER uvolni inym sposobom.
   B. Ak POINTER reprezentuje C++ ARRAY, potom je NEVYHNUTNE definovat CUSTOM DELETE FUNCTION, ktora zavola OPERATOR DELETE[].
   !!!!! C. POINTER na ten isty POINTER NESMIE byt priradeny VIAC AKO JEDNEJ INSTANCII CLASS [shared_ptr<T>]. Ak k tomu dojde, kedze OBE INSTANCIE maju VLASTNE REFERENCE COUNTER, ktore NIE SU PREVIAZANE, vo svojich DESTRUCTORS sa pokusia volat OPERATOR DELETE[] cim dojde k MEMORY ACCESS ERROR. Ak POINTER ma byt obsiahnuty vo VIACERYCH instanciach CLASS [shared_ptr<T>], potom 2. instanciu je potrebne vytvorit volanim jej CONSTRUCTOR do ktoreho sa vlozi 1. instancia CLASS [shared_ptr<T>]. V tomto pripade budu mat OBE INSTANCIE SHARED REFERENCE COUNTER a DESTRUCTOR CLASS [shared_ptr<T>] zavola OPERATOR DELETE az ked tento SHARED REFERENCE COUNTER klesne na 0.
   !!!!! D. POINTER NESMIE reprezentovat THIS POINTER. Ak by sa tak stalo, instancia CLASS [shared_ptr<T>] ma NEZAVISLY REFERENCE COUNTER, ktory ak poklesne na 0, DESTRUCTOR tejto intancie zavola OPERATOR DELETE na THIS POINTER co sposobi MEMORY ACCESS ERROR. Jednym z mnoznych rieseni je zdedenie CUSTOM CLASS z CLASS [enable_shared_from_this<T>] a pouzitie FUNCTION shared_from_this().
!!! 64. Ak do CLASS [shared_ptr<T>] je nutne ulozit THIS POINTER, je mozne vyuzit nasledujuci postup.
   A. CUSTOM CLASS ktora chce do instancie CLASS [shared_ptr<T>] ulozit THIS POINTER MUSI byt DERIVED z CLASS [enable_shared_from_this<T>].
   B. Ak CUSTOM CLASS chce vytvorit instanciu CLASS [shared_ptr<T>] pre THIS POINTER MUSI volat METHOD enable_shared_from_this<T>.shared_from_this(). METHOD vracia instanciu CLASS [shared_ptr<T>] vytvorenu z THIS POINTER.
   !!!!! C. Velkou NEVYHODOU METHOD enable_shared_from_this<T>.shared_from_this() je, ze NEMOZE byt volana z CONSTRUCTOR CUSTOM CLASS. Pokus o taketo volanie hodi EXCEPTION [bad_weak_ptr].
   !!!!! D. NEVYHODOU METHOD enable_shared_from_this<T>.shared_from_this() je, ze pri vytvarani instancie CUSTOM CLASS je NEVYHNUTNE ju priradit do instancie CLASS [shared_ptr<T>], inak dojde k EXCEPTION [bad_weak_ptr].
65. CLASS [shared_ptr<T>] definuje CONSTRUCTOR s 2 PARAMETERS, kde prvy je TYPE [shared_ptr<T>] a druhy je TYPE POINTER, ktory sa nazyva ALIASING CONSTRUCTOR. Sluzi na to ak OBJECT obsahuje ako svoj FIELD iny OBJECT. V tomto pripade je zivotnost OBOCH OBJECTS ZVIAZANA (ak sa uvolni PARENT OBJECT automaticky sa uvolnuje aj CHILD OBJECT), a prave na vyjadenie tejto zavislosti sluzi ALIASING CONSTRUCTOR. Samozrejme, ako 2. PARAMETER MUSI byt zaslany POINTER na FIELD OBJECT, ktoreho POINTER je obaleny v 1. PARAMETER, inak sa POINTER v 2. PARAMETER VOBEC NEUVOLNI.
!!! 66. CLASS [shared_ptr<T>] NIE JE THREAD SAFE, ale C++ poskytuje nasledujuce FUNCTIONS pre THREAD SAFE pracu s POINTER, ktory instancia CLASS [shared_ptr<T>] obaluje.
   A. FUNCTION atomic_is_lock_free() vracia TRUE, ak atomicke opracie nad CLASS [shared_ptr<T>] su LOCK FREE.
   B. FUNCTION atomic_load() vracia novu instanciu CLASS [shared_ptr<T>] z instancie CLASS [shared_ptr<T>] THREAD SAFE sposobom.
   C. FUNCTION atomic_store() nastavuje instanciu CLASS [shared_ptr<T>] na POINTER ulozeny v instancii CLASS [shared_ptr<T>] na novy POINTER THREAD SAFE sposobom.
   D. FUNCTION atomic_exchange() vymiena POINTERS ulozene v dvoch instanciach CLASS [shared_ptr<T>] THREAD SAFE sposobom.
!!!!! 67. Aj ked CLASS [shared_ptr<T>] NIE JE THREAD SAFE, tak operacie nad ROZNYMI INSTANCIAMI CLASS [shared_ptr<T>], ktore referuju na TEN ISTY OBJECT z ROZNYCH THREADS SU THREAD SAFE. THREAD UNSAFE je IBA pristup k TEJ ISTE instancii CLASS [shared_ptr<T>] z ROZLICNYCH THREADS.
68. ALLOCATOR je C++ CONCEPT, ktory umoznuje implementovat CUSTOM MEMORY MODELS. MEMORY MODEL definuje sposob ako sa v C++ alokuje DYNAMIC MEMORY.
69. C++ 11 definuje viacero zmien v definicii C++ STANDARD LIBRARY, ktore zjednodusuju pouzitie ALLOCATORS.
   A. V C++ 11 uz nie je vyzadovane, aby ALLOCATORS rovnakeho TYPE boli povazovane za IDENTICKE. ALLOCATORS su identicke iba vtedy, ak MEMORY alokovana pomocou ALLOCATOR 1, moze byt uvolnena ALLOCATOR 2.
   B. V C++ 11 maju ALLOCATORS definovane TYPE TRAITS umoznuju urcit vlastnosti ALLOCATOR ako je schopnost pouzit ALLOCATOR pri kopirovani COLLECTIONS pomocou COPY SEMANTICS, MOVE SEMANTICS alebo SWAP.
   C. V C++ 11 su definovane ALLOCATOR ADAPTERS, ktore umoznuju propagovat ALLOCATOR z COLLECTIONS na COLLECTION ITEMS.
   D. C++ 11 umoznuje vytvorit POLYMORPHIC ALLOCATOR, ktory umoznuje kopirovanie a presun ITEMS medzi COLLECTIONS s rozlicnymi ALLOCATOR TYPES, ak su ALLOCATOR TYPES identicke.
70. ALLOCATOR je CUSTOM CLASS, ktora MUSI implementovat nasledujuce METHODS.
   A. METHOD ALLOCATOR::allocate() alokuje MEMORY pre 'N' ELEMENTS. Alokovana MEMORY je vratena ako RETURN VALUE.
   B. METHOD ALLOCATOR::construct() inicializuje ELEMENT identifikovany pomocou POINTER, ktory sa prenasa ako 1. PARAMETER na VALUE, ktora je prenesena ako 2. PARAMETER.
   C. METHOD ALLOCATOR::destroy() odstranuje ELEMENT identifikovany pomocou POINTER, ktory sa prenasa ako 1. METHOD vola DESTRUCTOR daneho ELEMENT, ale NEUVOLNUJE MEMORY.
   D. METHOD ALLOCATOR::deallocate() uvolnuje MEMORY pre 'N' ELEMENTS. MEMORY je identifikovana pomocou POINTER, ktory sa prenasa ako 1. PARAMETER.
!!! 71. C++ CLASSES, ktore interne pouzivaju ALLOCATORS VZDY obsahuje METHOD XXX::get_allocator(), ktora vracia ALLOCATOR TYPE. Tento TYPE je mozne pomocou OPERATOR== porovnat s inym ALLOCATOR TYPE a zistit ci 2 CLASSES pouzivaju ten isty ALLOCATOR TYPE.
!!!!! 72. Ak 2 CLASSES pouzivaju ten ISTY ALLOCATOR TYPE, potom je mozne STORAGE alokovany ALLOCATOR v 1. CLASS uvolnit pomocou ALLOCATOR, ktoru pouziva 2. CLASS.
73. TEMPLATE CLASS [uses_allocator<TType,TAllocatorType>] umoznuje zistit ci TYPE [TType] interne pouziva ALLOCATOR TYPE [TAllocatorType].
74. CUSTOM ALLOCATORS by mali mat nasledujuce MEMBERS.
   1. TYPE [ALOCATOR::value_type] vracia TYPE pre ktory ALLOCATOR alokuje MEMORY. Spravidla sa jedna o identicky TYPE ako TYPE PARAMETER CUSTOM ALLOCATOR.
   2. TYPE [ALOCATOR::size_type] vracia TYPE pouzivany na reprezentaciu velkosti alokovanych OBJECTS. Spravidla sa pouziva TYPE [size_t].
   3. TYPE [ALOCATOR::difference_type] vracia TYPE pouzivany na reprezentaciu vzdialenosti medzi dvoma POINTERS. Spravidla sa pouziva TYPE [ptrdiff_t].
   4. TYPE [ALOCATOR::pointer] vracia TYPE reprezentujuci POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [ALOCATOR::value_type*].
   5. TYPE [ALOCATOR::const_pointer] vracia TYPE reprezentujuci CONST POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [const ALOCATOR::value_type*].
   6. TYPE [ALOCATOR::void_pointer] vracia TYPE reprezentujuci VOID POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [ALOCATOR::void*].
   7. TYPE [ALOCATOR::const_void_pointer] vracia TYPE reprezentujuci CONST VOID POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [const ALOCATOR::void*].
   8. TYPE [ALOCATOR::reference] vracia TYPE reprezentujuci REFERENCES, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [ALOCATOR::value_type*].
   9. TYPE [ALOCATOR::const_reference] vracia TYPE reprezentujuci CONST REFERENCES, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [const ALOCATOR::value_type*].
   10. TYPE [ALOCATOR::propagate_on_container_copy_assignment] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt skopirovany pomocou COPY SEMANTICS ak sa pomocou COPY SEMANTICS kopiruje COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   11. TYPE [ALOCATOR::propagate_on_container_move_assignment] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt skopirovany pomocou MOVE SEMANTICS ak sa pomocou MOVE SEMANTICS kopiruje COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   12. TYPE [ALOCATOR::propagate_on_container_swap] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt SWAPPED ak sa vykonava SWAP COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   13. TYPE [ALOCATOR::is_always_equal] je TYPE TRAIT urcujuci ci 2 instancie CUSTOM ALLOCATOR TYPE su VZDY IDENTICKE. V C++ 11 mozu 2 instancie toho isteho ALLOCATOR byt NEIDENTICKE, ak MEMORY alokovana jednou instanciou ALLOCATOR TYPE NEMOZE byt uvolnena inou instanciou ALLOCATOR TYPE.
   14. TEMPLATE STRUCTURE [ALOCATOR::rebind<TType>] umoznuje kazdemu CUSTOM ALLOCATOR nepriamo alokovat MEMORY pre lubovolny TYPE 'TType'.
   15. DEFAULT CONSTRUCTOR. Vytvara DEFAULT INSTANCE ALLOCATOR.
   16. COPY CONSTRUCTOR. Vytvara kopiu ALLOCATOR pomocou COPY SEMANTICS.
   17. MOVE CONSTRUCTOR. Vytvara kopiu ALLOCATOR pomocou MOVE SEMANTICS.
   18. DESTRUCTOR. Uvolnuje RESOURCES alokovane ALLOCATOR.
   19. OPERATOR== vracia TRUE ak CUSTOM ALLOCATORS su schopne vzajomne dealokovat MEMORY, ktoru jeden z CUSTOM ALLOCATOR alokoval.
   20. OPERATOR!= vracia TRUE ak CUSTOM ALLOCATORS nie su schopne vzajomne dealokovat MEMORY, ktoru jeden z CUSTOM ALLOCATOR alokoval.
   21. METHOD ALOCATOR::address() pre REFERENCE vracia POINTER obsahujucu adresu na ktoru REFERENCE odkazuje. OVERLOADED VERSION vracia pre CONST REFERENCE CONST POINTER.
   22. METHOD ALOCATOR::max_size() vracia maximalnu velkost OBJECT, ktory je pomocou CUSTOM ALLOCATOR mozne alokovat.
   23. METHOD ALLOCATOR::alocate() alokuje MEMORY pre 'N' OBJECTS. Hodnota 'N' musi byt VACSIA ako 0. OVERLOADED VERSION definuje HINT, ktory obsahuje CUSTOM INFORMATION o pozicii odkial ma byt MEMORY alokovana.
   24. METHOD ALLOCATOR::deallocate() uvolnuje MEMORY pre 'N' OBJECTS.
   25. METHOD ALLOCATOR::construct() vola CONSTRUCTOR vytvoreneho OBJECT.
   26. METHOD ALLOCATOR::destruct() vola DESTRUCTOR vytvoreneho OBJECT.
   27. METHOD ALLOCATOR::select_on_container_copy_construction() vracia kopiu zadaneho ALLOCATOR. FUNCTION je volana v COPY CONSTRUCTORS standardnych CONTAINTERS pre vytvorenie kopie CUSTOM ALLOCATOR.
75. Minimalisticka verzia CUSTOM ALLOCATORS MUSI mat MINIMALNE nasledujuce MEMBERS.
   A. TYPE [ALLOCATOR::value_type], ktory vracia TYPE pre ktory ALLOCATOR alokuje MEMORY. Spravidla sa jedna o identicky TYPE ako TYPE PARAMETER CUSTOM ALLOCATOR.
   B. TEMPLATE COPY CONSTRUCTOR, ktory kopiruje interny STATE ALLOCATOR.
   C. COPY CONSTRUCTOR, ak ALLOCATOR ma interny STATE.
   D. MOVE CONSTRUCTOR, ak ALLOCATOR ma interny STATE.
   E. DESTRUCTOR, ak ALLOCATOR ma interny STATE.
   F. OPERATOR==, ktory vracia TRUE ak CUSTOM ALLOCATORS su schopne vzajomne dealokovat MEMORY, ktoru jeden z CUSTOM ALLOCATOR alokoval.
   G. OPERATOR!=, ktory vracia TRUE ak CUSTOM ALLOCATORS nie su schopne vzajomne dealokovat MEMORY, ktoru jeden z CUSTOM ALLOCATOR alokoval.
   H. METHOD ALLOCATOR::alocate(), ktora alokuje MEMORY pre 'N' OBJECTS. Hodnota 'N' musi byt VACSIA ako 0. OVERLOADED VERSION definuje HINT, ktory obsahuje CUSTOM INFORMATION o pozicii odkial ma byt MEMORY alokovana.
   I. METHOD ALLOCATOR::deallocate(), ktora uvolnuje MEMORY pre 'N' OBJECTS.
!!! 76. Pretoze C++ poskytuje alternativne implementacie pre METHOD ALLOCATOR::construct() a METHOD ALLOCATOR::destruct(), CUSTOM ALLOCATOR ich NEMUSI EXPLICITNE implementovat.
77. TEMPLATE STRUCTURE [ALLOCATOR::rebind<TType>] je OPTIONAL MEMBER STRUCTURE pre ktoru platia nasledujuce vlastnosti.
   A. TEMPLATE STRUCTURE [ALLOCATOR::rebind<TType>] MUSI definovat TYPE [other], ktory vracia ALLOCATOR TYPE umoznujuci alokovat OBJECTS TYPE 'TType'.
   B. TEMPLATE STRUCTURE [ALLOCATOR::rebind<TType>] zmenit TYPE OBJECTS, ktore bude ALLOCATOR alokovat. Ak napriklad ALLOCATOR alokuje OBJECTS TYPE 'XXX', potom TYPE [ALLOCATOR::rebind<YYY>::other] reprezentuje CUSTOM ALLOCATOR, ktory dokaze alokovat OBJECTS TYPE 'YYY'.
   C. TEMPLATE STRUCTURE [ALLOCATOR::rebind<TType>] sa typicky pouziva v CONTAINERS, ktore okrem alokacie ITEMS, musia alokovat aj pomocne data, ktore su INEHO TYPE ako COLLECTION ITEMS. V takom pripade sa pouzije TEMPLATE STRUCTURE [ALLOCATOR::rebind<TType>] na definovanie ALLOCATOR, ktory je schopny alokovat tieto pomocne data.
78. CLASS [allocator] reprezentuje DEFUALT ALLOCATOR. Pre DEFUALT ALLOCATOR platia nasledujuce fakty.
   A. DEFUALT ALLOCATOR pouziva na alokaciu MEMORY GLOBAL OPERATOR 'new', a preto moze hodit EXCEPTION TYPE [bad_alloc].
   B. DEFUALT ALLOCATOR pouziva na dealokaciu MEMORY GLOBAL OPERATOR 'delete'.
   C. DEFUALT ALLOCATOR definuje SPECIALIZATION pre TYPE 'void*'.
79. CLASS [allocator] ma nasledujuce MEMBERS.
   A. TYPE [value_type] vracia TYPE pre ktory ALLOCATOR alokuje MEMORY. Spravidla sa jedna o identicky TYPE ako TYPE PARAMETER CUSTOM ALLOCATOR.
   B. TYPE [propagate_on_container_move_assignment] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt skopirovany pomocou MOVE SEMANTICS ak sa pomocou MOVE SEMANTICS kopiruje COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   C. TYPE [ALOCATOR::is_always_equal] je TYPE TRAIT urcujuci ci 2 instancie CUSTOM ALLOCATOR TYPE su VZDY IDENTICKE. V C++ 11 mozu 2 instancie toho isteho ALLOCATOR byt NEIDENTICKE, ak MEMORY alokovana jednou instanciou ALLOCATOR TYPE NEMOZE byt uvolnena inou instanciou ALLOCATOR TYPE.
   D. DEFAULT CONSTRUCTOR. Vytvara DEFAULT INSTANCE ALLOCATOR.
   E. COPY CONSTRUCTOR. Vytvara kopiu ALLOCATOR pomocou COPY SEMANTICS.
   F. MOVE CONSTRUCTOR. Vytvara kopiu ALLOCATOR pomocou MOVE SEMANTICS.
   G. TEMPLATE COPY CONSTRUCTOR vytvorit kopiu ALLOCATOR, ktory bude alokovat OBJECTS ineho TYPE.
   H. DESTRUCTOR. Uvolnuje RESOURCES alokovane ALLOCATOR.
   I. OPERATOR== vracia TRUE ak CUSTOM ALLOCATORS su schopne vzajomne dealokovat MEMORY, ktoru jeden z CUSTOM ALLOCATOR alokoval.
   J. OPERATOR!= vracia TRUE ak CUSTOM ALLOCATORS nie su schopne vzajomne dealokovat MEMORY, ktoru jeden z CUSTOM ALLOCATOR alokoval.
   K. METHOD alocate() alokuje MEMORY pre 'N' OBJECTS. Hodnota 'N' musi byt VACSIA ako 0. OVERLOADED VERSION definuje HINT, ktory obsahuje CUSTOM INFORMATION o pozicii odkial ma byt MEMORY alokovana.
   L. METHOD deallocate() uvolnuje MEMORY pre 'N' OBJECTS.
80. CLASS [allocator_traits<TAllocator>] definuje zoznam TRAITS, ktore sa v ALLOCATORS pouzivaju. Ma nasledujuce MEMBERS.
   A. TYPE [allocator_type] vracia ALLOCATOR TYPE, pre ktory je CLASS [allocator_traits] vytvorena.
   B. TYPE [value_type] vracia TYPE pre ktory ALLOCATOR alokuje MEMORY. Je identicky s TYPE [ALLOCATOR::value_type].
   C. TYPE [size_type] vracia TYPE pouzivany na reprezentaciu velkosti alokovanych OBJECTS. Je identicky s TYPE [ALLOCATOR::size_type], ak tento TYPE ALLOCATOR definuje.
   D. TYPE [difference_type] vracia TYPE pouzivany na reprezentaciu vzdialenosti medzi dvoma POINTERS. Je identicky s TYPE [ALLOCATOR::difference_type], ak tento TYPE ALLOCATOR definuje.
   E. TYPE [pointer] vracia TYPE reprezentujuci POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Je identicky s TYPE [ALLOCATOR::pointer], ak tento TYPE ALLOCATOR definuje.
   F. TYPE [const_pointer] vracia TYPE reprezentujuci CONST POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Je identicky s TYPE [ALLOCATOR::const_pointer], ak tento TYPE ALLOCATOR definuje.
   G. TYPE [void_pointer] vracia TYPE reprezentujuci VOID POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Je identicky s TYPE [ALLOCATOR::void_pointer], ak tento TYPE ALLOCATOR definuje.
   H. TYPE [const_void_pointer] vracia TYPE reprezentujuci CONST VOID POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Je identicky s TYPE [ALLOCATOR::const_void_pointer], ak tento TYPE ALLOCATOR definuje.
   I. TYPE [reference] vracia TYPE reprezentujuci REFERENCES, ktore sa pouzivaju v CUSTOM ALLOCATOR. Je identicky s TYPE [ALLOCATOR::reference], ak tento TYPE ALLOCATOR definuje.
   J. TYPE [const_reference] vracia TYPE reprezentujuci CONST REFERENCES, ktore sa pouzivaju v CUSTOM ALLOCATOR. Je identicky s TYPE [ALLOCATOR::const_reference], ak tento TYPE ALLOCATOR definuje.
   K. TYPE [propagate_on_container_copy_assignment] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt skopirovany pomocou COPY SEMANTICS ak sa pomocou COPY SEMANTICS kopiruje COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   L. TYPE [propagate_on_container_move_assignment] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt skopirovany pomocou MOVE SEMANTICS ak sa pomocou MOVE SEMANTICS kopiruje COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   M. TYPE [propagate_on_container_swap] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt SWAPPED ak sa vykonava SWAP COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   N. TYPE [is_always_equal] je TYPE TRAIT, ktory je nastaveny na TYPE [true_type] ak kazdy TYPE PARAMETER ma nastaveny TYPE [is_always_equal] na TYPE [true_type]. Inak vracia TYPE [false_type]. V C++ 11 mozu 2 instancie toho isteho ALLOCATOR byt NEIDENTICKE, ak MEMORY alokovana jednou instanciou ALLOCATOR TYPE NEMOZE byt uvolnena inou instanciou ALLOCATOR TYPE.
   O. TEMPLATE STRUCTURE [rebind_alloc<TType>] definuje ALLOCATOR, ktory umoznuje alokovat MEMORY pre TYPE 'TType'.
   P. TEMPLATE STRUCTURE [rebind_traits<TType>] definuje ALLOCATOR TRAITS, ktory umoznuje alokovat MEMORY pre TYPE 'TType'.
   Q. METHOD alocate() alokuje MEMORY pre 'N' OBJECTS. Hodnota 'N' musi byt VACSIA ako 0. OVERLOADED VERSION definuje HINT, ktory obsahuje CUSTOM INFORMATION o pozicii odkial ma byt MEMORY alokovana.
   R. METHOD deallocate() uvolnuje MEMORY pre 'N' OBJECTS.
   S. METHOD construct() vola CONSTRUCTOR vytvoreneho OBJECT.
   T. METHOD destruct() vola DESTRUCTOR vytvoreneho OBJECT.
   U. METHOD max_size() vracia maximalnu velkost OBJECT, ktory je pomocou CUSTOM ALLOCATOR mozne alokovat.
   V. METHOD select_on_container_copy_construction() vracia kopiu zadaneho ALLOCATOR.
81. CLASS [pointer_traits<TPointer>] definuje zoznam TRAITS popisujucich dany POINTER TYPE. Ma nasledujuce MEMBERS.
   A. TYPE [pointer] vracia TYPE reprezentujuci POINTERS. Je identicky s TEMPLATE PARAMETER 'TPointer'.
   B. TYPE [element_type] vracia TYPE identicky s TYPE [TPointer::element_type], ak TYPE 'TPointer' definuje. Ak nedefinuje, potom TYPE je rovny PRVEMU TEMPLATE PARAMETER TYPE 'TPointer', ak TYPE 'TPointer' reprezentuje TEMPLATE TYPE.
   C. TYPE [difference_type] vracia TYPE pouzivany na reprezentaciu vzdialenosti medzi dvoma POINTERS. Je identicky s TYPE [TPointer::difference_type], ak TYPE 'TPointer', tak TYPE definuje. Ak ho nedefinuje, TYPE [difference_type] je nastaveny na TYPE [ptrdiff_t].
   D. TEMPLATE STRUCTURE [rebind<TType>] vracia TYPE identicky s TYPE [TPointer::rebind<TType>], ak TYPE 'TPointer' definuje. Ak nedefinuje, potom TYPE je rovny PRVEMU TEMPLATE PARAMETER TYPE 'TPointer', ak TYPE 'TPointer' reprezentuje TEMPLATE TYPE.
   E. STATIC METHOD pointer_to() vracia DEREFERENCEABLE POINTER-LIKE OBJECT, ktory je mozne pre PARAMETER METHOD dereferencovat.
82. CLASS [pointer_traits<TPointer*>] definuje zoznam TRAITS popisujucich dany POINTER TYPE. Ma nasledujuce MEMBERS.
   A. TYPE [pointer] vracia TYPE reprezentujuci POINTERS. Je identicky s TEMPLATE PARAMETER 'TPointer*'.
   B. TYPE [element_type] vracia TYPE 'TPointer'.
   C. TYPE [difference_type] vracia TYPE pouzivany na reprezentaciu vzdialenosti medzi dvoma POINTERS. Je nastaveny na TYPE [ptrdiff_t].
   D. TEMPLATE STRUCTURE [rebind<TType>] vracia TYPE identicky s TYPE [TType*].
   E. STATIC METHOD pointer_to() vracia DEREFERENCEABLE POINTER-LIKE OBJECT, ktory je mozne pre PARAMETER METHOD dereferencovat.
!!! 83. C++ 11 definuje VARIADIC TEMPLATE CLASS [scoped_allocator_adaptor<TOuterAlloc,...TInnerAlloc>] pre ktoru platia nasledujuce zasady.
   A. TYPE PARAMETERS CLASS [scoped_allocator_adaptor<TOuterAlloc,...TInnerAlloc>] su ALLOCATOR TYPES.
   B. TYPE PARAMETERS reprezentuju ALLOCATORS, ktore sa pouziju pri alokacii COLLECTION ITEMS.
   !!!!! C. Ak COLLECTION obsahuje ako ITEM INU COLLECTION (vnorena COLLECTION), tak CLASS [scoped_allocator_adaptor<TOuterAlloc,...TInnerAlloc>] umoznuje pre kazde jedno vnorenie urcit ALLOCATOR. To znamena, ze napriklad pre TYPE [vector<list<set>>] 1. TYPE PARAMETER definuje ALLOCATOR, ktory pouzije CLASS [vector], 2. TYPE PARAMETER definuje ALLOCATOR, ktory pouzije CLASS [list] a 3. TYPE PARAMETER definuje ALLOCATOR, ktory pouzije CLASS [list].
84. CLASS [scoped_allocator_adaptor<TOuterAlloc,...TInnerAlloc>] ma nasledujuce MEMBERS.
   1. TYPE [outer_allocator_type] urcuje ALLOCATOR na 1. urovni vnorenej COLLECTION.
   2. TYPE [outer_allocator_type] urcuje ALLOCATOR na 2. urovni vnorenej COLLECTION. Kedze TYPE [outer_allocator_type] je VARIADIC TYPE PARAMETER je ho mozne rekurzivne rozbalit pre kazdu uroven vnorenej COLLECTION.
   3. TYPE [value_type] vracia TYPE pre ktory ALLOCATOR alokuje MEMORY. Spravidla sa jedna o identicky TYPE ako TYPE PARAMETER CUSTOM ALLOCATOR. Je identicky s TYPE [allocator_traits<TOuterAlloc>::value_type].
   4. TYPE [size_type] vracia TYPE pouzivany na reprezentaciu velkosti alokovanych OBJECTS. Spravidla sa pouziva TYPE [size_t]. Je identicky s TYPE [allocator_traits<TOuterAlloc>::size_type].
   5. TYPE [difference_type] vracia TYPE pouzivany na reprezentaciu vzdialenosti medzi dvoma POINTERS. Spravidla sa pouziva TYPE [ptrdiff_t]. Je identicky s TYPE [allocator_traits<TOuterAlloc>::difference_type].
   6. TYPE [pointer] vracia TYPE reprezentujuci POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [ALOCATOR::value_type*]. Je identicky s TYPE [allocator_traits<TOuterAlloc>::pointer].
   7. TYPE [const_pointer] vracia TYPE reprezentujuci CONST POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [const ALOCATOR::value_type*]. Je identicky s TYPE [allocator_traits<TOuterAlloc>::const_pointer].
   8. TYPE [void_pointer] vracia TYPE reprezentujuci VOID POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [ALOCATOR::void*]. Je identicky s TYPE [allocator_traits<TOuterAlloc>::void_pointer].
   9. TYPE [const_void_pointer] vracia TYPE reprezentujuci CONST VOID POINTERS, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [const ALOCATOR::void*]. Je identicky s TYPE [allocator_traits<TOuterAlloc>::const_void_pointer].
   10. TYPE [reference] vracia TYPE reprezentujuci REFERENCES, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [ALOCATOR::value_type*]. Je identicky s TYPE [allocator_traits<TOuterAlloc>::reference].
   11. TYPE [const_reference] vracia TYPE reprezentujuci CONST REFERENCES, ktore sa pouzivaju v CUSTOM ALLOCATOR. Spravidla sa pouziva TYPE [const ALOCATOR::value_type*]. Je identicky s TYPE [allocator_traits<TOuterAlloc>::const_reference].
   12. TYPE [propagate_on_container_copy_assignment] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt skopirovany pomocou COPY SEMANTICS ak sa pomocou COPY SEMANTICS kopiruje COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   13. TYPE [propagate_on_container_move_assignment] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt skopirovany pomocou MOVE SEMANTICS ak sa pomocou MOVE SEMANTICS kopiruje COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   14. TYPE [propagate_on_container_swap] je TYPE TRAIT urcujuci ci CUSTOM ALLOCATOR ma byt SWAPPED ak sa vykonava SWAP COLLECTION OBJECT, ktory obsahuje instanciu CUSTOM ALLOCATOR. DEFAULT VALUE je reprezentovany TYPE [false_type].
   15. TYPE [is_always_equal] je TYPE TRAIT, ktory je nastaveny na TYPE [true_type] ak kazdy TYPE PARAMETER ma nastaveny TYPE [is_always_equal] na TYPE [true_type]. Inak vracia TYPE [false_type]. V C++ 11 mozu 2 instancie toho isteho ALLOCATOR byt NEIDENTICKE, ak MEMORY alokovana jednou instanciou ALLOCATOR TYPE NEMOZE byt uvolnena inou instanciou ALLOCATOR TYPE.
   16. TEMPLATE STRUCTURE [rebind<TType>] umoznuje kazdemu CUSTOM ALLOCATOR nepriamo alokovat MEMORY pre lubovolny TYPE.
   17. CONSTRUCTOR vytvara instanciu ALLOCATOR. OVERLOADED VERSIONS definuju COPY CONSTRUCTOR a MOVE CONSTRUCTOR.
   18. DESTRUCTOR uvolnuje RESOURCES alokovane ALLOCATOR.
   19. OPERATOR= priradzuje jednu instanciu ALLOCTOR do druhej. OVERLOADED VERSIONS definuju COPY OPERATOR= a MOVE OPERATOR=.
   20. OPERATOR== vracia TRUE ak ALLOCATOR ADAPTERS su schopne vzajomne dealokovat MEMORY, ktoru jeden z ALLOCATOR ADAPTER alokoval.
   21. OPERATOR!= vracia TRUE ak ALLOCATOR ADAPTERS nie su schopne vzajomne dealokovat MEMORY, ktoru jeden z ALLOCATOR ADAPTER alokoval.
   22. METHOD inner_allocator() vracia REFERENCE an ALLOCATOR na 1. urovni vnorenej COLLECTION.
   23. METHOD outer_allocator() vracia REFERENCE na ALLOCATOR na 2. urovni vnorenej COLLECTION. Kedze TYPE [outer_allocator_type] je VARIADIC TYPE PARAMETER je ho mozne rekurzivne rozbalit pre kazdu uroven vnorenej COLLECTION.
   24. METHOD max_size() vracia maximalnu velkost OBJECT, ktory je pomocou CUSTOM ALLOCATOR mozne alokovat.
   25. METHOD alocate() alokuje MEMORY pre 'N' OBJECTS. Hodnota 'N' musi byt VACSIA ako 0. OVERLOADED VERSION definuje HINT, ktory obsahuje CUSTOM INFORMATION o pozicii odkial ma byt MEMORY alokovana.
   26. METHOD deallocate() uvolnuje MEMORY pre 'N' OBJECTS.
   27. METHOD construct() vola CONSTRUCTOR vytvoreneho OBJECT.
   28. METHOD destruct() vola DESTRUCTOR vytvoreneho OBJECT.
   29. METHOD select_on_container_copy_construction() vracia kopiu zadaneho ALLOCATOR.
!!! 85. C++ definuje vo svojom standarde APPLICATION BINARY INTERFACE, ktory umoznuje implementatorom C++ COMPILER implementovat GARBAGE COLLECTOR pre C++ PROGRAMY. Tento APPLICATION BINARY INTERFACE je vsak OPTIONAL a C++ COMPILERS ho NEMUSIA IMPLEMENTOVAT.
86. GARBAGE COLLECTORS v C++ rozlisuju POINTERS do 2 CATEGORIES.
   A. SAFELY DERIVED POINTERS su take, ktore vznikli alokaciou pomocou OPERATOR NEW. Tieto POINTERS su BEZPECNE a GARBAGE COLLECTOR ich moze odstranit z MEMORY ak na nich nereferuje ziadna VARIABLE.
   B. NOT SAFELY DERIVED POINTERS su take, ktore vznikli posunom POINTERS pomocou POINTER ARITHMETICS, pomocou OPERATOR reinterpret_cast<TYPE>(), matematickou operaciou, deserializaciou z FILE ci inym nestandardnym sposobom. Tieto POINTERS predstavuju RIZIKO, pretoze AK NEREFERUJU na MEMORY BLOCK alokovany OPERATOR NEW ich uvolnenie sposobi RUNTIME ERROR. GARBAGE COLLECTORS by NOT SAFELY DERIVED POINTERS NEMALI UVOLNOVAT.
87. C++ definuje subor FUNCTIONS, ktore je mozne pouzit na oznacenie MEMORY BLOCK, ktory GARBAGE COLLECTOR (ak je definovany) nesmie dealokovat. Tieto MEMORY BLOCKS spravidla reprezentuju MEMORY, ktora je pristupna cez POINTERS nad ktorymi sa robi POINTER ARITHMETICS a GARBAGE COLLECTOR by mohol mat problem spravne identifikovat, ze sa jedna o stale platnu a referovanu MEMORY.
   A. FUNCTION declare_reachable() umoznuje oznacit OBJECT na ktory referuje zadany POINTER ako MEMORY BLOCK, ktory NESMIE byt UVOLNENY GARBAGE COLLECTOR.
   B. FUNCTION undeclare_reachable() je reverznou FUNCTION voci FUNCTION declare_reachable(), umoznujuc deklarovat MEMORY BLOCK, ktory bol predtym oznaceny ako BLOCK, ktory GARBAGE COLLECTOR NESMIE ODSTRANIT z MEMORY za BLOCK, ktory GARBAGE COLLECTOR moze ZNOVA ODSTRANIT z MEMORY.
   C. FUNCTION declare_no_pointers() umoznuje oznacit MEMORY BLOCK (zaciatocny POINTER a pocet BYTES) za BLOCK, ktory NESMIE byt UVOLNENY byt UVOLNENY GARBAGE COLLECTOR.
   D. FUNCTION undeclare_no_pointers() je reverznou FUNCTION voci FUNCTION declare_no_pointers(), umoznujuc deklarovat MEMORY BLOCK (zaciatocny POINTER a pocet BYTES), ktory bol predtym oznaceny ako BLOCK, ktory GARBAGE COLLECTOR NESMIE ODSTRANIT z MEMORY za BLOCK, ktory GARBAGE COLLECTOR moze ZNOVA ODSTRANIT z MEMORY.
   E. FUNCTION get_pointer_safety() vracia hodnotu ENUM [pointer_safety], ktora urcuje aky POINTER SAFETY MODEL GARBAGE COLLECTOR pouziva.
88. ENUM [pointer_safety] definuje hodnoty POINTER SAFETY MODEL, ktory moze GARBAGE COLLECTOR pouzit. Ma nasledujuce hodnoty.
   A. VALUE [pointer_safety::strict] znamena, ze GARBAGE COLLECTOR uvolnuje iba SAFELY DERIVED POINTERS.
   B. VALUE [pointer_safety::preffered] znamena, ze GARBAGE COLLECTOR uvolnuje SAFELY DERIVED POINTERS aj NOT SAFELY DERIVED POINTERS, pricom GARBAGE COLLECTOR moze bezat ako REACHABILITY BASED LEAK DETECTOR.
   C. VALUE [pointer_safety::relaxed] znamena, ze GARBAGE COLLECTOR uvolnuje SAFELY DERIVED POINTERS aj NOT SAFELY DERIVED POINTERS.
89. C++ poskytuje v LIBRARY [<memory>] sadu HELPER TEMPLATE FUNCTIONS, ktore moze CUSTOM ALLOCATOR pouzit na efektivnu inicializaciu a kopirovanie NEINICIALIZOVANEJ MEMORY.
   A. TEMPLATE FUNCTION uninitialized_fill() nakopiruje danu hodnotu do ELEMETNS NEINICIALIZOVANEJ MEMORY.
   B. TEMPLATE FUNCTION uninitialized_fill_n() nakopiruje danu hodnotu do 'N' ELEMETNS NEINICIALIZOVANEJ MEMORY.
   C. TEMPLATE FUNCTION uninitialized_copy() nakopiruje ELEMENTS do NEINICIALIZOVANEJ MEMORY.
   D. TEMPLATE FUNCTION uninitialized_copy_n() nakopiruje 'N' ELEMENTS do NEINICIALIZOVANEJ MEMORY.
   E. TEMPLATE FUNCTION raw_storage_iterator() umoznuje iterovat ELEMENTS NEINICIALIZOVANEJ MEMORY a pomocou niektoreho z ALGORITHMS ju inicializovat na hodnoty, ktore su vysledkom daneho ALGORITHM.
90. C++ poskytuje FUNCTIONS na pracu s TEMPORARY BUFFERS, ktore je mozne pouzit v ramci FUNCTIONS na alokaciu tychto BUFFERS.
   A. FUNCTION get_temporary_buffer() sa pokusi alokovat 'N' OBJECTS. Ak sa nepodari alokovat dostatocnu MEMORY, FUNCTION vracia instanciu CLASS [pair<T1,T2>], kde 1. PARAMETER obsahuje POINTER na alkovanu MEMORY a 2. PARAMETER obsahuje pocet OBJECTS, ktore boli alokovane.
   B. FUNCTION return_temporary_buffer() uvolnuje TEMPORARY BUFFER alokovany FUNCTION get_temporary_buffer().
91. CLASS [raw_storage_iterator<TOutputIterator,TType>] REPREZENTUJE RAW STORAGE ITERATOR, ktory umoznuje iterovat cez RAW MEMORY. Ma nasledujuce MEMBERS.
   A. TYPE [value_type] obsahuje TYPE [void].
   B. TYPE [difference_type] obsahuje TYPE [void].
   C. TYPE [pointer] obsahuje TYPE [void].
   D. TYPE [reference] obsahuje TYPE [void].
   !!! E. TYPE [iterator_category] obsahuje TYPE [output_iterator_tag].
   F. CONSTRUCTOR vytvara pre zadany OUTPUT ITERATOR novy RAW STORAGE ITERATOR.
   G. OPERATOR= priradzuje do aktualnej pozicie RAW STORAGE ITERATOR VALUE TYPE 'TType'. Je definovany COPY OPERATOR= aj MOVE OPERATOR=.
   H. OPERATOR* dereferencuje RAW STORAGE ITERATOR na aktualnej pozicii.
   I. ++OPERATOR inkrementuje ITERATOR POSITION.
   J. OPERATOR++ inkrementuje ITERATOR POSITION.
   K. METHOD base() vracia ITERATOR, ktory RAW STORAGE ITERATOR zapuzdruje.
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
THREAD SAFE CLASS CLASS [shared_ptr<T>].

!!! 1. CLASS [shared_ptr<T>] NIE JE THREAD SAFE, ale C++ poskytuje nasledujuce FUNCTIONS pre THREAD SAFE pracu s POINTER, ktory instancia CLASS [shared_ptr<T>] obaluje.
   A. FUNCTION atomic_is_lock_free() vracia TRUE, ak atomicke opracie nad CLASS [shared_ptr<T>] su LOCK FREE.
   B. FUNCTION atomic_load() vracia novu instanciu CLASS [shared_ptr<T>] z instancie CLASS [shared_ptr<T>] THREAD SAFE sposobom.
   C. FUNCTION atomic_store() nastavuje instanciu CLASS [shared_ptr<T>] na POINTER ulozeny v instancii CLASS [shared_ptr<T>] na novy POINTER THREAD SAFE sposobom.
   D. FUNCTION atomic_exchange() vymiena POINTERS ulozene v dvoch instanciach CLASS [shared_ptr<T>] THREAD SAFE sposobom.
!!!!! 2. Aj ked CLASS [shared_ptr<T>] NIE JE THREAD SAFE, tak operacie nad ROZNYMI INSTANCIAMI CLASS [shared_ptr<T>], ktore referuju na TEN ISTY OBJECT z ROZNYCH THREADS SU THREAD SAFE. THREAD UNSAFE je IBA pristup k TEJ ISTE instancii CLASS [shared_ptr<T>] z ROZLICNYCH THREADS.
!!!!! 3. C++ DOCUMENTATION ku CLASS [shared_ptr<T>] uvadza nasledujuce informacie k THREAD SAFE.
   A.  If multiple threads of execution access the same [shared_ptr<T>] without synchronization and any of those accesses uses a non-const member function of [shared_ptr<T>] then a data race will occur. The [shared_ptr<T>] overloads of atomic functions can be used to prevent the data race.
   !!!!! B. All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of [shared_ptr<T>] without additional synchronization EVEN IF these instances are copies and SHARE OWNERSHIP of the SAME OBJECT.
//-------------------------------------------------------------------------------------------------------