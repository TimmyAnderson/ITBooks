//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje TEMPLATE SPECIALIZATION a TEMPLATE FUNCTION OVERLOADING.
2. TEMPLATE SPECIALIZATION umoznuje pre kombinaciu TEMPLATE ARGUMENTS definovat vlastnu verziu CLASS, METHOD, FUNCTION ci VARIABLE, ktora je NEZAVISLA na povodnej PRIMARY TEMPLATE.
3. Pre TEMPLATE FUNCTIONS a TEMPLATE METHODS C++ okrem mechanizmu TEMPLATE SPECIALIZATION podporuje aj TEMPLATE FUNCTION OVERLOADING a TEMPLATE METHOD OVERLOADING. Pomocou OVERLOADING je mozne definovat verziu TEMPLATE FUNCTION, alebo TEMPLATE METHOD, ktora je NEZAVISLA od povodnej TEMPLATE FUNCTION ci TEMPLATE METHOD.
!!! 4. Pri OVERLOADING TEMPLATE FUNCTIONS C++ umoznuje existenciu viacerych TEMPLATE FUNCTIONS aj ked pri INSTANTIATION budu mat rovnake TEMPLATE PARAMETERS. V takom pripade C++ vybera spravnu OVERLOADED TEMPLATE FUNCTION na zaklade OVERLOADING RULES.
5. FUNCTION SIGNATURE je tvorena nasledujucimi informaciami.
   A. FUNCTION UNQUALIFIED NAME, alebo TEMPLATE FUNCTION NAME, ak je FUNCTION generovana z TEMPLATE FUNCTION.
   B. CLASS SCOPE, alebo NAMESPACE SCOPE danej FUNCTION NAME. V pripade, ze FUNCTION ma INTERNAL LINKAGE, potom je to TRANSLATION UNIT v ktorej je FUNCTION deklarovana.
   C. MODIFIER [const], MODIFIER [volatile], alebo MODIFIER [const volatile], ak FUNCTION je METHOD.
   D. QUALIFIER [&], alebo QUALIFIER [&&], ak FUNCTION je METHOD.
   !!! E. TYPES vsetkych FUNCTION PARAMETERS. V pripade TEMPLATE FUNCTIONS su to FUNCTION PARAMETERS predtym nez su TEMPLATE PARAMETERS subsituovane.
   !!!!! F. RETURN TYPE v pripade, ze sa jedna o TEMPLATE FUNCTION.
   G. TEMPLATE PARAMETERS a TEMPLATE ARGUMENTS v pripade, ze sa jedna o TEMPLATE FUNCTION.
!!! 6. V C++ viacero FUNCTIONS mozu koexistovat, ak FUNCTIONS maju rovnaku SIGNATURE.
!!!!! 7. Aj ked FUNCTIONS maju ROZLICNE SIGNATURES a C++ teda umoznuje ich OVERLOADING, to ci dojde k AMBIGUITY zalezi od FUNCTION ARGUMENTS a TEMPLATE FUNCTION ARGUMENTS. Pre niektore kombinacii moze dojst k AMBIGUITY.
8. Ak ma C++ vybrat z OVERLOADED TEMPLATE FUNCTIONS pricom vsetky FUNCTIONS v CANDIDATE SET vyhovuju rovnako dobre, C++ uplatni PARTIAL ORDERING RULE kedy preferuje MORE SPECIALIZED TEMPLATE FUNCTION pred LESS SPECIALIZED TEMPLATE FUNCTION. To, ktora TEMPLATE FUNCTION je MORE SPECIALIZED sa urci podla nasledujuceho postupu.
   A. FUNCTION CALL PARAMETERS, ktore su substituovane pomocou DEFAULT ARGUMENTS su IGNOROVANE. Takisto su ignorovane ELLIPSIS PARAMETERS, ktore nie su pouzite.
   B. COMPILER pri porovnavani 2 TEMPLATE FUNCTIONS zostavi 2 ARTIFICIAL LISTS ARGUMENT TYPES - jeden pre kazdu TEMPLATE FUNCTION. V pripade CONVERSION OPERATORS sa beru do uvahy RETURN VALUE TYPES.
   C. Pri zostavovani ARTIFICIAL LIST ARGUMENT TYPES je kazdy TEMPLATE TYPE PARAMETER nahradeny unikatnym INVENTED TYPE. INVENTED TYPE je unikatny TYPE vygenerovany COMPILER.
   D. Pri zostavovani ARTIFICIAL LIST ARGUMENT TYPES je kazdy TEMPLATE TEMPLATE PARAMETER nahradeny unikatnym INVENTED TEMPLATE CLASS TYPE. INVENTED TEMPLATE CLASS TYPE je unikatny TYPE vygenerovany COMPILER.
   E. Pri zostavovani ARTIFICIAL LIST ARGUMENT TYPES je kazdy TEMPLATE NON-TYPE PARAMETER nahradeny unikatnou INVENTED VALUE TYPE NON-TYPE PARAMETER. INVENTED VALUE je unikatna VALUE vygenerovana COMPILER.
   !!! F. Ak TEMPLATE ARGUMENT DEDUCTION pre 2. TEMPLATE FUNCTION voci 1. ARTIFICIAL LIST ARGUMENT TYPES uspeje na zaklade EXACT MATCH, ale 1. TEMPLATE FUNCTION voci 2. ARTIFICIAL LIST ARGUMENT TYPES NEUSPEJE na zaklade EXACT MATCH, potom 1. TEMPLATE FUNCTION je MORE SPECIALIZED ako 2. TEMPLATE FUNCTION.
   !!! G. Ak TEMPLATE ARGUMENT DEDUCTION pre 1. TEMPLATE FUNCTION voci 2. ARTIFICIAL LIST ARGUMENT TYPES uspeje na zaklade EXACT MATCH, ale 2. TEMPLATE FUNCTION voci 1. ARTIFICIAL LIST ARGUMENT TYPES NEUSPEJE na zaklade EXACT MATCH, potom 2. TEMPLATE FUNCTION je MORE SPECIALIZED ako 1. TEMPLATE FUNCTION.
   !!! H. Ak ani jedna TEMPLATE FUNCTION nie je MORE SPECIALIZED ako druha, COMPILER hodi ERROR, pretoze doslo k AMBIGUITY.
!!! 9. TEMPLATE FUNCTIONS mozu byt OVERLOADED pomocou NON-TEMPLATE FUNCTIONS. Pre OVERLOADING TEMPLATE FUNCTIONS a NON-TEMPLATE FUNCTIONS platia nasledujuce RULES.
   A. Ak TEMPLATE FUNCTION a NON-TEMPLATE FUNCTION maju rovnaky MATCH, C++ vzdy uprednostni NON-TEMPLATE FUNCTION pred TEMPLATE FUNCTION.
   B. Ak TEMPLATE FUNCTION ma LEPSI MATCH ako NON-TEMPLATE FUNCTION, C++ vyberie TEMPLATE FUNCTION.
!!! 10. PARTIAL ORDERING RULE je sa aplikuje aj na VARIADIC TEMPLATE FUNCTIONS. Platia pri tom nasledujuce pravidla.
   !!! A. Pri zostavovani ARTIFICIAL LISTS je kazdy TEMPLATE PACK posudzovany ako 1 PARAMETER.
   B. Na zaklade toho ci sa jedna o TEMPLATE PARAMETER PACK TEMPLATE TYPE PARAMETERS, TEMPLATE TEMPLATE PARAMETERS, alebo TEMPLATE NON-TYPE PARAMETERS sa vygeneruju prislusne INVENTED TYPES, alebo INVENTED VALUES.
   !!! C. Cely proces PARTIAL ORDERING RULE je nasledne TAKMER rovnaky ako pre NON-VARIADIC TEMPLATE PARAMETERS.
   !!!!! D. Jedinou zmenou v PARTIAL ORDERING RULE je, ze pri subsitucii ARTIFICIAL LIST ARGUMENT TYPES do OVERLOADED TEMPLATE FUNCTIONS je ZAKAZANE, aby ARGUMENT TYPE, ktory vznikol z VARIADIC TEMPLATE PACK bol substituovany za TEMPLATE FUNCTION PARAMETER, ktory NIE JE VARIADIC TEMPLATE PACK. To znamena, ze C++ povazuje NON-VARIADIC TEMPLATE FUNCTIONS za MORE SPECIALIZED ako VARIADIC TEMPLATE FUNCTIONS.
   !!! E. PARTIAL ORDERING RULE sa analogicky aplikuje aj ked je TEMPLATE PARAMETER PACK aplikovany na VARIADIC TEMPLATE CLASSES, ktore su PARAMETERS TEMPLATE FUNCTIONS.
!!! 11. TEMPLATE FUNCTION OVERLOADING je mozny iba pre TEMPLATE FUNCTIONS a TEMPLATE METHODS. C++ pre ostatne typy TEMPLATES poskytuje alternativny mechanizmus SPECIALIZATION nazyvany EXPLICIT SPECIALIZATION. C++ definuje nasledujuce typy EXPLICIT SPECIALIZATIONS.
   A. FULL EXPLICIT SPECIALIZATIONS.
   B. PARTIAL EXPLICIT SPECIALIZATIONS.
12. Pre EXPLICIT SPECIALIZATIONS platia nasledujuce fakty.
   A. EXPLICIT SPECIALIZATIONS sa vykonavaju z existujucich TEMPLATES, ktore sa nazyvaju PRIMARY TEMPLATES.
   B. EXPLICIT SPECIALIZATIONS poskytuju alternativnu implementaciu TEMPLATE CLASSES, TEMPLATE FUNCTIONS, TEMPLATE METHODS ci TEMPLATE VARIABLES, ktora ma substituovane bude VSETKY, alebo len NIEKTORE TEMPLATE PARAMETERS.
   !!! C. C++ hodi ERROR, ak pre danu TEMPLATE existuje pre dane TEMPLATE PARAMETERS je najprv vytvorena INSTANTINATION a nasledne je definovana EXPLICIT TEMPLATE SPECIALIZATION pre tie iste TEMPLATE PARAMETERS.
   !!!!! D. PRIMARY TEMPLATES a TEMPLATE SPECIALIZATIONS by sa mali VZDY definovat v TOM ISTOM TRANSLATION UNIT. Ak sa pouzije TEMPLATE SPECIALIZATION este predtym ako dojde k jej DEFINITION, ktora je v inom TRANSLATION UNIT, COMPILER tento ERROR NEMUSI byt schopny odhalit.
13. Pre FULL EXPLICIT SPECIALIZATIONS platia nasledujuce fakty.
   A. FULL EXPLICIT SPECIALIZATIONS su TEMPLATE SPECIALIZATIONS, ktore maju definovane vsetky TEMPLATE PARAMETERS za konkretne TYPES.
   B. FULL EXPLICIT SPECIALIZATIONS je mozne vykonat pre TEMPLATE CLASSES, TEMPLATE FUNCTIONS, TEMPLATE METHODS a TEMPLATE VARIABLES.
14. Pre PARTIAL EXPLICIT SPECIALIZATIONS platia nasledujuce fakty.
   A. PARTIAL EXPLICIT SPECIALIZATIONS su TEMPLATE SPECIALIZATIONS, ktore maju definovane IBA NIEKTORE TEMPLATE PARAMETERS za konkretne TYPES, pricom obsahuju aj TEMPLATE PARAMETERS.
   B. PARTIAL EXPLICIT SPECIALIZATIONS je mozne vykonat pre TEMPLATE CLASSES a TEMPLATE VARIABLES, ale NIE pre TEMPLATE FUNCTIONS a TEMPLATE METHODS.
15. Pre FULL EXPLICIT SPECIALIZATIONS pre TEMPLATE CLASSES platia nasledujuce fakty.
   A. FULL EXPLICIT SPECIALIZATION je identifikovana pomocou SYNTAX [template<>], ktora je aplikovana pred KEYWORD [class].
   B. TEMPLATE PARAMETERS danej FULL EXPLICIT SPECIALIZATION su identifikovane pomocou SYNTAX [CLASS_NAME<TEMPLATE_PARAMETERS>], kde VALUE 'CLASS_NAME' je nazov TEMPLATE CLASS a VALUE 'TEMPLATE_PARAMETERS' je zoznam TEMPLATE PARAMETERS pre danu FULL EXPLICIT SPECIALIZATION.
   !!! C. FULL EXPLICIT SPECIALIZATION TEMPLATE CLASS je absolutne NEZAVISLA na PRIMARY TEMPLATE CLASS. To znamena, ze moze mat vlastne FIELDS, METHODS, CONSTRUCTORS, DESTRUCTORS, OPERATORS, INNER CLASSES ci USINGS, ktore nemaju nic spolocne s PRIMARY TEMPLATE CLASS.
   !!! D. FULL EXPLICIT SPECIALIZATION musi mat definovany ROVNAKY POCET a TYPE TEMPLATE ARGUMENTS ako je POCET a TYPES TEMPLATE PARAMETERS v PRIMARY TEMPLATE. To znamena, ze za TEMPLATE TYPE PARAMETER musi byt dosadeny TYPE, za TEMPLATE TEMPLATE PARAMETER musi byt dosadeny TEMPLATE a za TEMPLATE VALUE PARAMETER musi byt dosadena VALUE.
   E. FULL EXPLICIT SPECIALIZATION nemusi mat definovany TEMPLATE ARGUMENT pre TEMPLATE PARAMETER, ktory ma DEFAULT VALUE.
   !!!!! F. Ak FULL EXPLICIT SPECIALIZATION definuje TEMPLATE MEMBERS ako TEMPLATE STATIC VARIABLES, alebo TEMPLATE METHODS OUT OF CLASS, tak tieto NESMU mat aplikovanu SYNTAX [template<>], inak COMPILER hodi ERROR. Je to preto, lebo sa jedna o bezne CLASS MEMBERS a nie TEMPLATE CLASS MEMBERS.
16. Pre FULL EXPLICIT SPECIALIZATIONS pre TEMPLATE FUNCTIONS platia nasledujuce fakty.
   A. FULL EXPLICIT SPECIALIZATION je identifikovana pomocou SYNTAX [template<>], ktora je aplikovana pred FUNCTION SIGNATURE.
   B. TEMPLATE PARAMETERS danej FULL EXPLICIT SPECIALIZATION su identifikovane pomocou SYNTAX [FUNCTION_NAME<TEMPLATE_PARAMETERS>], kde VALUE 'FUNCTION_NAME' je nazov TEMPLATE FUNCTION a VALUE 'TEMPLATE_PARAMETERS' je zoznam TEMPLATE PARAMETERS pre danu FULL EXPLICIT SPECIALIZATION.
   !!! C. C++ umoznuje VYNECHAT TEMPLATE PARAMETERS pre FULL EXPLICIT SPECIALIZATION TEMPLATE FUNCTION, ak tieto mozu byt DEDUCED z FUNCTION PARAMETERS.
   !!! D. FULL EXPLICIT SPECIALIZATION TEMPLATE FUNCTION NESMIE mat DEFAULT ARGUMENTS. DEFAULT ARGUMENTS, ktore boli aplikovane na PRIMARY TEMPLATE FUNCTION su vsak automaticky aplikovane.
   !!!!! E. Kedze FULL EXPLICIT SPECIALIZATION TEMPLATE FUNCTION je v skutocnosti NON-TEMPLATE FUNCTION, tak sa na nu aplikuje ONE DEFINITION RULE. To znamena, ze moze byt DEFINED iba RAZ v CELOM PROGRAME.
   !!!!! F. DECLARATION FULL EXPLICIT SPECIALIZATION TEMPLATE FUNCTION musi VZDY PREDCHADZAT jej prvemu pouzitiu, iba COMPILER hodi ERROR. Prax je taka, ze V HEADER FILE [.H] sa po DEFINITION PRIMARY TEMPLATE FUNCTION nachadzaju DECLARATIONS vsetkych TEMPLATE FUNCTION SPECIALIZATIONS, aby bolo zabezpecene, ze DECLARATIONS TEMPLATE FUNCTION SPECIALIZATIONS predchadzaju ich prvemu pouzitiu. DEFINITIONS TEMPLATE FUNCTION SPECIALIZATIONS su spravidla ulozene v zodpovedajucom FILE [.cpp], aby sa dodrzal ONE DEFINITION RULE.
17. Pre FULL EXPLICIT SPECIALIZATIONS pre TEMPLATE VARIABLES platia nasledujuce fakty.
   A. FULL EXPLICIT SPECIALIZATION je identifikovana pomocou SYNTAX [template<>], ktora je aplikovana pred TEMPLATE VARIABLE.
   B. TEMPLATE PARAMETERS danej FULL EXPLICIT SPECIALIZATION su identifikovane pomocou SYNTAX [VARIABLE_NAME<TEMPLATE_PARAMETERS>], kde VALUE 'VARIABLE_NAME' je nazov TEMPLATE VARIABLE a VALUE 'TEMPLATE_PARAMETERS' je zoznam TEMPLATE PARAMETERS pre danu FULL EXPLICIT SPECIALIZATION.
   C. EXPLICIT SPECIALIZATION TEMPLATE VARIABLE moze mat inicializacnu VALUE, ktora je nezavisla od inicializacnej VALUE PRIMARY TEMPLATE VARIABLE.
   !!! D. EXPLICIT SPECIALIZATION TEMPLATE VARIABLE nemusi mat rovnaky TYPE ako PRIMARY TEMPLATE VARIABLE.
!!! 18. C++ umoznuje vytvarat FULL EXPLICIT SPECIALIZATIONS aj pre NON-TEMPLATE METHODS TEMPLATE CLASSES, hoci samotna TEMPLATE CLASSES NIE JE SPECIALIZED. Pre FULL EXPLICIT SPECIALIZATIONS NON-TEMPLATE METHODS TEMPLATE CLASSES platia nasledujuce fakty.
   A. FULL EXPLICIT SPECIALIZATION je identifikovana pomocou SYNTAX [template<>], ktora je aplikovana pred FUNCTION SIGNATURE.
   B. TEMPLATE PARAMETERS danej FULL EXPLICIT SPECIALIZATION su identifikovane pomocou SYNTAX [METHOD_NAME<TEMPLATE_PARAMETERS>], kde VALUE 'METHOD_NAME' je nazov NON-TEMPLATE METHOD TEMPLATE CLASS a VALUE 'TEMPLATE_PARAMETERS' je zoznam TEMPLATE PARAMETERS pre danu FULL EXPLICIT SPECIALIZATION.
   !!!!! C. FULL EXPLICIT SPECIALIZATIONS pre NON-TEMPLATE METHODS TEMPLATE CLASSES je mozne vykonat aj vtedy, ked samotna TEMPLATE CLASSES NIE JE SPECIALIZED.
   !!!!! D. FULL EXPLICIT SPECIALIZATIONS pre NON-TEMPLATE METHODS TEMPLATE CLASSES sa ZASADNE LISI od METHODS TEMPLATE CLASS SPECIALIZATIONS. Kym pre METHODS TEMPLATE CLASS SPECIALIZATIONS sa NESMIE pouzit SYNTAX [template<>], tak pre FULL EXPLICIT SPECIALIZATIONS pre NON-TEMPLATE METHODS TEMPLATE CLASSES je SYNTAX [template<>] NUTNA.
   !!! E. C++ umoznuje OUT-OF-CLASS DECLARATIONS pre FULL EXPLICIT SPECIALIZATIONS NON-TEMPLATE METHODS TEMPLATE CLASSES. 
!!! 19. C++ umoznuje vytvarat FULL EXPLICIT SPECIALIZATIONS aj pre NON-TEMPLATE STATIC FIELDS TEMPLATE CLASSES, hoci samotna TEMPLATE CLASSES NIE JE SPECIALIZED. Pre FULL EXPLICIT SPECIALIZATIONS NON-TEMPLATE STATIC FIELDS TEMPLATE CLASSES platia nasledujuce fakty.
   A. FULL EXPLICIT SPECIALIZATION je identifikovana pomocou SYNTAX [template<>], ktora je aplikovana pred FUNCTION SIGNATURE.
   B. TEMPLATE PARAMETERS danej FULL EXPLICIT SPECIALIZATION su identifikovane pomocou SYNTAX [TEMPLATE_CLASS_NAME<TEMPLATE_PARAMETERS>::FIELD_NAME], kde VALUE 'TEMPLATE_CLASS_NAME' je nazov TEMPLATE CLASS, VALUE 'TEMPLATE_PARAMETERS' je zoznam TEMPLATE PARAMETERS pre danu FULL EXPLICIT SPECIALIZATION a VALUE 'FIELD_NAME' je nazov NON-TEMPLATE NON-STATIC FIELD TEMPLATE CLASS.
   !!! C. C++ umoznuje OUT-OF-CLASS DECLARATIONS pre FULL EXPLICIT SPECIALIZATIONS NON-TEMPLATE STATIC FIELDS TEMPLATE CLASSES.
20. C++ umoznuje vytvarat FULL EXPLICIT SPECIALIZATIONS aj pre INNER CLASSES TEMPLATE CLASSES, hoci samotna TEMPLATE CLASSES NIE JE SPECIALIZED. Pre FULL EXPLICIT SPECIALIZATIONS INNER CLASSES TEMPLATE CLASSES platia nasledujuce fakty.
   A. FULL EXPLICIT SPECIALIZATION je identifikovana pomocou SYNTAX [template<>], ktora je aplikovana pred FUNCTION SIGNATURE.
   B. TEMPLATE PARAMETERS danej FULL EXPLICIT SPECIALIZATION su identifikovane pomocou SYNTAX [CLASS_NAME<TEMPLATE_PARAMETERS>], kde VALUE 'CLASS_NAME' je nazov INNER CLASSES TEMPLATE CLASS a VALUE 'TEMPLATE_PARAMETERS' je zoznam TEMPLATE PARAMETERS pre danu FULL EXPLICIT SPECIALIZATION.
!!!!! 21. C++ NEUMOZNUJE, aby pri definicii C++ ELEMENT po SYNTAXI [template<TEMPLATE_PARAMETERS>] nasledovala SYNTAX [template<>]. COMPILER v takom pripade VZDY hodi ERROR.
22. C++ umoznuje PARTIAL EXPLICIT SPECIALIZATIONS pre CLASSES. Pre PARTIAL EXPLICIT SPECIALIZATIONS pre CLASSES platia nasledujuce fakty.
   A. PARTIAL EXPLICIT SPECIALIZATION je identifikovana pomocou SYNTAX [template<TEMPLATE_PARAMETERS>], ktora je aplikovana pred KEYWORD [class].
   B. TEMPLATE PARAMETERS danej PARTIAL EXPLICIT SPECIALIZATION su identifikovane pomocou SYNTAX [CLASS_NAME<TEMPLATE_PARAMETERS>], kde VALUE 'CLASS_NAME' je nazov TEMPLATE CLASS a VALUE 'TEMPLATE_PARAMETERS' je zoznam TEMPLATE PARAMETERS pre danu PARTIAL EXPLICIT SPECIALIZATION.
!!! 23. V pripade, ze TEMPLATE PARAMETERS vyhovuju FULL EXPLICIT SPECIALIZATIONS aj PARTIAL EXPLICIT SPECIALIZATIONS, C++ uplatnuje nasledujuce poradie priorit.
   A. FULL EXPLICIT SPECIALIZATIONS su preferovane pred PARTIAL EXPLICIT SPECIALIZATIONS.
   B. PARTIAL EXPLICIT SPECIALIZATIONS su preferovane pred PRIMAR TEMPLATES.
   !!!!! C. PARTIAL EXPLICIT SPECIALIZATIONS TEMPLATE CLASSES mozu mat INY POCET TEMPLATE PARAMETERS, ako maju PRIMARY TEMPLATE CLASSES. Ale pocet TEMPLATE PARAMETERS, ktore su dosadene do PRIMARY TEMPLATE musi zodpovedat poctu TEMPLATE PARAMETERS, ktore ma PRIMARY TEMPLATE. Vynimkou je aplikacia DEFAULT TEMPLATE PARAMETER ARGUMENTS a VARIADIC TEMPLATES.
   !!! D. Pri vybere z viacerych PARTIAL EXPLICIT SPECIALIZATIONS TEMPLATE CLASSES C++ preferuje MORE SPECIALIZED PARTIAL EXPLICIT SPECIALIZATION.
24. PARTIAL EXPLICIT SPECIALIZATIONS TEMPLATE CLASSES ma nasledujuce obmedzenia.
   A. ARGUMENTY PARTIAL EXPLICIT SPECIALIZATION musia byt rovnakeho typu (TYPE PARAMETERS, NON-TYPE PARAMETERS, TEMPLATE PARAMETERS) ako zodpovedajuce TEMPLATE PARAMETERS PRIMARY TEMPLATE.
   B. PARTIAL EXPLICIT SPECIALIZATION NESMIE mat DEFAULT ARGUMENTS pre svoje TEMPLATE PARAMETERS. No DEFAULT ARGUMENTS z PRIMARY TEMPLATE su aplikovane na PARTIAL EXPLICIT SPECIALIZATION, ak ta za prislusne TEMPLATE PARAMETERS nedosadi vlastne TEMPLATE ARGUMENTS.
   C. NON-TYPE ARGUMENTS v PARTIAL EXPLICIT SPECIALIZATION musia byt NON-DEPENDENT VALUES, alebo obycajne NON-TYPE TEMPLATE PARAMETERS. Ani EXPRESSIONS ako EXPRESSION [2*VALUE], kde VALUE 'VALUE' na VALUE NON-TYPE TEMPLATE ARGUMENT nie su povolene.
   D. Zoznam TEMPLATE ARGUMENTS v PARTIAL EXPLICIT SPECIALIZATION nesmie byt identicky so zoznamom TEMPLATE PARAMETERS v PRIMARY TEMPLATE.
   E. Ak niektory TEMPLATE ARGUMENT je EXPANSION PACK, musi byt na konci TEMPLATE ARGUMENTS v PARTIAL EXPLICIT SPECIALIZATION.
25. C++ pri vybere, ktoru z PARTIAL EXPLICIT SPECIALIZATIONS TEMPLATE CLASSES vybrat postupuje nasledujucim sposobom.
   A. Pri vybere PARTIAL EXPLICIT SPECIALIZATION COMPILER vzdy robi LOOKUP do PRIMARY TEMPLATE, aby zistil pocet TEMPLATE PARAMETERS a DEFAULT TEMPLATE ARGUMENTS.
   B. COMPILER nasledne zacne prechadzat vsetky PARTIAL EXPLICIT SPECIALIZATIONS a snazi sa za ne dosadzovate TEMPLATE ARGUMENTS. Plati pritom princip SFINAE, co znamena, ze ked SUBSTITUTION ZLYHA, tak cela PARTIAL EXPLICIT SPECIALIZATION je ignorovana.
   C. Ak COMPILER nenajde ziadnu vyhovujucu PARTIAL EXPLICIT SPECIALIZATION, tak pouzije PRIMARY TEMPLATE.
   D. Ak COMPILER najde viacero vyhovujucich PARTIAL EXPLICIT SPECIALIZATIONS, vyberie tu co je MOST SPECIALIZED.
   !!! E. Ak su vsetky vybrane PARTIAL EXPLICIT SPECIALIZATIONS rovnako SPECIALIZED, COMPILER hodi AMBIGUITY ERROR.
26. Pre PARTIAL EXPLICIT SPECIALIZATIONS pre TEMPLATE VARIABLES platia nasledujuce fakty.
   A. PARTIAL EXPLICIT SPECIALIZATION je identifikovana pomocou SYNTAX [template<TEMPLATE_PARAMETERS>], ktora je aplikovana pred TEMPLATE VARIABLE.
   B. TEMPLATE PARAMETERS danej FULL EXPLICIT SPECIALIZATION su identifikovane pomocou SYNTAX [VARIABLE_NAME<TEMPLATE_PARAMETERS>], kde VALUE 'VARIABLE_NAME' je nazov TEMPLATE VARIABLE a VALUE 'TEMPLATE_PARAMETERS' je zoznam TEMPLATE PARAMETERS pre danu PARTIAL EXPLICIT SPECIALIZATION.
   C. EXPLICIT SPECIALIZATION TEMPLATE VARIABLE moze mat inicializacnu VALUE, ktora je nezavisla od inicializacnej VALUE PRIMARY TEMPLATE VARIABLE.
   !!! D. EXPLICIT SPECIALIZATION TEMPLATE VARIABLE nemusi mat rovnaky TYPE ako PRIMARY TEMPLATE VARIABLE.
//----------------------------------------------------------------------------------------------------------------------