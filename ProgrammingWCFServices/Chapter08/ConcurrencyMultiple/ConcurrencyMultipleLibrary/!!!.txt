//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje CONCURRENCY MODE MULTIPLE.
2. Mod ConcurrencyMode.Multiple nie je ziaden lock a operacie sa vykonavaju kompletne paralelne.
3. Mod ConcurrencyMode.Multiple PLNE UMOZNUJE reentaeranciu a ta vznika nielen pri volani ineho service, ktory by nasledne vyvolal tento, ale aj pri volani callback PRIAMO Z TELA metody service.
!!! 4. Volania nad dvoma objektami SERVICE su plne paralelne. Na to sa ConcurrencyMode nevztahuje.
!!! 5. Proxy musi byt vzdy otvorene (volanim nejakej motody service, alebo ClientBase.Open()) pretoze do doby kym nie je otvorene tak su VSETKY VOLANIA synchronne. Ak teda 2 thready volaju paralalne service a jeho proxy este nebolo otvorene budu PRVE volania SYNCHRONNE. Az tie nasledujuce po otvoreni kanalu budu ASYNCHRONNE.
!!! 6. Atribut [MethodImpl(MethodImplOptions.Synchronized)] poskytuje moznost sycnhronizacie nad volaniami matody pre DANY objekt. Ak teda je metoda service volana z 2 thradov pre tu istu instanciu service potom je volanie synchronne, ale ak su pouzite dve istancie service potom priznak nema vplyv. Je to podobne ako pri ConcurrencyMode.Single akurat, ze je to na jednej metode. Toto nie je riesenie WCF, ale este .NET 2.0..
//-------------------------------------------------------------------------------------------------------