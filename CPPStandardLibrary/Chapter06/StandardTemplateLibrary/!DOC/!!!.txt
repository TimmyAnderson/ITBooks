//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie STANDARD TEMPLATE LIBRARY.
2. STL je sucast C++ STANDARD LIBRARY, ktora implementuje COLLECTIONS a ALGORITHMS nad tymito COLLECTIONS.
3. STL definuje nasledujuce zakladne pojmy.
   A. CONTAINER je DATA STRUCTURE, ktora reprezentuje COLLECTION. Kedze CONTAINERS v STL su TEMPLATES, CONTAINERS mozu ukladat LUBOVOLNE TYPES.
   B. ITERATORS su INTERFACES, ktore umoznuju pristup k ITEMS v CONTAINER. V najjedoduchsom variante C++ ITERATORS definuju jednoduchy INTERFACE s OPERATOR++ na prechod na nasledujuci ITEM a OPERATOR* na ziskanie hodnoty ITEM z ITERATOR. Kedze VSETKY CONTAINERS definuju ITERATORS, ITERATORS sluzia ako standardny INTERFACE pre pracu s CONTAINER ITEMS umoznujuci implementaciu GENERIC ALGORITHMS.
   C. ALGORITHMS predstavuju standardizovane ALGORITHMS, ktore vykonavaju cinnost nad ITERATORS daneho CONTAINER.
!!!!! 4. V STL existuje oddelenie CONTAINERS od ALGORITHMS. To v praxi znaci, ze CONTAINERS NEOBSAHUJU METHODS, ktore by implementovali ALGORITHMS nad danym CONTAINER, ale ALGORITHMS su realizovane ako SEPARATNE TEMPLATE FUNCTIONS, ktore pracuju nad CONTAINERS pomocou ITERATORS. ITERATORS teda sluzia ako spojovy prvom medzi CONTAINTERS a ALGORITHMS. Tento DESIGNT umoznuje, aby existovala iba jedna sada GENERIC ALGORITHMS, ktora pracuje nad LUBOVOLNYM CONTAINER ku ktoremu pristupuje pomocou jeho ITERATORS.
!!!!! 5. Oddelenie ALGORITHMS a CONTAINERS je v PROTIKLADE s principmi OOP, pretoze DATA a OPERATIONS su vzajomne ODDELENE. Dovodom pre tento DESIGN bola snaha mat co najmensiu STL LIBRARY, ktora by nemala pre kazdy typ CONTAINER implementovane tie iste ALGORITHMS ako METHODS. Nevyhodou tohto pristupu je vsak komplikovanejsi a horsie citatelny CODE.
6. STL definuje 3 druhy CONTAINERS.
   A. SEQUENCE CONTAINERS su ORDERED COLLECTIONS, kde kazdy ITEM ma presnu poziciu, ktora zavisi od miesta kde bol ITEM vlozeny, ale je NEZAVISLA na hodnote daneho ITEM.
   B. ASSOCIATIVE CONTAINERS su SORTED COLLECTIONS, kde pozicia ITEM zavisi od jeho VALUE, eventualne hodnoty jeho KEY. ITEMS v COLLECTIONS su SORTED podla kriterii definovanych pri vytvarani COLLECTION.
   C. UNORDERED ASSOCIATIVE CONTAINERS su UNORDERED COLLECTIONS, kde pozicia ITEM NIE JE DEFINOVANA a moze sa menit. COLLECTIONS podla VALUE daneho ITEM, eventualne jeho KEY urcuju ci sa v nich ITEM nachadza, alebo nie.
7. STL definuje nasledujuce SEQUENCE CONTAINERS.
   A. CLASS [array<TItem>].
   B. CLASS [vector<TItem>].
   C. CLASS [deque<TItem>].
   D. CLASS [list<TItem>].
   E. CLASS [forward_list<TItem>].
8. STL definuje nasledujuce ASSOCIATIVE CONTAINERS.
   A. CLASS [set<TItem>].
   B. CLASS [multiset<TItem>].
   C. CLASS [map<TKey,TItem>].
   D. CLASS [multimap<TKey,TItem>].
9. STL definuje nasledujuce UNORDERED ASSOCIATIVE CONTAINERS.
   A. CLASS [unordered_set<TItem>].
   B. CLASS [unordered_multiset<TItem>].
   C. CLASS [unordered_map<TKey,TItem>].
   D. CLASS [unordered_multimap<TKey,TItem>].
!!! 10. ASSOCIATIVE CONTAINERS a UNORDERED ASSOCIATIVE CONTAINERS su interne rozdielne implementovane.
   A. ASSOCIATIVE CONTAINERS su interne implementovane ako BINARY TREES, kde na urcenie pozicie ITEM v CONTAINER sa pouziva COMPARE FUNCTION.
   B. UNORDERED ASSOCIATIVE CONTAINERS su interne implementovane ako HASH TABLES, kde na urcenie pozicie ITEM v CONTAINER sa pouziva HASH FUNCTION.
!!!!! 11. Medzi ASSOCIATIVE CONTAINERS a UNORDERED ASSOCIATIVE CONTAINERS existuje ZASADNY rozdiel v rychlosti vkladania a vyberania ITEMS.
   A. ASSOCIATIVE CONTAINERS su interne implementovane ako BINARY TREES, a preto maju VYSOKU rychlost vkladania a vyberania ITEMS.
   B. UNORDERED ASSOCIATIVE CONTAINERS su interne implementovane ako HASH TABLES, kde HASH TABLES su ARRAYS, a preto maju POMALU vkladania a vyberania ITEMS.
!!!!! 12. Medzi ASSOCIATIVE CONTAINERS a UNORDERED ASSOCIATIVE CONTAINERS existuje ZASADNY rozdiel v rychlosti pristupu k ITEMS.
   A. ASSOCIATIVE CONTAINERS maju pri pristupe k ITEMS zlozitost O(log(N)).
   !!! B. UNORDERED ASSOCIATIVE CONTAINERS maju pri pristupe k ITEMS zlozitost zavisiacu od kvality HASH FUNCTION. Uplne DOKONALA HASH FUNCTION, ktora pre kazdy ITEM vrati iny HASH CODE sposobuje, ze zlozitost vyhladavania ITEMS je O(1). Uplne NEDOKONALA HASH FUNCTION, ktora pre kazdy ITEM vrati rovnaky HASH CODE sposobuje, ze zlozitost vyhladavania ITEMS je O(N).
13. Pre CLASS vector<TItem> platia nasledujuce zasady.
   A. CLASS vector<TItem> je definovana v LIBRARY <vector>.
   B. VECTOR je dynamicke pole, ktoreho velkost sa moze dynamicky menit.
   C. VECTOR umoznuje INDEXOVY pristup k ITEMS. Pristup k ITEMS je extremne rychly a ma zlozitost O(1).
   D. VECTOR umoznuje RYCHLE pridavanie a odoberanie ITEMS z KONCA VECTOR. Pri pridani a odstraneni ITEMS na KONCI VECTOR sa RESIZE vyzadujuci alokaciu MEMORY a kopirovanie vsetkych ITEMS robi IBA ak je prekrocena interna kapacita VECTOR.
   E. VECTOR umoznuje iba POMALE pridavanie a odoberanie ITEMS na ZACIATOK ci do PROSTRIEDKU VECTOR. Kazde pridanie ci ostranenie ITEMS znamena RESIZE vyzadujuci alokaciu MEMORY a kopirovanie vsetkych ITEMS.
   F. VECTOR ma definovany OPERATOR[] na pristup k jeho ITEMS.
14. Pre CLASS deque<TItem> platia nasledujuce zasady.
   A. CLASS deque<TItem> je definovana v LIBRARY <deque>.
   B. DEQUEUE je dynamicke pole, ktoreho velkost sa moze dynamicky menit. DEQUEUE je podobne ARRAY a lisi sa iba a moznosti vkladat rychlo ITEMS aj na zaciatok DEQUEUE.
   C. DEQUEUE umoznuje INDEXOVY pristup k ITEMS. Pristup k ITEMS je extremne rychly a ma zlozitost O(1).
   D. DEQUEUE umoznuje RYCHLE pridavanie a odoberanie ITEMS zo ZACIATKU a KONCA DEQUEUE. Pri pridani a odstraneni ITEMS na ZACIATKU, alebo KONCI DEQUEUE sa RESIZE vyzadujuci alokaciu MEMORY a kopirovanie vsetkych ITEMS robi IBA ak je prekrocena interna kapacita DEQUEUE.
   E. DEQUEUE umoznuje iba POMALE pridavanie a odoberanie ITEMS na do PROSTRIEDKU DEQUEUE. Kazde pridanie ci ostranenie ITEMS znamena RESIZE vyzadujuci alokaciu MEMORY a kopirovanie vsetkych ITEMS.
   F. DEQUEUE ma definovany OPERATOR[] na pristup k jeho ITEMS.
15. Pre CLASS array<TItem,LENGTH> platia nasledujuce zasady.
   A. CLASS array<TItem,LENGTH> je definovana v LIBRARY <array>.
   B. ARRAY je statcke pole, ktore ma pevny pocet ITEMS definovany TEMPLATE PARAMETER 'LENGTH'.
   C. ARRAY umoznuje INDEXOVY pristup k ITEMS. Pristup k ITEMS je extremne rychly a ma zlozitost O(1).
   D. ARRAY NEUMOZNUJE pridavanie ani odoberanie ITEMS.
   E. ARRAY ma definovany OPERATOR[] na pristup k jeho ITEMS.
16. Pre CLASS list<TItem> platia nasledujuce zasady.
   A. CLASS list<TItem> je definovana v LIBRARY <list>.
   B. LIST je obojsmerny spojkovy zoznam, kde kazdy ITEM okrem samotnych dat ma priradene aj POINTERS na predchadzajuci a nasledujuci ITEM.
   C. LIST umoznuje iba velmi POMALY pristup k ITEMS pomocou ich postupneho iterovania, ktore je vyjadrene zlozitostou O(N). Cim dalej su 2 ITEMS od seba, tym dlhsie prechod od jedneho ITEM k druhemu trva. Priamy pristup k ITEMS pomocou indexu NIE JE MOZNY a je VZDY nutne ITEROVAT ITEMS.
   D. LIST podporuje iterovanie oboma smermi.
   E. LIST umoznuje RYCHLE pridavanie a odoberanie ITEMS na lubovolne miesto v LIST so zlozitostou O(1) ak je k dispozicii ITERATOR na ITEM, pred, alebo za ktory sa ma ITEM pridat, alebo odstranit. Pridavanie ITEMS je mozne iba PRED a ZA ITEM na ktory odkazuje ITERATOR. Odoberanie je mozne iba na ITEM na ktory odkazuje ITERATOR.
17. Pre CLASS forward_list<TItem> platia nasledujuce zasady.
   A. CLASS forward_list<TItem> je definovana v LIBRARY <forward_list>.
   B. FORWARD LIST je jednosmerny spojkovy zoznam, kde kazdy ITEM okrem samotnych dat ma priradeny aj POINTER na nasledujuci ITEM.
   C. FORWARD LIST umoznuje iba velmi POMALY pristup k ITEMS pomocou ich postupneho iterovania, ktore je vyjadrene zlozitostou O(N). Cim dalej su 2 ITEMS od seba, tym dlhsie prechod od jedneho ITEM k druhemu trva. Priamy pristup k ITEMS pomocou indexu NIE JE MOZNY a je VZDY nutne ITEROVAT ITEMS.
   D. FORWARD LIST podporuje iterovanie iba smerom dopredu.
   E. FORWARD LIST umoznuje RYCHLE pridavanie a odoberanie ITEMS na lubovolne miesto v LIST so zlozitostou O(1). Pridavanie ITEMS je mozne iba PRED a ZA ITEM na ktory odkazuje ITERATOR. Odoberanie je mozne iba na ITEM na ktory odkazuje ITERATOR.
   F. FORWARD LIST umoznuje RYCHLE pridavanie a odoberanie ITEMS na lubovolne miesto v LIST so zlozitostou O(1) avsak je NUTNE mat k dispozicii ITERATOR. Pri pridavani je mozne pridat ITEM IBA za ITEM na ktory odkazuje ITERATOR. Pri odoberani je mozne odobrat ITEM iba za ITEM na ktory odkazuje ITERATOR.
   !!!!! G. NEVYHODOU FORWARD LIST oproti LIST je to, ze ak sa vo FORWARD LIST najde ITEM tam NIE JE MOZNE tento ITEM odstranit, ani pridat pred neho iny ITEM. Na to je totizto nutne mat k dispozicii ITERATOR na predchadzajuci ITEM, aby sa v nom mohol zmenit POINTER na nasledujuci ITEM.
18. Pre CLASS set<TItem> platia nasledujuce zasady.
   A. CLASS set<TItem> je definovana v LIBRARY <set>.
   B. SET je mnozina ITEMS, kde kazdy ITEM musi mat rozdielnu hodnotu.
   C. ITEMS v SET su ORDERED podla hodnot ITEMS.
   !!! D. SET je interne realizovany ako BINARY TREE.
   E. ITEMS v SET su ORDERED aplikovanim COMPARE FUNCTION na hodnoty ITEMS. Ako DEFAULT sa pouziva OPERATOR< avsak SET umoznuje pri vytvarani definovat CUSTOM COMPARE FUNCTION.
   !!! F. COMPARE FUNCTION sa okrem ORDERING pouziva aj na urcenie ci ITEMS nemaju identicku hodnotu. Identicku hodnotu maju ITEMS vtedy ak plati ze [COMPARE_FUNCTION(ITEM1,ITEM2)==FALSE && COMPARE_FUNCTION(ITEM2,ITEM1)==FALSE].
   G. SET umoznuje RYCHLE vkladanie ITEMS.
   H. SET umoznuje RYCHLE odoberanie ITEMS, aj ked je pomalsie ako vkladanie.
   I. SET umoznuje RYCHLE vyhladanie ITEMS so zlozitostou O(log(N)).
   !!!!! J. V SET NIE JE MOZNE zmenit hodnotu ITEM po jeho vlozeni do SET, pretoze inak by sa narusila vnuorna konzistencia dat a MULTISET by sa stal nepouzitelnym.
19. Pre CLASS multiset<TItem> platia nasledujuce zasady.
   A. CLASS multiset<TItem> je definovana v LIBRARY <set>.
   B. MULTISET na rozdiel od SET umoznuje ulozenie viacerych ITEMS s ROVNAKOU hodnotou.
   C. ITEMS v MULTISET su ORDERED podla hodnot ITEMS.
   !!! D. MULTISET je interne realizovany ako BINARY TREE.
   E. ITEMS v MULTISET su ORDERED aplikovanim COMPARE FUNCTION na hodnoty ITEMS. Ako DEFAULT sa pouziva OPERATOR< avsak MULTISET umoznuje pri vytvarani definovat CUSTOM COMPARE FUNCTION.
   !!! F. COMPARE FUNCTION sa okrem ORDERING pouziva aj na urcenie ci ITEMS nemaju identicku hodnotu. Identicku hodnotu maju ITEMS vtedy ak plati ze [COMPARE_FUNCTION(ITEM1,ITEM2)==FALSE && COMPARE_FUNCTION(ITEM2,ITEM1)==FALSE].
   G. MULTISET umoznuje RYCHLE vkladanie ITEMS.
   H. MULTISET umoznuje RYCHLE odoberanie ITEMS, aj ked je pomalsie ako vkladanie.
   I. MULTISET umoznuje RYCHLE vyhladanie ITEMS so zlozitostou O(log(N)).
   !!!!! J. V MULTISET NIE JE MOZNE zmenit hodnotu ITEM po jeho vlozeni do MULTISET, pretoze inak by sa narusila vnuorna konzistencia dat a MULTISET by sa stal nepouzitelnym.
   !!! K. V C++ 11 je GARANTOVANE, ze ak sa pridava do MULTISET ITEM, ktory ma rovnaku hodnotu ako ITEM, ktory sa uz v MULTISET nachadza, tak novopridany ITEM bude zaradeny az za VSETKY EXISTUJUCE ITEMS s rovnakou hodnotou.
20. Pre CLASS map<TKey,TValue> platia nasledujuce zasady.
   A. CLASS map<TKey,TValue> je definovana v LIBRARY <map>.
   B. MAP je mnozina ITEMS reprezentovanymi KEY-VALUE PAIRS, kde kazdy KEY musi mat rozdielnu hodnotu.
   C. ITEMS v MAP su ORDERED podla hodnot KEYS.
   D. MAP je interne realizovana ako BINARY TREE.
   E. ITEMS v MAP su ORDERED aplikovanim COMPARE FUNCTION na hodnoty KEYS. Ako DEFAULT sa pouziva OPERATOR< avsak MAP umoznuje pri vytvarani definovat CUSTOM COMPARE FUNCTION.
   !!! F. COMPARE FUNCTION sa okrem ORDERING pouziva aj na urcenie ci KEYS nemaju identicku hodnotu. Identicku hodnotu maju KEYS vtedy ak plati ze [COMPARE_FUNCTION(KEY1,KEY2)==FALSE && COMPARE_FUNCTION(KEY2,KEY1)==FALSE].
   G. MAP umoznuje RYCHLE vkladanie ITEMS.
   H. MAP umoznuje RYCHLE odoberanie ITEMS, aj ked je pomalsie ako vkladanie.
   I. MAP umoznuje RYCHLE vyhladanie ITEMS podla ich KEYS so zlozitostou O(log(N)).
   !!!!! J. V MAP NIE JE MOZNE zmenit hodnotu KEY po vlozeni ITEM do MAP, pretoze inak by sa narusila vnuorna konzistencia dat a MAP by sa stala nepouzitelnou.
21. Pre CLASS multimap<TKey,TValue> platia nasledujuce zasady.
   A. CLASS multimap<TKey,TValue> je definovana v LIBRARY <map>.
   B. MULTIMAP je mnozina ITEMS reprezentovanymi KEY-VALUE PAIRS.
   C. MULTIMAP na rozdiel od MAP umoznuje ulozenie viacerych ITEMS s ROVNAKOU hodnotou ich KEYS.
   D. ITEMS v MULTIMAP su ORDERED podla hodnot ich KEYS.
   !!! E. MULTIMAP je interne realizovana ako BINARY TREE.
   F. ITEMS v MULTISET su ORDERED aplikovanim COMPARE FUNCTION na hodnoty KEYS. Ako DEFAULT sa pouziva OPERATOR< avsak MULTIMAP umoznuje pri vytvarani definovat CUSTOM COMPARE FUNCTION.
   !!! G. COMPARE FUNCTION sa okrem ORDERING pouziva aj na urcenie ci KEYS nemaju identicku hodnotu. Identicku hodnotu maju KEYS vtedy ak plati ze [COMPARE_FUNCTION(KEY1,KEY2)==FALSE && COMPARE_FUNCTION(KEY2,KEY1)==FALSE].
   H. SET umoznuje RYCHLE vkladanie ITEMS.
   I. SET umoznuje RYCHLE odoberanie ITEMS, aj ked je pomalsie ako vkladanie.
   J. MULTIMAP umoznuje RYCHLE vyhladanie ITEMS podla ich KEYS so zlozitostou O(log(N)).
   !!!!! K. V MULTIMAP NIE JE MOZNE zmenit hodnotu KEY po jeho vlozeni ITEM do MULTIMAP, pretoze inak by sa narusila vnuorna konzistencia dat a MULTIMAP by sa stala nepouzitelnou.
   !!! L. V C++ 11 je GARANTOVANE, ze ak sa pridava do MULTIMAP ITEM, ktory ma rovnaku hodnotu KEY ako ITEM, ktory sa uz v MULTIMAP nachadza, tak novopridany ITEM bude zaradeny az za VSETKY EXISTUJUCE ITEMS s rovnakym KEY.
22. Pre CLASS unordered_set<TItem> platia nasledujuce zasady.
   A. CLASS unordered_set<TItem> je definovana v LIBRARY <unordered_set>.
   B. UNORDERED SET je mnozina ITEMS, kde kazdy ITEM musi mat rozdielnu hodnotu.
   C. ITEMS v UNORDERED SET su UNORDERED. Ich poradie je nedefinovane a po vlozeni ci odstraneni ITEM sa pozicia moze zmenit.
   !!! D. UNORDERED SET je interne realizovany ako HASH TABLE, ktora je implementovana ako DYNAMIC ARRAY. DYNAMIC ARRAY reprezentuje kolekciu HASH BUCKETS, kde kazdy HASH BUCKET je realizovany ako LINKED LIST.
   !!! E. ITEMS v UNORDERED SET su ukladane do BUCKETS podla hodnoty HASH CODE, ktora sa vypocita aplikovanim HASH FUNCTION na hodnoty ITEMS. Ako DEFAULT sa pouziva TEMPLATE STRUCT [hash<TItem>] avsak UNORDERED SET umoznuje pri vytvarani definovat CUSTOM HASH FUNCTION. TEMPLATE STRUCT [hash<TItem>] je implementovana pre vsetky PRIMITIVE TYPES ako aj pre viacere C++ STANDARD LIBRARY TYPES ako su [string], [wstring], [unique_ptr<T>], [shared_ptr<T>], [error_code], [type_index] ci [thread::id].
   !!! F. Na urcenie, ci ITEMS maju identicku hodnotu sa pouziva EQUAL FUNCTION. Ako DEFAULT sa pouziva OPERATOR== avsak UNORDERED SET umoznuje pri vytvarani definovat CUSTOM EQUAL FUNCTION.
   G. UNORDERED SET umoznuje RYCHLE vkladanie ITEMS, aj ked POMALSIE ako SET. Je to dosledok toho, ze BUCKETS su ulozene v ARRAY.
   H. UNORDERED SET umoznuje RYCHLE odstranovanie ITEMS, aj ked POMALSIE ako vkladanie. Je to dosledok toho, ze BUCKETS su ulozene v ARRAY. Odstranovanie ITEMS z UNORDERED SET je vsak o nieco rychlejsie ako odstranovanie ITEMS z SET.
   !!!!! I. UNORDERED SET umoznuje v zavislosti na kvalite HASH FUNCTION RYCHLE vyhladanie ITEMS. Ak HASH FUNCTION vrati pre kazdy ITEM UNIKATNU VALUE, tak zlozitost vyhladavania je O(1). Ak HASH FUNCTION vrati pre kazdy ITEM ROVNAKU VALUE, tak zlozitost vyhladavania je O(N).
   !!!!! J. V UNORDERED SET NIE JE MOZNE zmenit hodnotu ITEM po jeho vlozeni do UNORDERED SET, pretoze inak by sa narusila vnuorna konzistencia dat a UNORDERED SET by sa stal nepouzitelnym.
   K. Pri odstranovani ITEMS sa REHASING vlozenych ITEMS nevykonava. Ten sa vykonava iba pri vkladani novych ITEMS.
23. Pre CLASS unordered_multiset<TItem> platia nasledujuce zasady.
   A. CLASS unordered_multiset<TItem> je definovana v LIBRARY <unordered_set>.
   B. UNORDERED MULTISET na rozdiel od UNORDERED SET umoznuje ulozenie viacerych ITEMS s ROVNAKOU hodnotou.
   C. ITEMS v UNORDERED MULTISET su UNORDERED. Ich poradie je nedefinovane a po vlozeni ci odstraneni ITEM sa pozicia moze zmenit.
   !!! D. UNORDERED MULTISET je interne realizovany ako HASH TABLE, ktora je implementovana ako DYNAMIC ARRAY. DYNAMIC ARRAY reprezentuje kolekciu HASH BUCKETS, kde kazdy HASH BUCKET je realizovany ako LINKED LIST.
   !!! E. ITEMS v UNORDERED MULTISET su ukladane do BUCKETS podla hodnoty HASH CODE, ktora sa vypocita aplikovanim HASH FUNCTION na hodnoty ITEMS. Ako DEFAULT sa pouziva TEMPLATE STRUCT [hash<TItem>] avsak UNORDERED MULTISET umoznuje pri vytvarani definovat CUSTOM HASH FUNCTION. TEMPLATE STRUCT [hash<TItem>] je implementovana pre vsetky PRIMITIVE TYPES ako aj pre viacere C++ STANDARD LIBRARY TYPES ako su [string], [wstring], [unique_ptr<T>], [shared_ptr<T>], [error_code], [type_index] ci [thread::id].
   !!! F. Na urcenie, ci ITEMS maju identicku hodnotu sa pouziva EQUAL FUNCTION. Ako DEFAULT sa pouziva OPERATOR== avsak UNORDERED MULTISET umoznuje pri vytvarani definovat CUSTOM EQUAL FUNCTION.
   G. UNORDERED MULTISET umoznuje RYCHLE vkladanie ITEMS, aj ked POMALSIE ako MULTISET. Je to dosledok toho, ze BUCKETS su ulozene v ARRAY.
   H. UNORDERED MULTISET umoznuje RYCHLE odstranovanie ITEMS, aj ked POMALSIE ako vkladanie. Je to dosledok toho, ze BUCKETS su ulozene v ARRAY. Odstranovanie ITEMS z UNORDERED MULTISET je vsak o nieco rychlejsie ako odstranovanie ITEMS z MULTISET.
   !!!!! H. UNORDERED MULTISET umoznuje v zavislosti na kvalite HASH FUNCTION RYCHLE vyhladanie ITEMS. Ak HASH FUNCTION vrati pre kazdy ITEM UNIKATNU VALUE, tak zlozitost vyhladavania je O(1). Ak HASH FUNCTION vrati pre kazdy ITEM ROVNAKU VALUE, tak zlozitost vyhladavania je O(N).
   !!!!! I. V UNORDERED MULTISET NIE JE MOZNE zmenit hodnotu ITEM po jeho vlozeni do UNORDERED SET, pretoze inak by sa narusila vnuorna konzistencia dat a UNORDERED MULTISET by sa stal nepouzitelnym.
   !!! J. V C++ 11 je GARANTOVANE, ze ak sa pridava do UNORDERED MULTISET ITEM, ktory ma rovnaku hodnotu ako ITEM, ktory sa uz v UNORDERED MULTISET nachadza, tak novopridany ITEM bude zaradeny az za VSETKY EXISTUJUCE ITEMS s rovnakou hodnotou.
   K. Pri odstranovani ITEMS sa REHASING vlozenych ITEMS nevykonava. Ten sa vykonava iba pri vkladani novych ITEMS.
24. Pre CLASS unordered_map<TKey,TValue> platia nasledujuce zasady.
   A. CLASS unordered_map<TKey,TValue> je definovana v LIBRARY <unordered_map>.
   B. UNORDERED MAP je mnozina ITEMS reprezentovanymi KEY-VALUE PAIRS, kde kazdy KEY musi mat rozdielnu hodnotu.
   C. ITEMS v UNORDERED MAP su UNORDERED. Ich poradie je nedefinovane a po vlozeni ci odstraneni ITEM sa pozicia moze zmenit.
   !!! D. UNORDERED MAP je interne realizovana ako HASH TABLE, ktora je implementovana ako DYNAMIC ARRAY. DYNAMIC ARRAY reprezentuje kolekciu HASH BUCKETS, kde kazdy HASH BUCKET je realizovany ako LINKED LIST.
   !!! E. ITEMS v UNORDERED MAP su ukladane do BUCKETS podla hodnoty HASH CODE, ktora sa vypocita aplikovanim HASH FUNCTION na hodnoty KEYS. Ako DEFAULT sa pouziva TEMPLATE STRUCT [hash<TItem>] avsak UNORDERED MAP umoznuje pri vytvarani definovat CUSTOM HASH FUNCTION. TEMPLATE STRUCT [hash<TItem>] je implementovana pre vsetky PRIMITIVE TYPES ako aj pre viacere C++ STANDARD LIBRARY TYPES ako su [string], [wstring], [unique_ptr<T>], [shared_ptr<T>], [error_code], [type_index] ci [thread::id].
   !!! F. Na urcenie, ci ITEMS maju identicku hodnotu sa pouziva EQUAL FUNCTION. Ako DEFAULT sa pouziva OPERATOR== avsak UNORDERED MAP umoznuje pri vytvarani definovat CUSTOM EQUAL FUNCTION.
   G. UNORDERED MAP umoznuje RYCHLE vkladanie ITEMS, aj ked POMALSIE ako MAP. Je to dosledok toho, ze BUCKETS su ulozene v ARRAY.
   H. UNORDERED MAP umoznuje RYCHLE odstranovanie ITEMS, aj ked POMALSIE ako vkladanie. Je to dosledok toho, ze BUCKETS su ulozene v ARRAY. Odstranovanie ITEMS z UNORDERED MAP je vsak o nieco rychlejsie ako odstranovanie ITEMS z MAP.
   !!!!! I. UNORDERED MAP umoznuje v zavislosti na kvalite HASH FUNCTION RYCHLE vyhladanie ITEMS. Ak HASH FUNCTION vrati pre kazdy ITEM UNIKATNU VALUE, tak zlozitost vyhladavania je O(1). Ak HASH FUNCTION vrati pre kazdy ITEM ROVNAKU VALUE, tak zlozitost vyhladavania je O(N).
   !!!!! J. V UNORDERED MAP NIE JE MOZNE zmenit hodnotu ITEM po jeho vlozeni do UNORDERED MAP, pretoze inak by sa narusila vnuorna konzistencia dat a UNORDERED MAP by sa stala nepouzitelnou.
   K. Pri odstranovani ITEMS sa REHASING vlozenych ITEMS nevykonava. Ten sa vykonava iba pri vkladani novych ITEMS.
25. Pre CLASS unordered_multimap<TKey,TValue> platia nasledujuce zasady.
   A. CLASS unordered_multimap<TKey,TValue> je definovana v LIBRARY <unordered_map>.
   B. UNORDERED MULTIMAP je mnozina ITEMS reprezentovanymi KEY-VALUE PAIRS.
   C. UNORDERED MULTIMAP na rozdiel od UNORDERED MAP umoznuje ulozenie viacerych ITEMS s ROVNAKOU hodnotou ich KEYS.
   D. ITEMS v UNORDERED MAP su UNORDERED. Ich poradie je nedefinovane a po vlozeni ci odstraneni ITEM sa pozicia moze zmenit.
   !!! D. UNORDERED MULTIMAP je interne realizovana ako HASH TABLE, ktora je implementovana ako DYNAMIC ARRAY. DYNAMIC ARRAY reprezentuje kolekciu HASH BUCKETS, kde kazdy HASH BUCKET je realizovany ako LINKED LIST.
   !!! E. ITEMS v UNORDERED MULTIMAP su ukladane do BUCKETS podla hodnoty HASH CODE, ktora sa vypocita aplikovanim HASH FUNCTION na hodnoty KEYS. Ako DEFAULT sa pouziva TEMPLATE STRUCT [hash<TItem>] avsak UNORDERED MULTIMAP umoznuje pri vytvarani definovat CUSTOM HASH FUNCTION. TEMPLATE STRUCT [hash<TItem>] je implementovana pre vsetky PRIMITIVE TYPES ako aj pre viacere C++ STANDARD LIBRARY TYPES ako su [string], [wstring], [unique_ptr<T>], [shared_ptr<T>], [error_code], [type_index] ci [thread::id].
   !!! F. Na urcenie, ci ITEMS maju identicku hodnotu sa pouziva EQUAL FUNCTION. Ako DEFAULT sa pouziva OPERATOR== avsak UNORDERED MULTIMAP umoznuje pri vytvarani definovat CUSTOM EQUAL FUNCTION.
   G. UNORDERED MULTIMAP umoznuje RYCHLE vkladanie ITEMS, aj ked POMALSIE ako MULTIMAP. Je to dosledok toho, ze BUCKETS su ulozene v ARRAY.
   H. UNORDERED MULTIMAP umoznuje RYCHLE odstranovanie ITEMS, aj ked POMALSIE ako vkladanie. Je to dosledok toho, ze BUCKETS su ulozene v ARRAY. Odstranovanie ITEMS z UNORDERED MULTIMAP je vsak o nieco rychlejsie ako odstranovanie ITEMS z MULTIMAP.
   !!!!! I. UNORDERED MULTIMAP umoznuje v zavislosti na kvalite HASH FUNCTION RYCHLE vyhladanie ITEMS. Ak HASH FUNCTION vrati pre kazdy ITEM UNIKATNU VALUE, tak zlozitost vyhladavania je O(1). Ak HASH FUNCTION vrati pre kazdy ITEM ROVNAKU VALUE, tak zlozitost vyhladavania je O(N).
   !!!!! J. V UNORDERED MULTIMAP NIE JE MOZNE zmenit hodnotu ITEM po jeho vlozeni do UNORDERED MULTIMAP, pretoze inak by sa narusila vnuorna konzistencia dat a UNORDERED MULTIMAP by sa stala nepouzitelnou.
   !!! K. V C++ 11 je GARANTOVANE, ze ak sa pridava do UNORDERED MULTIMAP ITEM, ktory ma rovnaku hodnotu KEY ako ITEM, ktory sa uz v UNORDERED MULTIMAP nachadza, tak novopridany ITEM bude zaradeny az za VSETKY EXISTUJUCE ITEMS s rovnakym KEY.
   L. Pri odstranovani ITEMS sa REHASING vlozenych ITEMS nevykonava. Ten sa vykonava iba pri vkladani novych ITEMS.
26. C++ CLASS [map<TKey,TValue>], CLASS [multimap<TKey,TValue>], CLASS [unordered_map<TKey,TValue>] a CLASS [unordered_multimap<TKey,TValue>] su oznacovane ako ASSOCIATIVE ARRAYS. ASSOCIATIVE ARRAYS maju nasledujuce vlastnosti.
   A. ASSOCIATIVE ARRAYS maju definovany OPERATOR[], ktorym je mozne pristupovat k ITEMS ASSOCIATIVE ARRAY.
   B. ASSOCIATIVE ARRAYS pouzitim OPERATOR[] pre ITEMS, ktore zatial neboli vlozene do ASSOCIATIVE ARRAYS vkladaju tieto ITEMS do ASSOCIATIVE ARRAYS.
   C. ASSOCIATIVE ARRAYS maju definovanu METHOD at(), ktora kontroluje ci ITEM bol vlozeny do ASSOCIATIVE ARRAY. Ak nebol, tak METHOD at() hodi EXCEPTION [out_of_range].
27. CLASS [string] a CLASS [wstring] je taktiez mozne povazovat za CONTAINERS nad CHARACTERS.
28. C-ARRAYS je taktiez mozne povazovat za CONTAINERS. Aj ked C-ARRAYS nemaju ziadne METHODS, C++ POINTERS sluzia ako ITERATORS nad C-ARRAYS co umoznuje aplikovat C++ ALGORITHMS.
29. C++ STANDARD LIBRARIES definuje CONTAINER ADAPTERS. CONTAINER ADAPTERS su CONTAINERS s obmedzenym INTERFACES, ktore na implementaciu vyuzivaju ine CONTAINERS. C++ STANDARD LIBRARIES definuje nasledujuce CONTAINER ADAPTERS.
   A. CLASS [priority_queue<TItem>] je QUEUE, ktora umoznuje ukladat ITEMS zoradene podla priority urcenych z hodnot ITEMS. Ako DEFAULT sa na porovnanie pouziva OPERATOR<, no je ho mozne zmenit pomocou TEMPLATE PARAMETER.
   B. CLASS [queue<TItem>] implementuje QUEUE.
   C. CLASS [stack<TItem>] implementuje STACK.
30. C++ STANDARD LIBRARY definuje CONTEPT ITERATOR, ktory umoznuje iterovat rozlicnymi typmi COLLECTIONS. ITERATOR definuje POZICIU v COLLECTION pomocou ktorej sa je v COLLECTION mozne pohybovat.
31. CONCEPT ITERATOR definuje INTERFACE, ktory musi COLLECTION implementovat, aby ITERATORS podporovala. INTERFACE pre ITERATORS pozostava z nasledujucich ELEMENTS, ktore musi KAZDY ITERATOR definovat.
   A. OPERATOR* umoznuje pristup k ITEM na ktory dany ITERATOR ukazuje. Implementacia OPERATOR* automaticky umoznuje pouzit OPERATOR-> na pristup k MEMBERS daneho ITEM.
   B. OPERATOR++ umoznuje posun na nasledujuci ITEM v COLLECTION. Niektore typy ITERATORS podporuju aj OPERATOR-- pre posun opacnym smerom.
   C. OPERATOR== a OPERATOR!= umoznuje porovnat dve ITERATORS ci odkazuju na ten isty ITEM.
   D. OPERATOR= umoznuje priradit jeden ITERATOR do ineho.
!!! 32. ITERATORS su casto implementovane ako INTERNAL CLASSES danej COLLECTION, ktore COLLECTION spristupnuje nasledujucimi METHODS.
   A. METHOD begin() vracia ITERATOR odkazujuci na 1. ITEM v COLLECTION.
   !!! B. METHOD end() vracia ITERATOR odkazujuci na 1 ITEM ZA KONCOM COLLECTION.
!!! 33. Fakt, ze METHOD end() vracia ITERATOR odkazujuci 1 ITEM ZA KONCOM COLLECTION umoznuje lahko riesit problem s prazdnymi COLLECTIONS, pretoze METHOD begin() a METHOD end() v tomto pripade vracaju ITERATOR odkazujuci na TEN ISTY NEEXISTUJUCI ITEM a tak cyklus, ktory porovnava CONDITION [while(begin()!=end())] okamzite skonci bez iteracie.
!!! 34. METHOD begin() a METHOD end() vracaju NON-CONST ITERATORS, ktore umoznuju menit hodnoty ITEMS danej COLLECTION.
!!! 35. V C++ 11 boli do STL COLLECTIONS pridane METHOD cbegin() a METHOD cend(), ktore vracaju CONST-ITERATORS, ktore NEUMOZNUJU menit hodnoty ITEMS danej COLLECTION.
!!! 36. C++ POINTERS splnaju ITERATOR INTERFACE a preto su taktiez legitimnymi ITERATORS.
37. ITERATORS definuju ako PREFIX tak aj POSTFIX verziu OPERATOR++ (resp. OPERATOR--). Pouzitie PREFIX verzie je spravidla o malicko RYCHLEJSIE, pretoze nie je nutne vytvorit TEMPORARY ITERATOR OBJECT, ktory POSTFIX verzia vracia ako RETURN VALUE.
38. RANGE-BASED FOR cyklus INTERNE vyuziva ITERATORS. RANGE-BASED FOR cyklus cez zadanu COLLECTION volanim METHOD begin() a METHOD end(), inkrementovanim pozicie pomocou OPERATOR++ a ulozeniu hodnoty ITEM (bud BY-VALUE, alebo BY-REFERENCE) pomocou OPERATOR*. RANGE-BASED FOR cyklus je len SYNTACTIC SUGAR nad ITERATORS.
39. ITERATORS podla sposobu iteracie je mozne rozdelit do nasledujucich kategorii.
   A. FORWARD ITERATORS su ITERATORS, ktore umoznuju iterovanie ITEMS len DOPREDU. Posun na nasledujuci ITEM sa robi pomocou OPERATOR++.
   B. BIDIRECTIONAL ITERATORS su ITERATORS, ktore umoznuju iterovanie ITEMS DOPREDU aj DOZADU. Posun na nasledujuci ITEM sa robi pomocou OPERATOR++. Posun na nasledujuci ITEM sa robi pomocou OPERATOR--.
   C. RANDOM ACCESS ITERATORS umoznuju INDEXOVY pristup ku ktoremukolvek ITEM. RANDOM ACCESS ITERATORS maju vlastnosti FORWARD ITERATORS aj BIDIRECTIONAL ITERATORS a zaroven poskytuju ITERATOR ARITHMETIC na odcitanie dvoch ITERATORS, pricitanie CONSTANT k ITERATOR ako aj porovnanie dvoch ITERATORS pomocou OPERATOR< a OPERATOR>.
40. ITERATORS je podla ACCESS RIGHTS k ITEMS mozne rozdelit do nasledujucich kategorii.
   A. INPUT ITERATORS su pocas iterovania schopne nacitavat a spracovavat hodnoty ITEMS.
   B. OUTPUT ITERATORS su ITERATORS su schopne schopne zapisovat hodnoty ITEMS.
41. LIBRARY <algorithm> implementuje subor ALGORITHMS, ktore vyuzivaju ITERATOR INTERFACE na realizaciu ALGORITHMS.
!!! 42. V C++ STANDARD LIBRARIES su ALGORITHMS implementovane NEZAVISLE na COLLECTIONS ako NON-MEMBER TEMPLATE FUNCTIONS. Tato architektura vychadza z idey GENERIC PROGRAMMING a ide PROTI PRINCIPOM OBJECT ORIENTED PROGRAMMING. Pouzitie tejto architektury ma nasledujuce dosledky.
   A. VYHODOU je, ze C++ STANDARD LIBRARY je mensia, pretoze odpada nutnost implementacie ALGORITHMS ako METHODS v kazdom type COLLECTION.
   B. NEVYHODOU je mensia intuitivnost pri pouzivani ALGORITHMS.
   !!! C. ZASADNOU NEVYHODOU je moznost aplikovat ALGORITHMS aj na COLLECTIONS, ktore pre dany ALGORITHM nie su vhodne. Vysledkom je NIZKA PERFORMACE pri vykonavani daneho ALGORITHM.
!!! 43. C++ ALGORITHMS VYZADUJU, aby ako PARAMETERS im boli zasielane ITERATOR RANGES. Pre ITERATOR RANGES v ALGORITHMS platia nasledujuce fakty.
   A. ITERATOR RANGES MUSIA byt zasielane ako HALF-OPEN RANGES <BEGIN_ITERATOR,END_ITERATOR). To znamena, ze ITEM na ktory referuje 'END_ITERATOR' NIE JE zahrnuty do spracovania v ALGORITHM a sluzi iba ako ZARAZKA oznacujuca, kedy ma ALGORITHM skoncit.
   !!! B. Ak sa do ALGORITHM zasle ITERATOR RANGE, ktoreho 'BEGIN_ITERATOR'>'END_ITERATOR', tak chovanie ALGORITHM je NEDEFINOVANE a moze skoncit LUBOVOLNOU RUNTIME ERROR.
   !!! C. Urcenie, ktory z dvojice ITERATORS v ITERATOR RANGE je pre NON-RANDOM ACCESS ITERATORS nemoze bez iteracie ITEMS, a preto PROGRAM, ktory chce pouzivat C++ ALGORITHMS by mal byt koncipovany tak, aby UZ pri vyhladavani ITERATORS tvoriacich ITERATOR RANGE bolo mozne urcit, ktory z ITERATORS bude predstavovat 'BEGIN_ITERATOR' a ktory 'END_ITERATOR'.
   D. Pouzitie HALF-OPEN ITERATOR RANGES umoznuje bezproblemove spracovanie EMPTY RANGES. Pri ich spracovani nie je potrebne specialne osetrenie, pretoze pre ITERATOR RANGE [ITERATOR,ITERATOR) plati, ze (ITERATOR!=ITERATOR)==FALSE a tym padom sa ALGORITHM nevykona.
   E. Niektore ALGORITHMS vyzaduju zasielanie dvoch ITERATOR RANGES. Tieto ALGORITHMS vyzaduju zaslanie BEGIN_ITERATOR a END_ITERATOR prvej COLLECTION a iba BEGIN_ITERATOR druhej COLLECTION. Pocet ITEMS v druhej COLLECTION sa urci z rozdielu BEGIN_ITERATOR a END_ITERATOR prvej COLLECTION. Ak druha COLLECTION nema dostatocny pocet ITEMS je cinnost ALGORITHM UNDEFINED.
44. C++ definuje viacero ITERATOR ADAPTERS, ktore vyuzivaju existujuce ITERATORS na definovanie novych ITERATORS s pozmenenou funkcnostou. ITERATOR ADAPTERS napriklad umoznuju pouzit BIDIRECTIONAL ITERATORS na realizovane REVERSE ITERATORS.
45. C++ definuje ITERATOR ADAPTERS pomocou, ktorych je mozne definovat nasledujuce ITERATORS.
   A. INSERT ITERATORS.
   B. STREAM ITERATORS.
   C. REVERSE ITERATORS.
   D. MOVE ITERATORS.
46. INSERT ITERATORS su ITERATORS, ktore namiesto ITEROVANIA ITEMS pri pristupe k ITEMS ich pridavaju do COLLECTION nad ktorou pracuju. Pre INSERT ITERATORS platia nasledujuce vlastnosti.
   A. Pri pristupe k ITEM na ktory odkazuje ITERATOR je novy ITEM vlozeny do COLLECTION a jeho referencia je vratena ako hodnota na ktoru ITERATOR referuje.
   B. OPERATOR++ je pri INSERT ITERATORS je implementovany ano NO-OPERATIONS OPERATION. Teda je to prazdna FUNCTION, ktora nic nerobi.
47. C++ STANDARD LIBRARY podporuje nasledujuce typy INSERT ITERATORS.
   A. BACK INSERT ITERATOR implementovany ako CLASS [back_inserter] vklada nove ITEMS na koniec COLLECTION pomocou METHOD push_back(), ktoru UNDERLYING COLLECTION musi implementovat.
   B. FRONT INSERT ITERATOR implementovany ako CLASS [front_inserter] vklada nove ITEMS na koniec COLLECTION pomocou METHOD front_back(), ktoru UNDERLYING COLLECTION musi implementovat.
   C. GENERAL INSERT ITERATOR implementovany ako CLASS [inserter] vklada nove ITEMS na poziciu v COLLECTION urcenu 2. PARAMETER CLASS [inserter]. Vkladanie ITEMS je realizovane pomocou METHOD insert(), ktoru UNDERLYING COLLECTION musi implementovat.
48. STREAM ITERATORS vytvaraju abstrakciu nad STREAMS, ktore umoznuje citat a zapisovat do STREAMS, ako keby STREAMS boli COLLECTIONS. STREAM ITERATORS je mozne rozdelit do nasledujucich kategorii.
   A. INPUT STREAM ITERATORS implementuju ITERATORS nad INPUT STREAMS z ktorych je mozne citat VALUES. INPUT STREAM ITERATORS pri pristupe k UNDERLYING STREAM pouzivaju OPERATOR>>.
   B. OUTPUT STREAM ITERATORS implementuju ITERATORS nad OUTPUT STREAMS do ktorych je mozne zapisovat VALUES. OUTPUT STREAM ITERATORS pri pristupe k UNDERLYING STREAM pouzivaju OPERATOR<<.
!!! 49. Interne STREAM ITERATORS pri iterovani volaju OPERATOR>> (INPUT STREAM ITERATORS), alebo OPERATOR>> (OUTPUT STREAM ITERATORS), az kym sa pri iterovani nedosiahne koniec STREAM, alebo nedojde k ERROR.
50. REVERSE ITERATORS umoznuju iterovat COLLECTIONS v obratenom poradi. Pre REVERSE ITERATORS platia nasledujuce fakty.
   A. REVERSE ITERATORS su implementovane pomocou CLASS [reverse_iterator<TType>].
   B. COLLECTIONS, ktore implementuju REVERSE ITERATORS musia implementovat METHOD rbegin(), METHOD crbegin(), METHOD rend() a METHOD crend(), ktore vracaju instancie REVERSE ITERATORS.
   C. METHOD rbegin() a METHOD rbegin() vracaju odkaz na POSLEDY ITEM v COLLECTION.
   D. METHOD rend() a METHOD crend() vracaju poziciu PRED PRVYM ITEM v COLLECTION.
   E. REVERSE ITERATORS iteruju pomocou OPERATOR++, ktorym sa prechadza od POSLEDNEHO ITEM k PRVEMU ITEM.
   F. REVERSE ITERATORS implementuju aj OPERATOR--, ktorym sa prechadza opacnym smerom, teda dopredu ako klasicke ITERATORS.
51. MOVE ITERATORS pocas iterovania vykonavaju MOVE ITEMS, ktorymi ITERATORS iteruju. Pre MOVE ITERATORS platia nasledujuce fakty.
   A. MOVE ITERATORS su implementovane pomocou CLASS [move_iterator<TType>].
   B. MOVE ITERATORS pocas iterovania vykonavaju MOVE ITEMS, ktorymi ITERATORS iteruju.
!!!!! 52. Modifikacne ALGORITHMS ako napriklad ALGORITHM remove() sa vdaka tomu, ze jedinym ITERFACE, ktore voci COLLECTIONS maju su ITERATORS chovaju neocakavane.
   A. ALGORITHM remove() prechadza COLLECTION definovanu ITERATOR RANGE a odstranuje z nej ITEMS, ktore maju rovnaku hodnotu ako PARAMETER ALGORITHM.
   !!!!! B. Problem je v tom, z kedze ALGORITHM remove() je GENERICKY a jedinym INTERFACE cez ktory s COLLECTION pracuje su ITERATORS, ALGORITHM NEMOZE odstranovat ITEMS z COLLECTION volanim METHOD danej COLLECTION. Ak by sa o to pokusil, narusil by filozofiu ALGORITHMS nezavislych na COLLECTION ku ktorym pristupuje vyhradne cez ITERATORS.
   !!!!! C. V dosledku pouzitia ITERATORS ako jedineho INTERFACE ALGORITHM remove() v skutocnosti pri odstranovani ITEMS z COLLECTION NEMENI VELKOST COLLECTION, ale iba presuva ITEMS tak, aby sa v nich vyradene ITEMS nenachadzali. ALGORITHM remove() zaroven vracia NOVY END ITERATOR urcujuci novy koniec COLLECTION. CODE volajuci ALGORITHM remove() ak chce odstranit prebytocne ITEMS z COLLECTION je zodpovedny za nasledujuce volanie CUSTOM METHOD danej COLLECTION (METHOD erase()), aby znizil dlzku COLLECTION.
!!!!! 53. Modifikacne ALGORITHMS ako napriklad ALGORITHM remove() NIE JE MOZNE POUZIT na ORDERED a UNORDERED ASSOCIATIVE ARRAYS, pretoze tieto ALGORITHMS pri svojej cinnosti modifikuju hodnoty ITEMS ich kopirovanim a posunmi v ramci COLLECTION. Napriklad ALGORITHM remove() namiesto skutocneho odstranovania ITEMS iba presuva ITEMS v COLLECTION tak, aby vylucil, alebo presunul na koniec COLLECTION tie ITEMS, ktore maju byt odstranene. Avsak pri tomto presune dochadza k ZMENE VALUES tychto ITEMS. Zmena VALUES ITEMS (resp. KEYS) vsak v ORDERED a UNORDERED ASSOCIATIVE ARRAYS NIE JE POVOLENA, inak by doslo k naruseniu ich vnutornej struktury. Vysledkom je NEMOZNOST pouzitia modifikacnych ALGORITHMS pre ORDERED a UNORDERED ASSOCIATIVE ARRAYS. Riesenim je pouzit METHODS ORDERED a UNORDERED ASSOCIATIVE ARRAYS namiesto ALGORITHMS.
!!! 54. Modifikacne ALGORITHMS ako napriklad ALGORITHM remove() mozu byt v porovnani s METHODS danych COLLECTION EXTREMNE POMALE, a preto je VZDY VYHODNEJSIE ak COLLECTION METHOD implementujucu dany ALGORITHM definuje pouzit namiesto pouzitia ALGORITHM. Prikladom EXTREMNE ZLEJ PERFORMANCE je ALGORITHM remove(), ktory v skutocnosti NEVYKONAVA ODSTRANOVANIE ITEMS, ale iba PRESUN ITEMS, ktore v COLLECTION MAJU po REMOVE OSTAT. To vedie v COLLECTIONS ako napriklad list<TItem> k EXTREMNE POMALEJ PERFORMANCE, pretoze sa kopiruje CELA COLLECTION. Naproti tomu METHOD list<TItem>::remove() NEKOPIRUJE ITEMS, ale iba ODSTRANUJE TIE ITESM, ktore MAJU BYT ODSTRANENE.
55. Viacero ALGORITHMS vyzaduje FUNCTIONS ako PARAMETERS. Tieto FUNCTIONS potom ALGORITHM vola pre jednotlive ITEMS na vykonanie nejakej akcie, ako predikat ci na porovnanie hodnot jednotlivych ITEMS.
56. Viacero ALGORITHMS vyzaduje, aby FUNCTIONS zaslane ako PARAMETERS reprezentovali PREDICATES. Pre PREDICATES platia nasledujuce fakty.
   A. PREDICATES mozu byt UNARNE, alebo BINARNE. UNARNE PREDICATES prijimaju 1 PARAMETER. BIARNE PREDICATES prijimaju 2 PARAMETRE.
   B. PREDICATES musia VZDY vracat BOOL RETURN VALUE.
   C. PREDICATES MUSIA byt STATELESS. To znaci, ze si nesmu uchovavat vlastny stav a RETURN VALUE NESMIE byt zavisla od nicoho ineho iba vstupnych PARAMETERS.
57. FUNCTIONS, ktore su zasielane ako PARAMETERS do ALGORITHMS je najoptimalnejsie definovat ako LAMBDA FUNCTIONS. Pouzitie LAMBDA FUNCTIONS vedie k citatelnejsiemu CODE a umoznuje C++ lepsie optimalizovat generovany CODE.
58. LAMBDA FUNCTIONS je nevhodne pouzit ako FUNCTIONS, ktore su zasielane ako PARAMETERS do ALGORITHMS ak je nutne aby tieto FUNCTIONS mali vlastny STATE od ktoreho zavisi ich cinnost. LAMBDA FUNCTIONS by STATE mohli ukladat iba do svojich PARAMETERS prenasanych BY-REFERENCE co by viedlo k obskurnemu dizajnu. V pripade nutnosti udrziavat STATE je namiesto LAMBDA FUNCTIONS lepsie pouzit FUNCTION OBJECTS.
59. FUNCTION OBJECT je CLASS, ktora definuje OPERATOR(). FUNCTION OBJECT reprezentuje CALLABLE OBJECT a moze byt pouzita vsade tam, kde mozu byt pouzite ine CALLABLE OBJECTS ako su FUNCTIONS, METHODS, LAMBDA FUNCTIONS.
60. FUNCTION OBJECTS maju na rozdiel od ostatnych typov CALLABLE OBJECTS nasledujuce vyhody.
   A. FUNCTION OBJECTS kedze su v skutocnosti CLASSES mozu mat vlastny vnutorny STATE, pricom 2 instancie toho isteho FUNCTION OBJECT TYPE maju ROZDIELNE STATES. To umoznuje implementaciu sofistikovanejsich algoritmov.
   B. Kazdy FUNCTION OBJECT predstavuje specificky TYPE co je mozne s vyhodou pouzit v GENERIC PROGRAMMING. Bezne FUNCTIONS na rozdiel od FUNCTION OBJECTS sa lisia v TYPE iba ak sa lisia vo svojich PARAMETERS.
   C. FUNCTION OBJECTS dokaze COMPILER spravidla LEPSIE OPTIMALIZOVAT, pretoze ma o FUNCTION OBJECTS viac informacii ako napriklad o FUNCTION, ktora je prenasana ako POINTER na FUNCTION. POINTERS na FUNCTION je nemozne optimalizovat, zatial co pri FUNCTION OBJECTS ma COMPILER moznosti na optimalizaciu.
61. LIBRARY <functional> definuje sadu preddefinovanych FUNCTION OBJECTS, ktore obaluju C++ BINARY a UNARY OPERATORS.
   A. STRUCT [not_fn<TType>] definuje FUNCTION OBJECT, ktory vracia komplementarnu hodnotu k tej ktoru vratil FUNCTION OBJECT, ktory STRUCT [not_fn] obaluje.
   B. STRUCT [plus<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR+.
   C. STRUCT [minus<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR-.
   D. STRUCT [multiples<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR*.
   E. STRUCT [modulus<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR%.
   F. STRUCT [negate<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ UNARY OPERATOR-.
   G. STRUCT [equal_to<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR==.
   H. STRUCT [not_equal_to<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR!=.
   I. STRUCT [greater<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR>.
   J. STRUCT [less<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR<.
   K. STRUCT [greater_equal<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR>=.
   L. STRUCT [less_equal<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR<=.
   M. STRUCT [logical_and<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR&&.
   N. STRUCT [logical_or<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR||.
   O. STRUCT [logical_not<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ UNARY OPERATOR!.
   P. STRUCT [bit_and<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR&.
   Q. STRUCT [bit_or<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR|.
   R. STRUCT [bit_xor<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ BINARY OPERATOR^.
   S. STRUCT [bit_not<TType>] definuje FUNCTION OBJECT, ktory obaluje C++ UNARY OPERATOR~.
62. FUNCTION bind() umoznuje mapovat jednotlive PARAMETERS CALLABLE OBJECTS tak, ze RETURN VALUE predstavuje CALLABLE OBJECT, ktora uz ma namapovane prislusne PARAMETERS na definovane hodnoty. Pre FUNCTION bind() platia nasledujuce zasady.
   A. FUNCTION bind() mapuje PARAMETERS CALLABLE OBJECT pricom vracia CALLABLE OBJECT, ktory vola povodny CALLABLE OBJECT uz s namapovanymi PARAMETERS.
   B. FUNCTION bind() existuje v 2 verziach, kde druha verzia umoznuje definovat RETURN VALUE TYPE, ktory ma novovytvoreny CALLABLE OBJECT vracat.
   !!! C. V NAMESPACE [std::placeholders] je definovanych 'N' PLACEHOLDERS. PLACEHOLDERS identifikuju PARAMETERS CALLABLE OBJECT, ktory FUNCTION bind() vracia ako RETURN VALUE. PLACEHOLDERS sa pouzivaju na urcenie, kde sa maju pouzit PARAMETERS novovytvoreneho CALLABLE OBJECT pri volani povodneho CALLABLE OBJECT.
   !!!!! D. PLACEHOLDERS sluzia ako PARAMETERS NOVODEFINOVANEHO CALLABLE OBJECT, ktory FUNCTION bind() vracia. To znaci, ze ak povodna FUNCTION ma napriklad 6 PARAMETERS a vo FUNCTION bind() sa definuju 2 PLACEHOLDERS, tak CALLABLE OBJECT, ktory FUNCTION bind() vrati ako RETURN VALUE bude mat 2 PARAMETERS. PLACEHOLDERS urcuju kde sa PARAMETERS NOVODEFINOVANEHO CALLABLE OBJECT pouziju pri volani povodneho CALLABLE OBJECT.
   E. FUNCTION bind() sa casto pouziva v spojeni s preddefinovanymi FUNCTION OBJECTS, ktore su definovane v LIBRARY <functional>, umoznujuc tak vytvarat komplexne FUNCTIONS OBJECTS s namapovanymi PARAMETERS.
   !!! F. FUNCTION bind() je mozne pouzit aj na volanie METHODS, kde PLACEHOLDER [_1] reprezentuje THIS POINTER.
   !!! G. Podla poctu PLACEHOLDERS moze vrateny CALLABLE OBJECT mat aj VIAC PARAMETERS ako povodny CALLABLE OBJECT, ktory volanim FUNCTION bind() sa zapuzdruje. Napriklad z FUNCTION, ktora ma 2 PARAMETRE je mozne spravit CALLABLE OBJECT s 3. PARAMETERS, kde 2. a 3. PLACEHOLDER sa scitavaju.
63. ITEMS umiestnovane do C++ CONTAINERS MUSIA splnat nasledujuce podmienky, aby do CONTAINERS mohli byt umiestnene.
   A. ITEMS MUSIA byt COPYABLE, alebo MOVEABLE. Kedze ITEMS su v COLLECTIONS ulozene BY-VALUE, pri ukladani ITEMS do COLLECTION sa vyuzivaju COPY a MOVE OPERATIONS.
   B. ITEMS MUSIA mat implementovany bud COPY OPERATR=, alebo MOVE OPERATOR=. OPERATOR= sa pouziva pri presune ITEMS v ramci COLLECTION napriklad po operacii RESIZE, ktora je vyvolana bud volani METHOD daneho CONTAINER, alebo pri prekroceni intrnej kapacity, kedy je treba zvacsit rozsah interneho BUFFER.
   C. ITEMS MUSIA byt DETROYABLE. To znaci, ze MUSIA mat verejne pristupny CONSTRUCTOR.
64. Niektore operacie nad COLLECTIONS kladu specialne poziadavky na ITEMS.
   A. Operacia RESIZE v pripade, ze pri nej vznika miesto pre nove ITEMS vyzaduje, aby ITEMS mali verejne pristupny EMPTY CONSTRUCTOR. Tento sa pouzije pri vytvaranie novovzniknutych ITEMS.
   B. Niektore operacie ako napriklad SEARCH vyzaduju aby ITEMS mali definovany OPERATOR==.
   C. ASSOCIATIVE CONTAINERS a operacie typu SORT vyzaduju aby ITEMS mali definovany OPERATOR<.
   D. UNORDERED ASSOCIATIVE CONTAINERS vyzaduju aby ITEMS (resp. KEYS) mali definovanu HASH FUNCTION a ich vnutorny STATE sa NEMENIL.
!!! 65. ITEMS su v COLLECTION VZDY umiestnovane BY-VALUE. Ak je do CONTAINERS nutne umiestnit ITEMS BY-REFERENCE je mozne ulozit ich ako POINTERS na ITEMS, alebo SHARED POINTERS na ITEMS. Ulozenie REFERENCES na ITMES do COLLECTIONS NIE JE MOZNE.
!!! 66. Kedze C++ STANDARD LIBRARY CONTAINERS boli vytvorene s dorazom na maximalny vykon, CONTAINERS vykonavaju iba MINIMUM ERROR CHECKING. Pouzitie CONTAINERS je teda potencialne rizikove, pretoze nespravne pouzitie nevedie k vzniku EXCEPTION, ale k UNDEFINED BEHAVIOR, co spravidla znamena PAD PROGRAMU.
67. Niektore METHODS C++ STANDARD LIBRARY CONTAINERS vykonavaju detekciu ERRORS.
   A. METHOD vector<TItem>::at() vykonava kontrolu ci INDEX nie je OUT OF RANGE a ak je tak generuje EXCEPTION [out_of_range].
   B. METHOD reserve() viacerych CONTAINERS hodi EXCEPTION [length_error], ak dojde k pokusu rezervovat vacsi pocet ITEMS ako je definovane METHOD max_size().
   C. Vsetky METHODS, ktore alokuju MEMORY mozu hodit EXCEPTION [bad_alloc].
68. Ak ITEMS ukladane do C++ STANDARD LIBRARY CONTAINERS hodia EXCEPTIONS pri vykonavani OPERATIONS, ktore nad ITEMS CONTAINERS vykonavaju (volanie CONSTRUCTORS, OPERATOR=, OPERATOR==, OPERATOR<, HASH FUNCTION), tak C++ STANDARD LIBRARY CONTAINERS poskytuju vzhladom na tieto EXCEPTIONS nasledujuce garancie.
   A. METHOD erase(), METHOD clear(), METHOD pop_back(), METHOD pop_front a FUNCTION swap() NEGENERUJU EXCEPTIONS.
   B. COPY CONSTRUCTORS a OPERATOR= pre ITERATORS, ktore vratili C++ STANDARD LIBRARY CONTAINERS NEGENERUJU EXCEPTIONS.
   C. NODE BASED CONTAINERS (LISTS, FORWARDS LISTS, SETS, MULTISETS, MAPS, MULTIMAPS, UNORDERED SETS, UNORDERED MULTISETS, UNORDERED MAPS, UNORDERED MULTIMAPS) ponechavaju CONTAINER ne nezmenenom stave ak doslo pri vytvarani noveho NODE k vzniku EXCEPTION.
   D. NODE BASED CONTAINERS (LISTS, FORWARDS LISTS, SETS, MULTISETS, MAPS, MULTIMAPS, UNORDERED SETS, UNORDERED MULTISETS, UNORDERED MAPS, UNORDERED MULTIMAPS) garanuju ze REMOVE OPERATIONS NEGENERUJU EXCEPTIONS.
   E. ASSOCIATIVE CONTAINERS (SETS, MULTISETS, MAPS, MULTIMAPS) garantuju, ze ak SINGLE INSERT OPERATIONS zlyhaju, pretoze ITEM generoval EXCEPTION, tak CONTAINERS ostanu v nezmenenom stave.
   F. UNORDERED ASSOCIATIVE CONTAINERS (UNORDERED SETS, UNORDERED MULTISETS, UNORDERED MAPS, UNORDERED MULTIMAPS) garantuju, ze ak SINGLE INSERT OPERATIONS zlyhaju, pretoze ITEM generoval EXCEPTION, tak CONTAINERS ostanu v nezmenenom stave. Podmienkou vsak je, aby HASH FUNCTION daneho CONTAINER negenerovala EXCEPTION.
   G. ASSOCIATIVE CONTAINERS (SETS, MULTISETS, MAPS, MULTIMAPS) garantuju, ze REMOVE OPERATIONS SINGLE i MULTIPLE NEGENERUJU EXCEPTION.
   H. UNORDERED ASSOCIATIVE CONTAINERS (UNORDERED SETS, UNORDERED MULTISETS, UNORDERED MAPS, UNORDERED MULTIMAPS) garantuju, ze REMOVE OPERATIONS SINGLE i MULTIPLE NEGENERUJU EXCEPTION. Podmienkou vsak je, aby HASH FUNCTION daneho CONTAINER negenerovala EXCEPTION.
   I. Pre LISTS VSETKY OPERATIONS okrem OPERATIONS REMOVE, REMOVE_IF, MERGE, SORT a UNIQUE plati ze ak ITEMS generuju EXCEPTION, tak CONTAINERS ostanu v nezmenenom stave.
   J. Pre FORWARD LISTS OPERATIONS INSERT_AFTER, EMPLACE_AFTER a PUSH_FRONT plati, ze ak ITEMS generuju EXCEPTION, tak CONTAINERS ostanu v nezmenenom stave.
   !!! K. Pre ARRAY-BASED CONTAINERS (ARRAY, VECTOR, DEQUEUE) INSERT OPERATIONS NEGARANTUJU, ze v pripade, ze ITEM generuje EXCEPTION ponechaju COLLECTIONS v povodnom stave. Tieto CONTAINERS teda NIE JE mozne pouzit na implementaciu COMMIT-ROLLBACK sematiky.
   L. Pre ARRAY-BASED CONTAINERS (ARRAY, VECTOR, DEQUEUE) PUSH a POP OPERATIONS ak su vykonavane na konci COLLECTION GARANTUJU, ze ak ITEMS hodia EXCEPTION, tak CONTAINERS ostanu v nezmenenom stave.
   !!! L. Pre ARRAY-BASED CONTAINERS (ARRAY, VECTOR, DEQUEUE) v pripade ze ITEMS NEGENERUJU EXCEPTIONS pre COPY CONSTRUCTOR, MOVE CONSTRUCTORS, COPY OPERATOR= a MOVE OPERATOR= tak CONTAINERS GARANTUJU, ze v pripade ze dojde k vzniku EXCEPTION (naprikad pre problem s alokaciou MEMORY), tak CONTAINERS ostanu v nezmenenom stave.
69. CLASS [list<TItem>] zo vsetkych C++ STANDARD LIBRARY CONTAINERS poskytuje najvacsie garancie, ze v pripade vzniku EXCEPTIONS ostane CONTAINER v nezmenenom stave.
70. C++ STANDARD LIBRARY CONTAINERS kvoli PERFORMANCE NEOBSAHUJU VIRTUAL METHODS, a preto nema zmysel, aby sluzili ako BASE CLASSES. Pri vytvarani novych CONTAINERS je lepsie pouzit WRAPPERS okolo C++ STANDARD LIBRARY CONTAINERS.
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
Pouzitie PLACEHOLDERS.

1. FUNCTION XXX() ma 4 PARAMETERS.

   void XXX(int, int, int, int).

2. Nasledujuci CODE vytvori NOVY CALLABLE OBJECT, ktory bude mat 2 PARAMETERS. PARAMETERS FUNCTION bind() maju nasledujuci vyznam.
   A. PARAMETER 'XXX' reprezentuje CALLABLE OBJECT, ktory ma novovytvoreny CALLABLE OBJECT obalovat.
   B. PARAMETER '100' reprezentuje 1. PARAMETER FUNCTION XXX(). Pri volani CALLABLE OBJECT 'CallableObject' bude 1. PARAMETER FUNCTION XXX() VZDY subsitutovany hodnotou 100.
   C. PARAMETER '_1' reprezentuje 2. PARAMETER FUNCTION XXX(). Kedze sa pouzil PLACEHOLDER [_1], tak pri volani CALLABLE OBJECT 'CallableObject' bude tento PLACEHOLDER nahradeny 1. PARAMETER pouzitym pri volani CALLABLE OBJECT 'CallableObject'.
   D. PARAMETER '_2' reprezentuje 3. PARAMETER FUNCTION XXX(). Kedze sa pouzil PLACEHOLDER [_2], tak pri volani CALLABLE OBJECT 'CallableObject' bude tento PLACEHOLDER nahradeny 2. PARAMETER pouzitym pri volani CALLABLE OBJECT 'CallableObject'.
   E. PARAMETER '200' reprezentuje 4. PARAMETER FUNCTION XXX(). Pri volani CALLABLE OBJECT 'CallableObject' bude 4. PARAMETER FUNCTION XXX() VZDY subsitutovany hodnotou 200.

   auto															CallableObject=bind(XXX,100,_1,_2,200).

3. Nasledujuci CODE pouziva vytvoreny CALLABLE OBJECT. Kedze vo FUNCTION bind() sa pouzili PLACEHOLDERS [_1] a [_2], tak CALLABLE OBJECT 'CallableObject' ma 2 PARAMETERS.

   CallableObject(777,888).

4. Predchadzajuci CODE sa interpretuje ako nasledujuce volanie FUNCTION XXX().

   XXX(100,777,888,200).
//-------------------------------------------------------------------------------------------------------