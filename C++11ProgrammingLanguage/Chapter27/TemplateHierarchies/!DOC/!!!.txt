//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje TEMPLATES HIERARCHIES v C++.
2. Ak C++ CLASSES, tak aj C++ TEMPLATES poskytuju prostriedky pre pridavanie funkcionality do svojej zakladnej ENTITY (BASE CLASS, PRIMARY TEMPLATE).
   A. CLASS INHERITANCE umoznuje rozsirit funkcionalitu BASE CLASS pridanim novych FIELDS a METHODS.
   B. TEMPLATE SPECIALIZATION umoznuje rozsirit funkcionalitu PRIMARY TEMPLATE modifikaciou jej funkcnosti, alebo struktury (v pripade TEMPLATE CLASSES).
3. C++ umoznuje kombinovat CLASS INHERITANCE a TEMPLATE SPECIALIZATION. To znaci, ze je mozne definovat CLASS TEMPLATES, ktore su DERIVED z inych CLASS TEMPLATES a zaroven vytvarat pre ne TEMPLATE SPECIALIZATIONS modifikujuce ich funkcionalitu.
!!! 4. C++ NEUMOZNUJE definovat VIRTUAL TEMPLATE METHODS.
5. Ak CLASS [CDerived1] dedi z CLASS [CBase], tak C++ NEUMOZNUJE konverziu [vector<CDerived1*>] na [vector<CBase*>], pretoze nasledne by do CLASS [vector<CBase*>] mohla byt vlozena instancia napriklad CLASS [CDerived2] a tym by VECTOR [vector<CBase*>] povodne vytvoreny pre CLASSES [CDerived1] mohol obsahovat aj instancie CLASS [CDerived2]. C++ vsak, v pripade, ze je to nutne, umoznuje definovat CUSTOM CONVERSIONS.
6. Ak CLASS [CDerived1] dedi z CLASS [CBase], tak C++ NEUMOZNUJE IMPLICITNU konverziu z [CDerived1**] na [CBase**], pretoze do VARIABLE typu [CBase**] by bolo mozne ulozit instanciu napriklad CLASS [CDerived2]. To by znamenalo, ze do VARIABLE typu [CDerived1] by mohla byt ulozena instancia [CDerived2] co C++ neumoznuje.
!!! 7. Ak CLASS [CDerived] dedi z CLASS [CBase], C++ vykonava IMPLICITNU konverziu z [CDerived*] na [CBase*]. Problem je, ak VARIABLE typu [CDerived*] odkazuje na ARRAY. Takuto VARIABLE C++ je schopny IMPLICITNE konvertovat na ARRAY obsahujuci instancie [CDerived], kedze C++ NEDOKAZE rozpoznat rozdiel medzi ARRAY a NON-ARRAY VARIABLE. Problem nastava v tom, ze pri prenose ARRAY typu [CDerived] do FUNCTION, ktora ocakava ARRAY typu [CBase] bude C++ predpokladat, ze kazdy ARRAY ITEM ma SIZEOF(CBase). Ak vsak CLASS [CDerived] obsahuje dalsie FIELDS, dojde k CHYBNEMU PRISTUPU k MEMORY. Ak je potrebne do FUNCTION preniest ARRAY objektov [CDerived] je ich nutne prenasat ako POINTERS [CDerived*] a cele ARRAY ako POINTER na POINTER [CDerived**].
!!! 8. Pri vytvarani TEMPLATE SPECIALIZATIONS je mozne aby TEMPLATE SPECIALIZATION dedila z INEJ TEMPLATE SPECIALIZATION, napriklad TEMPLATE SPECIALIZATION pre [TType*] z TEMPLATE SPECIALIZATION pre [void*]. Vdaka tomu DERIVED TEMPLATE SPECIALIZATION ziskava vsetky PROTECTED a PUBLIC MEMBERS z BASE TEMPLATE SPECIALIZATION.
!!! 9. C++ UMOZNUJE, aby TEMPLATE CLASS dedil zo svojho TYPE PARAMETER.
10. Ak BASE CLASS potrebuje mat pristup k datam z DERIVED CLASS, je mozne vyuzit kombinaciu TEMPLATE CLASSES a CLASS INHERITANCE na spristupnenie tychto dat. Techniku je mozne implementovat v nasledujucich krokoch.
   A. Definuje sa BASE CLASS TEMPLATE, ktorej TYPE PARAMETER reprezentuje DERIVED CLASS. METHODS BASE CLASS TEMPLATE mozu prostrednictvom TYPE PARAMETER pristupovat k datam DERIVED CLASS.
   B. Definuje sa DERIVED CLASS TEMPLATE, ktorej TYPE PARAMETER reprezentuje DATA, ktore ma DERIVED CLASS obsahovat.
   !!! C. KLUCOVE je, aby DERIVED CLASS TEMPLATE dedila z BASE CLASS TEMPLATE, pricom ako TYPE PARAMETER definuje samotnu DERIVED CLASS TEMPLATE. Vdaka tomu bude mat BASE CLASS TEMPLATE pristup k datam z DERIVED CLASS TEMPLATE a to BEZ NUTNOSTI pouzit VIRTUAL METHODS, ktore su casovo narocnejsie na vykonanie.
//-------------------------------------------------------------------------------------------------------