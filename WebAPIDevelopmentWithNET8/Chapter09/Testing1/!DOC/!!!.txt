//----------------------------------------------------------------------------------------------------------------------
1. SOLUTION demonstruje UNIT TESTING v ASP.NET CORE.
2. V ASP.NET CORE je mozne realizovat nasledujuce typy TESTS.
   A. UNIT TESTING. Pri UNIT TESTING sa testuju jednotlive METHODS, alebo CLASSES, ako nezavisle entity. UNIT TESTS casto vyuzivaju MOCK OBJECTS simulujuce funkcionalitu externych systemov.
   B. INTEGRATION TESTING. Pri INTEGRATION TESTING sa testuje interakcia medzi roznym komponentami CODE ci spolocne funguju podla ocakavania. INTEGRATION TESTS tiez mozu vyuzivat MOCK OBJECTS simulujuce funkcionalitu externych systemov.
   C. END TO END TESTING. Pri END TO END TESTING je testovany cely PROGRAM z USER PERSPECTIVE. To znamena, ze sa simuluje interakcia USER s USER INTERFACE a ci vysledky tejto interakcie splnaju ocakavania.
   D. LOAD TESTING. Pri LOAD TESTING sa testuje ocakavana zataz PROGRAMU, ci ju dokaze PROGRAM zvladnut.
   E. STRESS TESTING. Pri STRESS TESTING sa vykonava testovanie PROGRAMU pri rozlicnej zatazi, vratane daleko vyssej zatazi ako sa realne ocakava. Zistuje sa ci PROGRAM pri extremnej zatazi negeneruje chyby.
   F. PERFORMANCE TESTING. Pri PERFORMANCE TESTING sa testuje PROGRAM pri rozlicnej zatazi, pricom sa analyzuju RESPONSE TIME, THROUGHPUT ci RESOURCE USAGE. Sucastou PERFORMANCE TESTING su aj USER ACCEPTANCE TESTING, kde sa overuje ci zodpoveda ocakavanej funkcionalite v PRODUCTION-LIKE ENVIRONMENT.
3. UNIT TESTS sa v .NET CORE realizuju pomocou FRAMEWORK [xUNIT].
4. FRAMEWORK [xUNIT] vyzaduje nasledujuce PACKAGES.
   A. PACKAGE [coverlet.collector].
   B. PACKAGE [Microsoft.NET.Test.Sdk].
   C. PACKAGE [xunit].
   D. PACKAGE [xunit.runner.visualstudio].
5. UNIT TESTS sa realizuju v nasledujucich krokoch.
   A. V UNIT TEST PROJECT sa vytvara CLASS, ktora obsahuje UNIT TESTS.
   B. Pre kazdy UNIT TEST sa vytvara METHOD danej CLASS. METHOD musi byt oznacena ATTRIBUTE [Fact] a obsahuje CODE daneho UNIT TEST.
   C. Ak UNIT TEST zbehne uspesne, METHOD skonci bez hodenia EXCEPTION. Ak UNIT TEST zlyha, METHOD musi hodit EXCEPTION, cim sa demonstruje zlyhanie UNIT TESTU.
6. UNIT TESTS su spravidla realizovane pomocou ARRANGE, ACT, ASSERT PATTERN. Tento PATTERN ma nasledujuce PHASES.
   A. PHASE [ARRANGE]. Je to cast UNIT TEST CODE, kde sa pripravuju testovacie data a pripravuje sa TEST ENVIRONMENT na vykonanie UNIT TESTU.
   B. PHASE [ACT]. Je to cast UNIT TEST CODE, kde sa vola METHOD, ktora ma byt testovana.
   C. PHASE [ASSERT]. Je to cast UNIT TEST CODE, kde sa kontroluje ci testovana METHOD vratila ocakavane RESULTS.
7. V PHASE [ASSERT] je na kontrolu RESULTS odporucane pouzit CLASS [Assert].
8. Vo VISUAL STUDIO sa TEST spustaju pomocou COMMAND [Test->Test Explorer].
9. Z COMMAND LINE je mozne TESTS spustat nasledujucimi COMMANDS.
   A. COMMAND [dotnet test] spusti vsetky UNIT TESTS a vypise zakladny LOG.
   B. COMMAND [dotnet test --verbosity normal] spusti vsetky UNIT TESTS a vypise podrobnejsi LOG.
10. MOCKING je proces vytvarania testovacich OBJECTS, ktore simuluju cinnost OBJECTS v UNIT TESTS.
11. MOCKING v .NET je implementovany v PACKAGE [Moq].
12. S PACKAGE [Moq] sa pracuje nasledujucim sposobom.
   A. MOCK OBJECT ma TYPE [Mock<TMock>] a vytvara sa pomocou DEFAULT CONSTRUCTOR.
   !!! B. MOCK OBJECT vracia vytvoreny OBJECT v PROPERTY [Mock<TMock>.TMock Object].
   C. CUSTOM METHOD v MOCK OBJECT sa definuje pomocou METHOD [ISetup<TMock,TResult> Setup<TResult>(Expression<Func<TMockType,TResult>> Expression)].
   D. CUSTOM METHOD definuje RETURN VALUE pomocou METHOD [IReturnsResult<TMock> ReturnsAsync<TMock,TResult>(this IReturns<TMock,Task<TResult>> Mock, TResult Value)].
   E. CUSTOM METHOD definuje EXCEPTION, ktoru ma hodit pomcoou METHOD [Task<TException> ThrowsAsync<TException>(Func<Task> TestCode)].
   F. Validaciu ci doslo k volaniu CUSTOM METHOD daneho MOCK OBJECT je mozne vykonat pomocou METHOD [void Mock<TMock>.Verify(Expression<Action<TMock>> Expression, Func<Times> Times)].
13. CLASS [Assert] definuje mnozinu STATIC METHODS, ktore umoznuju kontrolu vysledkov UNIT TESTS.
   A. METHOD [void Assert.Equal(EXPECTED,ACTUAL)] kontroluje ci VALUE [EXPECTED] a VALUE [ACTUAL] su zhodne. Ak nie, METHOD generuje EXCEPTION.
   B. METHOD [void Assert.NotEqual(EXPECTED,ACTUAL)] kontroluje ci VALUE [EXPECTED] a VALUE [ACTUAL] su rozdielne. Ak nie, METHOD generuje EXCEPTION.
   C. METHOD [void Assert.StrictEqual(EXPECTED,ACTUAL)] kontroluje ci VALUE [EXPECTED] a VALUE [ACTUAL] su zhodne. Ak nie, METHOD generuje EXCEPTION. Pre porovnanie sa pouziva DEFAULT COMPARER daneho TYPE.
   D. METHOD [void Assert.NotStrictEqual(EXPECTED,ACTUAL)] kontroluje ci VALUE [EXPECTED] a VALUE [ACTUAL] su rozdielne. Ak nie, METHOD generuje EXCEPTION. Pre porovnanie sa pouziva DEFAULT COMPARER daneho TYPE.
   E. METHOD [void Assert.Same(EXPECTED,ACTUAL)] kontroluje ci VALUE [EXPECTED] a VALUE [ACTUAL] odkazuju na ten isty OBJECT. Ak nie, METHOD generuje EXCEPTION.
   F. METHOD [void Assert.NotSame(EXPECTED,ACTUAL)] kontroluje ci VALUE [EXPECTED] a VALUE [ACTUAL] odkazuju na rozdielne OBJECTS. Ak nie, METHOD generuje EXCEPTION.
   G. METHOD [void Assert.True(CONDITION)] kontroluje ci CONDITION [CONDITION] ma VALUE [true]. Ak nie, METHOD generuje EXCEPTION.
   H. METHOD [void Assert.False(CONDITION)] kontroluje ci CONDITION [CONDITION] ma VALUE [false]. Ak nie, METHOD generuje EXCEPTION.
   I. METHOD [void Assert.Null(OBJECT)] kontroluje ci OBJECT [OBJECT] obsahuje VALUE [null]. Ak nie, METHOD generuje EXCEPTION.
   J. METHOD [void Assert.NotNull(OBJECT)] kontroluje ci OBJECT [OBJECT] neobsahuje VALUE [null]. Ak nie, METHOD generuje EXCEPTION.
   K. METHOD [void Assert.IsType(EXPECTED_TYPE,OBJECT)] kontroluje ci OBJECT [OBJECT] je TYPE [EXPECTED_TYPE]. Ak nie, METHOD generuje EXCEPTION.
   L. METHOD [void Assert.IsNotType(UNEXPECTED_TYPE,OBJECT)] kontroluje ci OBJECT [OBJECT] nie je TYPE [UNEXPECTED_TYPE]. Ak nie, METHOD generuje EXCEPTION.
   M. METHOD [void Assert.IsAssignableFrom(EXPECTED_TYPE,OBJECT)] kontroluje ci OBJECT [OBJECT] je TYPE [EXPECTED_TYPE], alebo niektory z DERIVED TYPES TYPE [EXPECTED_TYPE]. Ak nie, METHOD generuje EXCEPTION.
   N. METHOD [void Assert.Contains(EXPECTED_OBJECT,COLLECTION)] kontroluje ci COLLECTION [COLLECTION] obsahuje OBJECT [EXPECTED_OBJECT]. Ak nie, METHOD generuje EXCEPTION.
   O. METHOD [void Assert.DoesNotContain(EXPECTED_OBJECT,COLLECTION)] kontroluje ci COLLECTION [COLLECTION] neobsahuje OBJECT [EXPECTED_OBJECT]. Ak nie, METHOD generuje EXCEPTION.
   P. METHOD [void Assert.Empty(COLLECTION)] kontroluje ci COLLECTION [COLLECTION] je prazdna. Ak nie, METHOD generuje EXCEPTION.
   Q. METHOD [void Assert.NotEmpty(COLLECTION)] kontroluje ci COLLECTION [COLLECTION] nie je prazdna. Ak nie, METHOD generuje EXCEPTION.
   R. METHOD [void Assert.Single(COLLECTION)] kontroluje ci COLLECTION [COLLECTION] obsahuje presne 1 ELEMENT daneho TYPE. Ak nie, METHOD generuje EXCEPTION.
   S. METHOD [void Assert.InRange(ACTUAL,LOW,HIGH)] kontroluje ci VALUE [ACTUAL] je v RANGE <LOW,HIGH>. Ak nie, METHOD generuje EXCEPTION.
   T. METHOD [void Assert.NotInRange(ACTUAL,LOW,HIGH)] kontroluje ci VALUE [ACTUAL] nie je v RANGE <LOW,HIGH>. Ak nie, METHOD generuje EXCEPTION.
   U. METHOD [void Assert.Throws<ExceptionType>(ACTION)] kontroluje ci METHOD [ACTION] hodi EXCEPTION TYPE [ACTION]. Ak nie, METHOD generuje EXCEPTION.
   V. METHOD [void Assert.ThrowsAny<ExceptionType>(ACTION)] kontroluje ci METHOD [ACTION] hodi EXCEPTION TYPE [ACTION], alebo EXCEPTION, ktora je DERIVED z EXCEPTION TYPE [ACTION]. Ak nie, METHOD generuje EXCEPTION.
14. LIBRARY FLUENT ASSERTIONS poskytuje alternativnu implementaciu funkcionality, ktoru poskytuje CLASS [Assert]. Pre FLUENT ASSERTION platia nasledujuce fakty.
   A. LIBRARY FLUENT ASSERTIONS je implementovana v PACKAGE [FluentAssertions].
   B. LIBRARY FLUENT ASSERTIONS poskytuje alternativnu implementaciu METHODS CLASS [Assert].
   C. LIBRARY FLUENT ASSERTIONS poskytuje citatelnejsie API, ktore umoznuje pisat prehladnejsie UNIT TESTS.
   D. LIBRARY FLUENT ASSERTIONS umoznuje definovat CUSTOM MESSAGES, ak dany ASSERT zlyha, cim sa lepsie hladaju ERRORS v CODE.
15. Medzi CLASS [Assert] a LIBRARY FLUENT ASSERTIONS existuje nasledujuce mapovanie STATIC ASSERT METHODS.
   A. METHOD [Assert.Equal(EXPECTED,ACTUAL)] sa mapuje na METHOD [ACTUAL.Should().Be(EXPECTED)].
   B. METHOD [Assert.NotEqual(EXPECTED,ACTUAL)] sa mapuje na METHOD [ACTUAL.Should().NotBe(EXPECTED)].
   C. METHOD [Assert.True(CONDITION)] sa mapuje na METHOD [CONDITION.Should().BeTrue()].
   D. METHOD [Assert.False(CONDITION)] sa mapuje na METHOD [CONDITION.Should().BeFalse()].
   E. METHOD [Assert.Null(OBJECT)] sa mapuje na METHOD [OBJECT.Should().BeNull()].
   F. METHOD [Assert.NotNull(OBJECT)] sa mapuje na METHOD [OBJECT.Should().NotBeNull()].
   G. METHOD [Assert.Contains(EXPECTED,COLLECTION)] sa mapuje na METHOD [COLLECTION.Should().Contain(EXPECTED)].
   H. METHOD [Assert.DoesNotContain(EXPECTED,COLLECTION)] sa mapuje na METHOD [COLLECTION.Should().NotContain(EXPECTED)].
   I. METHOD [Assert.Empty(COLLECTION)] sa mapuje na METHOD [COLLECTION.Should().BeEmpty()].
   J. METHOD [Assert.NotEmpty(COLLECTION)] sa mapuje na METHOD [COLLECTION.Should().NotBeEmpty()].
   K. METHOD [Assert.Throws<TException>(ACTION)] sa mapuje na METHOD [ACTION.Should().Throw<TException>()].
   L. METHOD [Assert.DoesNotThrow(ACTION)] sa mapuje na METHOD [ACTION.Should().NotThrow()].
16. DATABASE CODE je mozne testovat nasledujucimi sposobmi.
   A. Pouzit IN MEMORY DATABASE pomocou DB PROVIDER [InMemoryDatabase]. Tento DB PROVIDER ma viacere obmedzenia ako napriklad nepodpora TRANSACTIONS ci RAW SQL QUERIES.
   B. Pouzit IN MEMORY DATABASE pomocou DB PROVIDER [SQLite]. Tento DB PROVIDER ma niektore obmedzenia voci inym DB PROVIDERS, a preto sa na nom nedaju testovat vsetky funkcionality DB.
   C. Po realnu DATABASE. Pri pouziti realnej DATABASE je mozne testovat kazdu funkcionalitu, no za cenu nizsej vykonnosti a nutnosti zmazat testovacie data, ktore boli do DATABASE pocas testovania zapisane.
17. Pri testovani DATABASE CODE nad realnou DATABASE vznikaju nasledujuce problemy.
   A. DATABASE musi byt po kazdom teste uvedena do povodneho stavu, to znamena vratit zmeny, ktore TEST v DATABASE vykonal, aby jeden TEST neovplyvnoval ostatne TESTS.
   B. TESTS mozu bezat paralelne, a preto je pri realizovani TESTS nutne aplikovat THREAD SAFETY.
18. Problemy vzniknute pri testovani DATABASE CODE nad realnou DATABASE je mozne riesit aplikovanim TEST FIXTURE PATTERN. Pre TEST FIXTURE PATTERN platia nasledujuce fakty.
   !!! A. FIXTURE CLASS je CLASS, ktorej instancia je SHARED medzi vsetkymi UNIT TESTS v ramci tej istej UNIT TESTS COLLECTION.
   B. TESTING LIBRARY [xUnit] definuje HELPER INTERFACE [IClassFixture<TFixtureClass>], ktory umoznuje implementovat TEST FIXTURE PATTERN.
   C. HELPER INTERFACE [IClassFixture<TFixtureClass>] vyzaduje implementaciu FIXTURE CLASS, ktora musi splnat nasledujuce podmienky.
      A. Implementovat METHOD INITIALIZE DATABASE, ktora vytvara TEST DATABASE a a nainicializuje ju naplnenim TEST DATA.
      !!! B. Implementovat DEFAULT CONSTRUCTOR, ktory THREAD SAFE sposobom vytvori pri prvom volani zavola METHOD INITIALIZE DATABASE na vytvorenie a inicializovanie DATABASE.
   D. UNIT TEST CLASS musi implementovat HELPER INTERFACE [IClassFixture<TFixtureClass>].
   E. Pomocou CONSTRUCTOR DEPENDENCY INJECTION sa do UNIT TEST CLASS instancia FIXTURE CLASS.
   !!! F. V UNIT TEST METHODS sa pouzije FIXTURE CLASS na vytvorenie ENTITY FRAMEWORK DB CONTEXT.
19. TESTING LIBRARY [xUnit] umoznuje pre UNIT TESTS deklarativne definovat TEST DATA. TEST DATA sa definuju nasledujucim sposobom.
   A. UNIT TEST METHOD je oznacena ATTRIBUTE [Theory] namiesto ATTRIBUTE [Fact].
   B. UNIT TEST METHOD definuje <1,N> instancii ATTRIBUTE [InlineData], ktory obsahuje INLINE DATA. ATTRIBUTE [InlineData] moze obsahovat viacero VALUES, kde kazda VALUE sa prenesie do TEST METHOD ako PARAMETER.
   C. UNIT TEST METHOD definuje PARAMETERS, ktorych pocet sa rovna poctu VALUES v ATTRIBUTE [InlineData]. PARAMETERS musia mat TYPE na ktory je danu VALUE mozne konvertovat.
   !!! D. Kedze TEST DATA su ukladane v ATTRIBUTE [InlineData] a ATTRIBUTES umoznuju iba ukladane data PRIMITIVE TYPES, tymto sposobom nie je mozne prenasat do TEST METHODS instancie CUSTOM CLASSES a CUSTOM STRUCTURES.
20. TESTING LIBRARY [xUnit] podporuje implementaciu INTERFACE [IDisposable] v UNIT TEST CLASSES. Pre implementacia INTERFACE [IDisposable] v UNIT TEST CLASSES platia nasledujuce fakty.
   A. UNIT TEST CLASSES mozu implementovat INTERFACE [IDisposable], kde v METHOD [void Dispose()] mozu implementovat lubovolny CLEANUP CODE.
   B. TESTING LIBRARY [xUnit] pre kazdu UNIT TEST METHOD v danej UNIT TEST CLASS vytvara novu instanciu UNIT TEST CLASS, pricom pri skonceni UNIT TEST METHOD, TESTING LIBRARY [xUnit] AUTOMATICKY zavola METHOD [void IDisposable.Dispose()], ktora moze vykonat lubovolny CLEANUP CODE.
21. Pre PARALELIZMUS vykonavania UNIT TESTS v TESTING LIBRARY [xUnit] platia nasledujuce fakty.
   A. UNIT TESTS su organizovane do UNIT TESTS COLLECTIONS.
   !!! B. Vsetky UNIT TESTS v ramci 1 UNIT TESTS COLLECTION bezia SEKVENCNE. To znamena, ze pre kazdy UNIT TEST sa vytvara nova instancia UNIT TEST CLASS, ktora po skonceni UNIT TEST je uvolnena volanim METHOD [void IDisposable.Dispose()], ak UNIT TEST CLASS INTERFACE [IDisposable] implementuje.
   !!! C. UNIT TESTS beziace v ramci rozdielnych UNIT TESTS COLLECTIONS bezia PARALELNE.
   !!!!! D. Pre UNIT TESTS beziace ramci tej istej UNIT TESTS COLLECTION su vytvorene SHARED INSTANCES FIXTURE CLASES. Instancie FIXTURE CLASES su teda zdielane medzi vsetkymi UNIT TESTS v ramci jednej UNIT TESTS COLLECTION.
   !!!!! E. BY DEFAULT, 1 UNIT TEST CLASS tvori 1 UNIT TESTS COLLECTION. To znamemna, ze BY-DEFAULT UNIT TESTS beziace v ramci 1 UNIT TEST CLASS bezia SEKVENCNE.
   F. Ak nevyhovuje funkcionalita TESTING LIBRARY [xUnit], kde kazda UNIT TEST CLASS predstavuje nezavislu UNIT TESTS COLLECTION, je mozne toto chovanie zmenit implementaciou CUSTOM UNIT TESTS COLLECTION. CUSTOM UNIT TESTS COLLECTION sa implementuje nasledujucim sposobom.
      A. Definuje sa FIXTURE CLASS, ktora ma byt SHARED medzi viacerymi UNIT TEST CLASSES v ramci 1 UNIT TESTS COLLECTION.
      B. Pre FIXTURE CLASS sa definuje sa FIXTURE COLLECTION CLASS. FIXTURE COLLECTION CLASS sa definuje nasledujucim sposobom.
         A. FIXTURE COLLECTION CLASS musi implementovat INTERFACE ICollectionFixture<TFixtureClass>, kde TYPE [TFixtureClass] reprezentuje TYPE FIXTURE CLASS.
         B. Na FIXTURE COLLECTION CLASS sa aplikuje ATTRIBUTE [CollectionDefinition], ktory definuje NAME FIXTURE COLLECTION.
      C. Na vsetky UNIT TEST CLASSES, ktore maju byt v tej istej UNIT TESTS COLLECTION a maju zdielat tu istu instanciu FIXTURE CLASS sa aplikuje ATTRIBUTE [Collection], ktoreho NAME je zhodny s NAME FIXTURE COLLECTION.
      !!!!! D. Pre tieto UNIT TEST CLASSES bude vytvorena iba 1 spolocna instancia FIXTURE CLASS a vsetky TESTS v tejto UNIT TESTS COLLECTION budu vykonavane SEKVENCNE.
//----------------------------------------------------------------------------------------------------------------------