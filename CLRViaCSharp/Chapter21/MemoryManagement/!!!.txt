//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje MEMORY MANAGEMENT v .NET.
2. CLR vyuziva MANAGED HEAP na alokovanie OBJECTS. OBJECTS po tom, ako prestanu byt pouzivane su AUTOMATICKY odstranene z MEMORY pomocou nechanizmu GARBAGE COLLECTION (GC).
3. CLR pracuje s OBJECTS nasledujucim sposobom.
   A. MEMORY pre OBJECT sa alokuje CLR INSTRUCTION [newobj], ktora sa generuje pri pouziti C# KEYWORD [new].
   B. OBJECT, ktory danu MEMORY reprezenuje sa inicializuje volanim CONSTRUCTOR.
   C. Po inicializacii je OBJECT mozne pouzivat.
   D. Ak sa OBJECT sa prestane pouzivat, moze byt uvolneny z MEMORY. Toto sa moze stat bude tym, ze na dany OBJECT NEBUDE refereovat ZIADNA VARIABLE.
   E. OBJECT je pomocou GARBAGE COLLECTOR (GC) uvolneny z MEMORY.
!!! 4. C# ak sa nepouziva KEYWORD [unsafe], VZDY generuje CODE, ktory vykonava BEZPECNY pristup k MEMORY zabranujuci MEMORY LEAKS ci pristupu k uvolnenej, alebo nenainicializovanej MEMORY.
5. Pre TYPES, ktore pouzivaju UNMANAGED RESORUCES a potrebuju EXPLICITNE UVOLNENIE z MEMORY, CLR definuje DISPOSE PATTERN. Dany TYPE ho moze realizovat implementaciou INTERFACE IDisposable.
!!! 6. CLR alokuje MEMORY po REGIONS. REGION je MEMORY BLOCK z ktoreho MEMORY HEAP alokuje MEMORY. Ak sa REGION zaplni, CLR alokuje dalsi REGION.
7. Alokacia MEMORY je vykonavana MSIL INSTRUCTION [newobj], ktora vykonava nasledujucu cinnost.
   A. Vypocita sucet velkosti VSETKYCH FIELDS, ktore obsahuje dany TYPE (a jeho BASE TYPES), ktoreho instancia sa ma vytvorit.
   B. K vypocitanej dlzke sa prirata POINTER SIZE pre 2 FIELDS (REFERENCIU na TYPE OBJECT a SYNC BLOCK INDEX).
   C. Z MANAGED HEAP sa alokuje MEMORY. Ta sa alokuje tak, ze v aktualnom REGION sa zisti ci je dostatok MEMORY (ak nie, alokuje sa dalsi) a POINTER ukazujuci na zaciatkom volnej MEMORY 'NewObjPtr' sa posunie o POCET BYES vypocitanych v bodoch A a B.
   !!! D. Ak pri pridelovani MEMORY PRESIAHNE MAXIMALNU VELKOST MEMORY, ktora bola pridelena danej GC GENERATION, tak CLR spusti GC, ktory nepouzitu MEMORY uvolni a nasledne vykona MEMORY COMPACTION, aby tvorila jednotny MEMORY BLOCK.
!!! 8. Kedze alokacia MEMORY z MANAGED HEAP znamena len posunutie POINTER 'NewObjPtr', alokacia je mimoriadne RYCHLA.
9. GC ALGORITHM je tvoreny nasledujucimi krokmi.
   A. MARKING. Oznacia sa OBJECTS, na ktore NIE JE REFEROVANA ZIADNA VARIABLE a teda tieto OBJECTS moze byt uvolnene z MEMORY.
   B. COMPACTING. Odstranuje diery v HEAP, ktore vznikli po uvolnenych OBJECT. OBJECTS sa v MEMORY posuvaju tak, aby vzniknute diery zarovnali. Zaroven sa opravuju aj REFERENCES na zijuce OBJECTS, tak aby REFERENCES aj po posune daneho OBJECT v MEMORY odkazovali na spravne ADDRESSES.
!!! 10. VARIABLE ROOT je lubovolna VARIABLE, alebo FIELD, ktory referuje na OBJECT. Ak OBJECT ma svoj priamy (priamy odkaz), alebo nepriamy (ako FIELD OBJECT na ktory referuje ROOT) ROOT, potom NEMOZE byt odstraneny z MEMORY. Informacie ci dany OBJECT je REFERRED je ziskana z pomocnych TABLES, ktore su vytvarane pomocou JIT COMPILATION.
11. GC ALGORITHM sa vykonava nasledujucim sposobom.
   A. GC pozastavi VSETKY THREADS.
   B. GC zacne MARKING PHASE nastavenim MARKING BIT (je sucastou SYNC BLOCK INDEX) na FALSE pre VSETKY OBJECTS. To znaci, ze KAZDY OBJECT je oznaceny ako OBJECT urceny na odstranenie z MEMORY.
   !!! C. JIT COMPILER pri COMPILATION do MSIL INSTRUCTIONS do NATIVE CODE generuje interne TABLES, ktore obsahuju ktore ROOTS (VARIABLES, FIELDS) su pre dany CALL STACK platne a teda OBJECTS na ktore referuju maju ostat v MEMORY. Tieto tabulky sa vyuzivaju v procese MARKING a to tak, ze sa REKURZIVNE prechadza CELY CALL STACK daneho THREADU a na zaklade udajov v tabulkach a znalosti pozicie kde sa IP register nachadza dokaze GC urcit vsetky ROOTS.
   !!! D. Pre vsetky ROOTS sa zistia OBJECTS na ktore referuju. Pre tieto OBJECTS je nastaveny MARKING BIT na TRUE, cim sa zabrani GC, aby ich odstranil. Ak dany OBJECT ma FIELDS, ktore referuju na ine OBJECTS, tak sa REKURZIVNE prejdu vsetky tieto FIELDS a aj pre OBJECTS na ktore referuju je nastaveny MARKING BIT na TRUE. Ak MARKING BIT daneho OBJECT uz je nastaveny na TRUE, tak sa tato REKURZIA NEVYKONAVA, cim sa zabranuje vzniku nekonecneho cyklu.
   E. OBJECTS, ktore maju MARKING BIT nastaveny na FALSE su povazovane za OBJECTS, ktore mozu byt odstranene.
   F. GC zacne COMPATION PHASE tym, ze posunie vsetky OBJECTS tak, aby vyplnili medzery v HEAP, ktore vznikli uvolnenim nepouzivanych OBJECTS.
   G. GC nasledne posunie VARIABLE a FIELDS REFERENCES tak, aby referovali na OBJECTS aj po ich posune v MEMORY.
   H. GC spusti VSETKY THREADS.
!!! 12. Jednym zo zmyslov rozdelenia TYPES na VALUE a REFERENCE TYPES je fakt, ze IBA REFERENCE TYPES su predmetom vykonania GC.
!!! 13. STATIC VARIABLES predstavuju ROOTS (tj. OBJECTS na ktore sa referuju nemozu byt uvolnene z MEMORY), az kym nie je uvolnena APP DOMAIN, ktora TYPE obsahujuci dane STATIC VARIABLES vytvorila.
!!!!! 14. Pre LOCAL VARIABLES plati, ze stracaju platnost (a teda mozu byt uvolnene GC) OKAMZITE po POSLEDNEJ MSIL INSTRUCTION, ktora danu LOCAL VARIABLE pouzila. To znamena, ze OBJECT moze byt predmetom GC dokonca aj v PRIEBEHU vykonavania METHOD (tj. pred jej skoncenim), ak sa v dalsom CODE uz na LOCAL VARIABLE, ktora sa referuje na dany OBJECT viac CODE neodkazuje. Toto KOMPLIKUJE proces DEGUGGING, a preto v DEBUG verzii JIT COMPILER UMELO PREDLZUJE platnost LOCAL VARIABLES az do SKONCENIA tela danej METHOD.
15. CLR GARBAGE COLLECTOR je GENERATION GARBAGE COLLECTOR. Pre GENERATION GARBAGE COLLECTOR platia nasledujuce fakty.
   A. GENERATION GC ma 3 GENERATIONS.
   B. Novovytvorene OBJECTS su ulozene do GENERATION 0. V GENERATION 0 su ulozene OBJECTS, ktore este neboli predmetom GARBAGE COLLECTIONS.
   C. Kazda GENERATION ma stanoveny limit, ktory ked je prekroceny spusti sa GARBAGE COLLECTOR, ktory odstrani nepouzite OBJECTS a vykona HEAP COMPACTION.
   D. VSETKY OBJECTS, ktore pocas GARBAGE COLLECTION neboli odstrane su presunute do vyssej GENERATION. To znaci, ze OBJECTS v GENERATION 0 sa presunu do GENERATION 1 a OBJECTS v GENERATION 1 sa presunu do GENERATION 2. OBJECTS v GENERATION 2 uz ostavaju v GENERATION 2 permanente az pokym ich CODE neprestane pouzivat.
   E. Po vykonani GARBAGE COLLECTION nad GENERATION 0 je GENERATION 0 PRAZDNA.
   F. Po vykonani GARBAGE COLLECTION nad GENERATION 1 je GENERATION 1 PRAZDNA.
   !!! G. GARBAGE COLLECTOR obsahuje specialnu optimalizaciu, ktorej cielom je, aby GARBAGE COLLECTOR nemusel pri COMPACTION jednej GENERATION kontrolovat aj OBJECTS z inych GENERATIONS ci nereferuju na OBJECTS v GENERATION, ktora je COMPACTED. GARBAGE COLLECTOR nastavuje specialny BIT pre tie OBJECTS, ktorych FIELDS sa zmenili od poslednej GARBAGE COLLECTION co prinuti GARBAGE COLLECTOR, aby tieto OBJECTS skontroloval ci nie su ROOTS.
   !!! H. GARBAGE COLLECTOR pri GENERATION 1 a GENERATION 2 NESPUSTA GARBAGE COLLECTION OKAMZITE po tom co dana GENERATION prekroci limit. GARBAGE COLLECTION sa pre GENERATION 1 spusta az vtedy, ked sa okrem GENERATION 1 naplni aj GENERATION 0. To znaci, ze ak sa vykona GARBAGE COLLECTION GENERATION 0, ktora sposobi pri presune OBJECTS do GENERATION 1 jej naplnenie, tak GARBAGE COLLECTION sa spusti az ked sa naplni GENERATION 0. V tomto pripade sa spusti GARBAGE COLLECTION pre GENERATION 0 aj GENERATION 1. Podobna analogia plati aj pre GENERATION 2, ktora sa spusti iba ak sa zaplnia VSETKY 3 GENERATIONS.
   !!! I. GARBAGE COLLECTOR je schopny DYNAMICKY menit svoje parameter. Napriklad ak GARBAGE COLLECTOR detekuje, ze dana GENERATION po GARBAGE COLLECTION uvolni velke mnozstvo MEMORY, moze zmensit limit pre danu GENERATION. Naopak, ak GARBAGE COLLECTOR detekuje, ze dana GENERATION po GARBAGE COLLECTION uvolni male mnozstvo MEMORY, moze zvacsit limit pre danu GENERATION.
   J. Ak GARBAGE COLLECTOR nedostatok MEMORY, tak vykona FULL GARBAGE COLLECTION nad vsetkymi GENERATIONS a ak ani potom nie je uvolnene dostatocne mnozstvo MEMORY generuje EXCEPTION [OutOfMemoryException].
16. CLR moze GARBAGE COLLECTIOR spustit v nasledujucich pripadoch.
   A. Limit pre danu GENERATION je prekroceny.
   B. Pri zavolani METHOD GC.Collect().
   C. Ak WINDOWS oznami CLR, ze detekoval nedostatok MEMORY.
   D. Ak je APP DOMAIN ukoncena. V tomto pripade su vsetky OBJECTS vytvorene pre danu APP DOMAIN odstranene a CLR vykona GARBAGE COLLECTION nad vsetkymi GENERATIONS.
   E. CLR sa vypne pri ukonceni PROCESS. V tomto pripade je vykonana GARBAGE COLLECTION nad vsetkymi GENERATIONS, aby OBJECTS mali moznost uvolnit RESOURCES. V tomto pripade vsak CLR nevykonava HEAP COMPACTION.
!!! 17. OBJECTS, ktora maju velkost viac ako 85000 BYTES su spracovavane inak ako ostatne OBJECTS. Pre tieto LARGE OBJECTS platia nasledujuce zasady.
   A. LARGE OBJECTS nie su ulozene v MANAGED HEAP, ale v specialnej HEAP nazvanej LARGE OBJECT HEAP (LOH).
   !!! B. LARGE OBJECTS NIE SU COMPACTED. Dovodom je ze COMPACTION by bola prilis pomala. NEVYHODOU je, ze tym, ze sa nerobi COMPACTION moze dojst k FRAGMENTATION, ktory moze sposobit hodenie EXCEPTION [OutOfMemoryException].
   C. LARGE OBJECT HEAP je sucastou GENERATION 2 a LARGE OBJECTS su OKAMZITE ukladane do GENERATION 2.
   !!!!! D. .NET od verzie 4.5.1. podporuje COMPACTION LARGE OBJECT HEAP.
!!!!! 18. .NET od verzie 4.5.1. podporuje COMPACTION LARGE OBJECT HEAP pomocou PROPERTY GCSettings.LargeObjectHeapCompactionMode, ktora moze mat nasledujuce hodnoty.
   A. VALUE [Default] znamena, ze COMPACTION LARGE OBJECT HEAP je VYPNUTA.
   !!!!! B. VALUE [CompactOnce] znamena, ze COMPACTION LARGE OBJECT HEAP bude vykonana pri nasledujucom FULL GARBAGE COLLECTION. Nasledne bude hodnota PROPERTY GCSettings.LargeObjectHeapCompactionMode vratana na hodnotu [Default].
19. CLR podporuje nasledujuce MODES vykonavania GARBAGE COLLECTION.
   A. WORKSTATION MODE umoznuje, aby iba 1 THREAD vykonaval GARBAGE COLLECTION pre cely PROGRAM. Toto je DEFAULT MODE optimalizovany na CLIENT-SIDE PROGRAMS.
   B. SERVER MODE umoznuje aby VIACERO THREADS PARALELNE VYKONAVALO GARBAGE COLLECTION. HEAP je v tomto rezime rozdelena na SECTIONS podla poctu CPU a pre kazdy CPU je vytvoreny specialny THREAD, ktory vykonava GARBAGE COLLECTION NEZAVISLE na OSTATNYCH THREADS. Vdaka tomu je GARBAGE COLLECTION daleko rychlejsi. Pri tomto MODE CLR predpoklada, ze na pocitaci bezi iba 1 PROGRAM. Tento MODE je mozne pouzit IBA ak ma SYSTEM VIACERO CPU. Pri 1 CPU CLR automaticky pouzije WORKSTATION MODE.
20. CLR podporuje nasledujuce SUB-MODES vykonavania GARBAGE COLLECTION.
   !!! A. Pri CONCURRENT SUBMODE (je to DEFAULT SUBMODE) MARKING PHASE GARBAGE COLLECTION pre GENERATION bezi PARALELNE s behom PROGRAMU v SEPARATNOM THREADE. Plati, ze ak GARBAGE COLLECTOR detekuje prekrocenie limitu pre GENERATION 0, alebo 1, tak vykona normalny GARBAGE COLLECTION vyzadujuci zastavenie vsetkych THREADS. Ak vsak GARBAGE COLLECTOR zisti prekrocenie limitu pre GENERATION 2, tak NESPOSOBI ZASTAVENIE THREADS, ale naopak spusti MARKING PHASE GARBAGE COLLECTION v SEPARATNOM THREAD. Az ked je MARKING PHASE GARBAGE COLLECTION skoncena, tak GARBAGE COLLECTOR POZASTAVI VSETKY THREADS a vykona COMPACTION PHASE GARBAGE COLLECTION, vyuzijuc informacie z MARKING PHASE GARBAGE COLLECTION, ktora bola vykonana v SEPARATNOM THREAD.
   B. Pri NON-CONCURRENT SUBMODE IBA 1 THREAD moze robit OBE PHASES GARBAGE COLLECTION a pocas CELEHO vykonavania GARBAGE COLLECTION su VSETKY THREADS v PROGRAME POZASTAVENE.
!!! 21. Nastavenie GC MODE sa robi pomocou .CONFIG FILE v SECTION <runtime> a po spusteni PROCESSU uz ho nie je mozne zmenit.
   A. ELEMENT [gcServer] urcuje ci sa pouzije SERVER, alebo WORKSTATION MODE.
   B. ELEMENT [gcConcurrent] urcuje ci sa pouzije CONCURRENT, alebo NON-CONCURRENT SUBMODE.
22. V RUNTIME program moze ovplyvnit sposob vykonavania GARBAGE COLLECTION pomocou PROPERTY GCSettings.LatencyMode. PROPERTY moze nadobudat nasledujuce hodnoty.
   !!! A. LOW LATENCY. Sposobuje konzervativnejsie spustanie GARBAGE COLLECTION, ktore okrem ineho znamena, ze GARBAGE COLLECTOR NEBUDE vykonavat GARBAGE COLLECTION pre GENERATION 2 az kym PROGRAM nema nedostatok MEMORY. Tato hodnota by sa mala nastavovat iba na KRATKY CAS ked sa robi nejaka casovo narocna operacia, ktora by nemala byt narusena vykonavanim GARBAGE COLLECTION.
   !!! B. SUSTAINED LOW LATENCY. Minimalizuje latanciu pri vykonavani GARBAGE COLLECTION. Pre GENERATION 2 vykonava GARBAGE COLLECTION iba ak je pouzity CONCURRENT SUBMODE, alebo ked ma PROGRAM nedostatok MEMORY. Tato hodnota by sa mala nastavovat iba na KRATKY CAS ked sa robi nejaka casovo narocna operacia, ktora by nemala byt narusena vykonavanim GARBAGE COLLECTION. Jej prilis dlhe nastavenie by mohlo sposobit hodenie EXCEPTION [OutOfMemoryException].
   C. BATCH. Nastavuje NON-CONCURRENT SUBMODE. Je DEFAULT pre SERVER MODE.
   D. INTERACTIVE. Nastavuje CONCURRENT SUBMODE. Je DEFAULT pre WORKSTATION MODE.
23. STATIC CLASS GC ma viacero MEMBERS, ktorymi je mozne ovladat proces GARBAGE COLLECTION.
   A. STATIC PROPERTY GC.MaxGeneration vracia maximalne cislo GENERATION, ktora je v procese GARBAGE COLLECTION podporovana.
   !!! B. STATIC METHOD GC.Collect() spusta GARBAGE COLLECTION. Umoznuje spustat BLOCKING, alebo NON-BLOCKING GARBAGE COLLECTION a takisto umoznuje pomocou ENUM [GCCollectioMode] urcit ci sa bude vykonavat [Forced] GARBAGE COLLECTION, ktora vykona GARBAGE COLLECTION VZDY, alebo [Optimized] GARBAGE COLLECTION, ktora vykona GARBAGE COLLECTION iba ak GARBAGE COLLECTION ma sancu uvolnit znacne mnozstvo MEMORY.
   C. STATIC METHOD GC.WaitForPendingFinalizer() uvedie aktualny THREAD do WAIT STATE, az kym pre VSETKY OBJECTS v F-REACHABLE QUEUE (maju implementovanu METHOD Finalize() a namaju ROOT) nie je zavolana METHOD Finalize().
   D. STATIC METHOD GC.GetGeneration() vracia informaciu o tom v ktorej GENERATION sa dany OBJECT nachadza.
   E. STATIC METHOD GC.CollectionCount() vracia pocet vykonanych GARBAGE COLLECTION nad danou GENERATION.
   !!! F. STATIC METHOD GC.RegisterForFullGCNotification() urcuje kedy ma byt poslana NOTIFICATION o vykonani GARBAGE COLLECTION. METHOD funguje IBA ak sa NEPOUZIVA CONCURRENT SUMBODE.
   G. STATIC METHOD GC.WaitForFullGCApproach() vracia STATUS obsahujuci informaciu o tom aky type GARBAGE COLLECTION bude vykonany. METHOD BLOKUJE CURRENT THREAD. METHOD funguje IBA ak sa NEPOUZIVA CONCURRENT SUMBODE.
   H. STATIC METHOD GC.WaitForFullGCComplete() vracia STATUS obsahujuci informaciu o tom aky type GARBAGE COLLECTION bol vykonany. METHOD BLOKUJE CURRENT THREAD. METHOD funguje IBA ak sa NEPOUZIVA CONCURRENT SUMBODE.
   I. STATIC METHOD GC.CancelFullGCNotification() odstrani NOTIFICATION o vykonani GARBAGE COLLECTION. METHOD funguje IBA ak sa NEPOUZIVA CONCURRENT SUMBODE.
   J. STATIC METHOD GC.SuppressFinalize() zabranuje vykonaniu Object.Finalize() METHOD pre dany OBJECT.
   !!! K. STATIC METHOD GC.ReRegisterForFinalize() znova povoluje vykonanie Object.Finalize() METHOD pre dany OBJECT. Ak sa METHOD zavola VIACKRAT, potom je FINALIZER METHOD vykonana VIACKRAT.
   L. STATIC METHOD GC.GetTotalMemory() vracia pocet BYTES, ktore METHOD pouziva.
   M. STATIC METHOD GC.AddMemoryPressure() umoznuje CODE definovat mnozstvo alokovanej UNMANAGED MEMORY, ktoru CODE pouziva. Vdaka tomu moze GARBAGE COLLECTOR robit castejsie GARBAGE COLLECTION. METHOD moze interne volat GC.Collect(), ak detekuje prilis velke naroky na MEMORY.
   N. STATIC METHOD GC.RemoveMemoryPressure() umoznuje CODE definovat mnozstvo uvolnenej UNMANAGED MEMORY, ktoru CODE uz nepouziva. Vdaka tomu moze GARBAGE COLLECTOR robit menej casto GARBAGE COLLECTION.
24. CLR poskytuje viacero PERFORMANCE COUNTERS, ktorymi je mozne sledovat kolko GARBAGE COLLECTIONS sa vykonalo a ake mnozstvo MEMORY PROGRAM pouziva.
25. FINALIZATION je mechanizmus, ktory umoznuje uvolnovat UNMANAGED RESOURCES, predtym ako OBJECT ktory ich pouziva je zlikvidovany v GARBAGE COLLECTION.
!!! 26. METHOD Object.Finalize() realizuje FINALIZATION. Je volana v procese GARBAGE COLLECTION tesne predtym ako je OBJECT uvoleny z MEMORY.
!!! 27. C# definuje SPECIALNU SYNTAX pre METHOD Object.Finalize() v tvare [~CLASS_NAME()], kde 'CLASS_NAME' je meno CLASS, pre ktory je METHOD Object.Finalize(). C# takto definovanu METHOD prelozi na deklaraciu METHOD Object.Finalize().
!!!!! 28. Pri deklaracii Object.Finalize() v tvare [~CLASS_NAME()] C# generuje CODE METHOD Object.Finalize() tak, ze CODE definovany v METHOD ~CLASS_NAME() je volany v TRY BLOCK, pricom v prisluchajucom FINALLY BLOCK sa nachadza volanie METHOD base.Finalize(), aby sa VZDY zavolala Finalize() METHOD BASE CLASS.
!!! 29. Pre FINALIZATION platia nasledujuce fakty.
   !!! A. CLASSES s FINALIZER METHODS musia byt udrziavane v MEMORY dlhsie ako ostatne CLASSES, pretoze GARBAGE COLLECTOR po detekovani, ze CLASS ma FINALIZER ich zaradi do specialnej QUEUE z ktorej su postupne OBJECTS vyberane a vyvolavane ich FINALIZERS.
   !!! B. GARBAGE COLLECTOR predlzuje nielen samotnym OBJECTS s FINALIZERS, ale aj VSETKYM OBJECTS na ktore referuju FIELDS OBJECT s FINALIZER.
   C. Poradie volania FINALIZER METHODS je NEDEFINOVANE.
   !!!!! D. Ak CLASS definuje FINALIZER METHOD, pricom CLASS obsahuje FIELDS odkazujuce OBJECTS s implementovanymi FINALIZER METHODS, tak je NEBEZPECNE vo FINALIZER METHOD danej CLASS pristupovat k tymto FIELDS. Dovodom je fakt, ze poradie volania FINALIZER METHODS je NEDEFINOVANE a tak OBJECTS s FINALIZERS na ktore referuju FIELDS uz MOHLI byt FINALIZED a mozu byt v NEDETERMINISTICKOM STAVE. Avsak pristup k FIELDS, ktore NEOBSAHUJU FINALIZER METHOD je bezpecny, kedze tieto nemozu byt FINALIZED a OBJECTS, ktore obsahuju su uvolnene AZ po UKONCENI FINALIZER METHOD.
   !!! E. Volania FINALIZER METHODS su realizovane v SEPARATNOM VYSOKO PRIORITNOM THREADE.
   F. CLR definuje specializovane CLASSES, ktore zjednodusuju implementaciu FINALIZER METHODS.
!!!!! 30. Pre FINALIZER THREAD platia nasledujuce fakty.
   A. FINALIZER THREAD je VYSOKO PRIORITNY THREAD.
   !!! B. Ak sa niektora FINALIZER METHOD dostane do INFINITE LOOP, tak FINALIZER THREAD STVRDNE a FINALIZER METHODS sa PRESTANU VOLAT a tym padom sa ani UNMANAGED RESOURCES NEBUDU UVOLNOVAT.
   C. Ak je CLR ukoncovany pri ukonceni PROGRAMU, tak FINALIZER THREAD dostane 40 sekund na zavolanie vsetkych FINALIZER METHODS, pricom kazda FINALIZER METHODS ma maximalne 2 sekundy na vykonanie. Ak sa tento cas prekroci, tak PROCESS je TERMINATED a ZIADNE dalsie FINALIZER METHODS uz NIE su VOLANE.
   !!! D. Ak niektora FINALIZER METHOD hodi UNHANDLED EXCEPTION, tak PROCESS je OKAMZITE TERMINATED.
!!!!! 31. CLR definuje specializovanu CLASS CriticalFinalizerObject zjednodusujucu implementaciu CLASSES pouzivajucich UNMANAGED RESOURCES. Ak CUSTOM CLASS je DERIVED z CLASS CriticalFinalizerObject, CLR vykonava specializovany algoritmus, ktory zvysuje sancu, ze sa FINALIZER METHOD uspesne vykona aj vtedy, ak napriklad PROCESS ma nedostatok MEMORY, alebo APP DOMAIN je nasilne ukoncena. CLR pracuje s CLASSES DERIVED z CLASS CriticalFinalizerObject nasledujucim sposobom.
   !!! A. CLR pri nacitavani CLASS, ktora je DERIVED z CLASS CriticalFinalizerObject OKAMZITE vykona JIT COMPILATION FINALIZER METHOD tejto CLASS, ako aj FINALIZER METHODS VSETKYCH BASE CLASSES. Predcasna JIT COMPILATION zabranuje, aby CLR pri nedostatku MEMORY, alebo neschopnosti nacitat ASSEMBLY, ktoru FINALIZER METHOD pouziva (pretoze sa nenachadza v pozadovanej PATH) nemohlo spustit FINALIZER METHODS. Tym, ze tieto METHODS su JIT COMPILED v predstihu, CLR ma istotu, ze ich bude schopny vyvolat.
   !!!!! B. Pri FINALIZATION CLR NAJPRV vola VSETKY FINALIZER METHODS tych CLASSES, ktore NIE SU DERIVED z CLASS CriticalFinalizerObject a AZ PO NICH vola FINALIZER METHODS tych CLASSES, ktore SU DERIVED z CLASS CriticalFinalizerObject. Vdaka tomuto postupu maju CLASSES, ktore NIE SU DERIVED z CLASS CriticalFinalizerObject ISTOTU, ze mozu pristupovat k FIELDS referujucim na OBJECTS DERIVED z CriticalFinalizerObject, pretoze ich FINALIZER METHODS este NEBOLI ZAVOLANE.
   !!! C. Ak APP DOMAIN je z nejakeho dovodu NASILNE UKONCENA, potom CLR zabezpecuje vyvolanie FINALIZER METHODS tych CLASSES, ktore su DERIVED z CLASS CriticalFinalizerObject. Vdaka tomuto kroku CLR zabezpecuje volanie FINALIZER METHOD (a uvolnenie UNMANAGED RESOURCES), aj pri nasilnom ukonceni APP DOMAIN.
!!! 32. CLASS SafeHandle poskytuje SAFE implementaciu UNMANAGED HANDLE, ktora zabezpecuje ze UNMANAGED HANDLE bude vzdy uvolneny. Pre CLASS SafeHandle ma nasledujuce vlastnosti.
   A. CLASS SafeHandle je DERIVED z CriticalFinalizerObject co znaci, ze pre nu platia vsetky zasady pre CLASSES DERIVED z CLASS CriticalFinalizerObject a teda CLR robi vsetko preto, aby METHOD Finalize() bola za kazdych okolnosti zavolana.
   B. CLASS SafeHandle poskytuje SAFE implementaciu METHOD IDisposable.Dispose().
   !!! C. CLASS definuje ABSTRACT METHOD SafeHandle.ReleaseHandle() v ktorej musia DERIVED CLASSES uvolnit UNMANAGED RESOURCE.
   !!! D. CLASS definuje ABSTRACT PROPERTY SafeHandle.IsInvalid, ktora vracia TRUE, ked je HANDLE NEPLATNY a FALSE, ked je PLATNY. Pouziva sa napriklad pri HANDLE vracanom z FUNCTION CreateFile(), ktory je neplatny ak ma hodnotu -1. Ine API zas povazuju za neplatny HANDLE ak mna hodnotu rovnu 0.
   !!!!! E. Pri vytvarani instancie CLASS SafeHandle CLR zabezpecuje, ze vytvorenie UNMANAGED HANDLE a jeho priradenie do CLASS SafeHandle je vykonavane v UNMANAGED CODE, a preto NEMOZE byt PRERUSENE CLR. Teda napriklad generovanie EXCEPTION [ThreadAbortException] NEMOZE sposobit nepriradenie vytvorenej UNMANAGED HANDLE do instancie CLASS SafeHandle a teda aj MEMORY LEAK. Ak by sa UNMANAGED HANDLES priradzovali do VARIABLE typu IntPtr a toto naplnanie by sa robilo az v MANAGED CODE, mohlo by sa stat, ze po uspesnom vytvoreni UNMANAGED HANDLE pomocou PInvoke by mohol dojst ku generovaniu EXCEPTION [ThreadAbortException]. UNMANAGED HANDLE IntPtr by tak ostal NEPRIRADENY a MANAGED CODE by ho NEMAL ako UVOLNIT, cim by doslo k RESOURCE LEAK. Riesenim je prave pouzitie SafeHandle, ktore toto priradenie robi v UNMANAGED KODE, ktore NEMOZE byt PRERUSENE generovanim EXCEPTION [ThreadAbortException].
   !!! F. CLASS SafeHandle implementuje REFERENCE COUNTING a to tak, ze pri zavolani UNMANAGED FUNCTION sa COUNTER AUTOMATICKY INKREMENTUJE a pri OPUSTENI UNMANAGED FUNCTION sa COUNTER AUTOMATICKY DEKREMENTUJE. Ak niektora MANAGED METHOD chce uvolnit instanciu SafeHandle, tak sa zisti hodnota COUNTER. Ak je 1 (pri vytvoreni instancie SafeHandle je nastavena 1), tak sa UVOLNENIE instancie SafeHandle sa VYKONA. Ak naopak je COUNER>1, tak sa uvolnenie UNMANAGED HANDLE sa NEVYKONA az do chvile kym NEKLESNE na hodnotu 1. To zvysuje stabilitu MULTITHREAD PROGRAMS, pretoze zabranuje moznosti, aby 1. THREAD zavolal UNMANAGED FUNCTION a POCAS JEJ BEHU 2. THREAD sa pokusil uvolnit UNMANAGED HANDLE, ktory instancia CLASS SafeHandle zapuzduje.
33. Z CLASS SafeHandle je DERIVED ABSTRACT CLASS SafeHandleZeroOrMinusOneIsInvalid, ktora je rovnako ako CLASS SafeHandle ABSTRACT, avsak implementuje PROPERTY SafeHandle.IsInvalid a to tak, ze vracia TRUE ak je hodnota HANDLE, ktory zapuzduje rovna 0, alebo -1. METHOD SafeHandle.ReleaseHandle() vsak nie je OVERRIDED a DERIVED CLASSES musia vykonat jej OVERRIDING.
34. Z CLASSES SafeHandle a SafeHandleZeroOrMinusOneIsInvalid je DERIVED viacero CLASSES pre jednotlive typy HANDLES pouzivane vo WinAPI. Bohuzial vacsina je PRIVATE, iba ako interne CLASSES BCL, a tak z CODE k nim nie je mozne pristupovat.
35. Okrem CLASS SafeHandle .NET definuje aj CLASS CriticalHandle, ktora robi TO ISTE co CLASS SafeHandle akurat NEVYKONAVA REFERENCE COUNTING pri volani a ukonceni volania UNMANAGED FUNCTIONS. Vdaka tomu je cinnost CLASS CriticalHandle RYCHLEJSIA, ako v pripade CLASS SafeHandle, no zaroven sa moze stat, ze iny THREAD pocas vykonavania UNMANAGED FUNCTION moze sa pokusit o uvolnenie UNMANAGED HANDLE co moze zapricinit PAD PROGRAMU.
!!! 36. CLR poskytuje aj moznost DETERMINISTICKEHO UVOLNENIA OBJECTS pomocou implementacie INTERFACE IDisposable. INTERFACE IDisposable obsahuje METHOD IDisposable.Dispose(), ktoru CLASSES pouzivaju na explicitne uvolnenie RESOURCES. CLIENT moze volat METHOD IDisposable.Dispose() zavolat vzdy vtedy, ked potrebuje EXPLICITNE uzatvorit RESOURCES asociovane s instanciou danej CLASS. Pre INTERFACE IDisposable platia nasledujuce zasady.
   A. METHOD IDisposable.Dispose() moze pristupovat ku VSETKYM FIELDS, pretoze v case volania je OBJECT este aktivny a ZIADNE jeho FIELDS NEBOLI UVOLNENE.
   !!! B. Ak niektory FIELD danej CLASS implementuje INTERFACE IDisposable, tak aj samotna CLASS by mala implementovat INTERFACE IDisposable.
   C. Ak CLASS implementuje INTERFACE IDisposable, CLASS MOZE, alebo aj NEMUSI implementovat FINALIZER METHOD. FINALIZER METHOD by sa mala implementovat vtedy ak CLASS pouziva na UNAMANGED RESOURCES.
   !!! D. Po zavolani METHOD IDisposable.Dispose() by KAZDA PUBLIC METHOD a PROPERTY (s vynimkou METHOD IDisposable.Dispose()) mala hodit EXCEPTION [ObjectDisposedException] cim indikuje, ze dany OBJECT uz bol DISPOSED.
   !!! E. Ak je METHOD IDisposable.Dispose() volana DRUHYKRAT, po uz uspesnom uvolneni RESOURCES, nemalo by opatovne volanie IDisposable.Dispose() hodit EXCEPTION [ObjectDisposedException]. METHOD IDisposable.Dispose() by nemala vykonat nic a okamzite skoncit.
   !!! F. Implementacia METHOD IDisposable.Dispose() NIE JE vyzadovana aby bola THREAD-SAFE, aj ked je ho mozne THREAD-SAFE sposobom implementovat.
   G. Po zavolani METHOD IDisposable.Dispose(), ak dany OBJECT implementuje i FINALIZER METHOD by METHOD IDisposable.Dispose() mala volat METHOD GC.SuppressFinalize(), aby sa pre danu instanciu uz nevolal FINALIZER METHOD, kedze UNMANAGED RESOURCES uz boli v METHOD IDisposable.Dispose() uvolnene.
   !!! H. C# poskytuje KEYWORD [using], ktore je mozne aplikovat IBA na CLASSES implementujuce INTERFACE IDisposable. Pouzitie KEYWORD [using] sposobi, CODE zapisany v KEYWORD [using] bude obaleny TRY BLOCK, pricom nasledny FINALLY BLOCK zavola METHOD IDisposable.Dispose() nad instanciou, ktora bola vytvorena v KEYWORD [using]. Tym je zabezpecene, ze aj pri vzniku EXCEPTION sa zavola METHOD IDisposable.Dispose().
!!! 37. CLASS StreamWriter interne pouziva CLASS Stream na ukladanie dat do STREAM. Kedze CLASS Stream MOZE OBSAHOVAT i UNMANAGED RESOURCES (napriklad CLASS FileStream obsahuje HANDLE na FILE), tak CLASS Stream IMPLEMENTUJE FINALIZER METHOD. CLASS StreamWriter vsak FINALIZER METHOD NEIMPLEMENTUJE, aj ked ma FIELD typu Stream, ktory FINALIZER METHOD implementuje. Je to preto, lebo kedze poradie volani FINALIZER METHOD NIE JE GARANTOVANE, tak by CLASS StreamWriter NEMOHOL vo svojej FINALIZER METHOD uvolnit FIELD typu Stream, pretoze ten UZ MOHOL BYT FINALIZED. Riesenim je, ze CLASS StreamWriter NEIMPLEMENTUJE FINALIZER METHOD a az pri volani FINALIZER METHOD CLASS Stream je UNMANAGED RESOURCE, ktory CLASS Stream obsahuje uvolneny. Toto ma jednu NEVYHODU v tom, ze CLASS StreamWriter INTERNE pouziva BUFFER, ktory AZ KED SA NAPLNI, UKLADA DATA do internej instancie CLASS Stream. Kedze vsak CLASS StreamWriter NEIMPLEMENTUJE FINALIZER METHOD, tak ak sa v CODE NEZAVOLA METHOD StreamWriter.Dispose(), tak sa data ulozene v INTERNOM BUFFER, ktore este neboli zapisane do Stream STRATIA.
!!! 38. CLR moze obsahovat CLASSES, ktore interne pouzivaju velky objem UNMANAGED MEMORY, avsak v CLR su reprezentovane iba CLASSES, ktore obsahuju iba niekolko BYTES. Napriklad CLR WRAPPER CLASS okolo BITMAPS obsahuju iba HANDLES na UNMANAGED BITMAP, ktore mozu byt znacne velke. CLR poskytuje METHODS GC.AddMemoryPressure() a GC.RemoveMemoryPressure() vdaka ktorym moze CODE informovat CLR o zvysenych narokoch na MEMORY co sposobi vyssi pocet GARBAGE COLLECTIONS.
!!! 39. Ak PROGRAM pouziva UNMANAGED RESOURCE, ktoreho pocet instancii, ktore z neho mozu byt vytvorene je limitovany systemovymi obmedzeniami (napriklad WINDOWS obmedzuje pocet FILE HANDLES, ktore moze dany PROCESS vytvorit), tak je mozne pouzit CLASS HandleCollector pomocou, ktorej moze PROGRAM informovat GARBAGE COLLECTOR o tom, ze vycerpava, alebo vycerpal maximalny pocet UNMANAGED RESOURCE a tym prinutit GARBAGE COLLECTOR, aby vykonaval GARBAGE COLLECTIONS castejsie na uvolnenie nepouzivanych OBJECTS, ktore obsahuju limitovane UNMANAGED RESOURCES. CLASS HandleCollector ma nasledujuce MEMBERS.
   A. CONSTRUCTOR. Umoznuje definovat identifikator UNMANAGED RESOURCE ako aj maximalny mozny pocet vytvorenych instancii ci pociatocny pocet vytvorenych instancii UNMANAGED RESOURCES.
   B. METHOD HandleCollector.Add() zvysuje hodnotu COUNTER pocitajuceho pocet UNMANAGED RESOURCES. Tato METHOD by mala byt volana, ked CODE alokoval UNMANAGED RESOURCES. METHOD moze interne spustit volanie METHOD GC.Collect().
   C. METHOD HandleCollector.Remove() zvysuje hodnotu COUNTER pocitajuceho pocet UNMANAGED RESOURCES. Tato METHOD by mala byt volana, ked CODE alokoval UNMANAGED RESOURCES. Casto je volana v METHOD IDisposable.Dispose(), alebo vo FINALIZER METHODS.
   D. PROPERTY HandleCollector.Count vracia aktualnu hodnotu COUNTER pocitajuceho pocet UNMANAGED RESOURCES.
   E. PROPERTY HandleCollector.MaximumThreshold vracia maximalnu hodnotu COUNTER pocitajuceho pocet UNMANAGED RESOURCES pri ktoreho dosiahnuti sa spusta proces GARBAGE COLLECTION.
   F. PROPERTY HandleCollector.InitialThreshold vracia pociatocnu hodnotu COUNTER pocitajuceho pocet UNMANAGED RESOURCES.
   G. PROPERTY HandleCollector.Name vracia identifikator UNMANAGED RESOURCE.
40. FINALIZATIONS sa robi v nasledujucich krokoch.
   A. Ak OBJECT implementuje FINALIZER METHOD, tak CLR AUTOMATICKY PRED VYKONANIM jeho CONSTRUCTOR, zaradi tento OBJECT do FINALIZATION LIST.
   B. Ked OBJECTS implementujuce FINALIZER METHODS prestanu byt platne (neodkazuju na ne ziadne ROOTS) a teda mozu byt uvolnene, GARBAGE COLLECTOR ich namiesto okamziteho uvolnenia presunie do F-REACHABLE QUEUE.
   !!!!! C. F-REACHABLE QUEUE sluzi ako ROOT pre GARBAGE COLLECTOR, a preto ich GARBAGE COLLECTOR ich NEMOZE UVOLNIT. Naopak NAMIESTO UVOLNENIA su tieto OBJECTS po presunuti do F-REACHABLE QUEUE zaroven presunute do GENERATION 1.
   D. Vyskoko prioritny FINALIZER THREAD nasledne prechadza F-REACHABLE QUEUE a vola jednotlive FINALIZER METHODS.
   !!! E. Po skonceni FINALIZER THREADU su OBJECTS z F-REACHABLE QUEUE odstranene a kedze nemaju svoj ROOT a mozu byt uvolnene.
   !!! F. Pri DALSOM SPUSTENI GC su tieto OBJECTS uvolnene. To znaci, ze OBJECTS implementujuce FINALIZER METHOD sa VZDY dostanu do F-REACHABLE QUEUE a ZAROVEN sa VZDY dostanu aspon do GENERATION 1. Preto je pouzivanie tychto OBJECTS POMALSIE ako OBJECTS, ktore neimplementuju FINALIZER METHOD.
41. V CLR existuju 2 THREADS, ktore sa zucastnuju procesu GARBAGE COLLECTION.
   A. GARBAGE COLLECTION THREAD je THREAD, ktory sposobuje samotne uvolnovanie MEMORY vykonavanim procesu MARKING a COMPACTING na OBJECTS v MANAGED HEAP.
   B. FINALIZER THREAD je VYSOKO PRIORITNY THREAD, ktoreho cielom je spustat FINALIZER METHODS pre OBJECTS, ktore su v F-REACHABLE QUEUE.
!!!!! 42. Ak vo FINALIZER METHOD je 'THIS' POINTER priradeny do nejakej inej VARIABLE, ktora sa stane jeho ROOT, CLR NEMOZE takyto OBJECT ODSTRANIT z MEMORY. Takyto OBJECT je oznaceny za RESURRECTED OBJECT. Problemom je vsak fakt, ze kedze pre OBJECT uz BOLA volana jeho FINALIZER METHOD, GARBAGE COLLECTOR ju NEZAVOLA ZNOVA. Avsak pomocou METHOD GC.ReRegisterForFinalize(), vsak je mozne PRINUTIT GARBAGE COLLECTOR, aby pre RESURRECTED OBJECTS boli ich FINALIZER METHODS ZNOVA VOLANE.
!!! 43. Kazda APP DOMAIN obsahuje GARBAGE COLLECTOR HANDLE TABLE, ktora obsahuje zoznam OBJECTS z MANAGED HEAP, ktorych ZIVOTNOST v MEMORY chce PROGRAM bud MONITOROVAT, alebo EXPLICITNE URCOVAT (urcit kedy GARBAGE COLLECTOR moze dane OBJECTS zrusit).
44. Kazdy RECORD v GARBAGE COLLECTOR HANDLE TABLE obsahuje 2 udaje.
   A. Referenciu na OBJECT alokovany na MANAGED HEAP, ktory chce PROGRAM monitorovat, alebo riadit jeho zivotnost.
   B. FLAG TYPE GCHandleType urcujuci akym sposobom bude PROGRAM monitorovat, alebo riadit zivotnost objektu na MANAGED HEAP.
45. VALUE TYPE GCHandle sluzi na pridavanie, alebo odoberanie RECORDS z GARBAGE COLLECTOR HANDLE TABLE. Obsahuje nasledujuce MEMBERS.
   A. STATIC METHOD GCHandle.Alloc() prida novy zaznam do GARBAGE COLLECTOR HANDLE TABLE. OVERLOADED verzia umoznuje definovat GCHandleType urcujuci AKYM SPOSOBOM ma byt OBJECT na HEAP monitorovany, alebo ako ma byt ovladana jeho zivotnost.
   B. METHOD GCHandle.Free() uvolnuje RECORD z GARBAGE COLLECTOR HANDLE TABLE.
   C. OPERATOR IntPtr() konvertuje instanciu GCHandle na IntPtr.
   D. OPERATOR GCHandle() konvertuje instanciu IntPtr na GCHandle.
   E. OPERATOR==() a OPERATOR!=() porovnavaju 2 instancie GCHandle.
   F. METHOD GCHandle.AddrOfPinnedObject() vracia PINNED ADDRESS daneho OBJECT, ak bol OBJECT do GARBAGE COLLECTOR HANDLE TABLE zaradeny s hodnotou GCHandleType.Pinned.
   !!! G. PROPERTY GCHandle.IsAllocated urcuje ci je dany GCHandle stale v GARBAGE COLLECTOR HANDLE TABLE, alebo uz bol odstraneny volanim Free(). POZOR tato PROPERTY NEURCUJE ci OBJECT, ktory RECORD reprezenuje UZ BOL ODSTRANENY GARBAGE COLLECTOR z MEMORY. Urcuje iba to, ze sa uz nenachadza v GARBAGE COLLECTOR HANDLE TABLE.
   H. PROPERTY GCHandle.Target vracia odkaz na OBJECT, ktory GCHandle zapuzdruje.
!!! 46. Pomocou VALUE TYPE GCHandle je mozne vykonat MONITORING OBJECT na HEAP, alebo EXPLICITNE riadit jeho ZIVOTNOST.
!!! 47. METHOD GCHandle.Alloc() pomocou PARAMETER TYPE [GCHandleType] umoznuje akym sposobom bude OBJECT na HEAP monitorovany, resp. ako bude riadena jeho zivotnost. MONITORING a RIADENIE ZIVOTNOSTI je mozne realizovat pomocou instancie CLASS [GCHandle], ktoru vracia METHOD GCHandle.Alloc(). TYPE [GCHandleType] moze nadobudat nasledujuce hodnoty.
   A. VALUE GCHandleType.Weak. OBJECT bude vlozeny objekt do GC HANDLE TABLE, pricom instancia GCHandle vratena METHOD GCHandle.Alloc() umoznuje monitorovat zivotnost OBJECT. Ak PROPERTY GCHandle.Target vracia hodnotu NOT NULL, potom OBJECT ma stale ROOT a teda ho GARBAGE COLLECTION este NEZRUSIL. Ak PROPERTY GCHandle.Target vracia hodnotu NULL, potom OBJECT NEMA ROOT a teda GARBAGE COLLECTION ho uz mohol odstranit z MEMORY. Avsak ak ma OBJECT FINALIZER METHOD, tak NIE JE GARANTOVANE, ze FINALIZER METHOD pre dany OBJECT uz bola zavolana.
   !!! B. VALUE GCHandleType.WeakTrackResurrection. OBJECT bude vlozeny objekt do GC HANDLE TABLE, pricom instancia GCHandle vratena METHOD GCHandle.Alloc() umoznuje monitorovat zivotnost OBJECT. Ak PROPERTY GCHandle.Target vracia hodnotu NOT NULL, potom OBJECT ma stale ROOT, alebo ma FINALIZER METHOD, ktora este NEBOLA ZAVOLANA a teda ho GARBAGE COLLECTION este NEZRUSIL. Ak PROPERTY GCHandle.Target vracia hodnotu NULL, potom OBJECT bol ODSTRANENY z MEMORY a to aj ked MAL FINALIZER METHOD, ktora uz BOLA VYVOLANA.
   !!! C. VALUE GCHandleType.Normal. OBJECT bude vlozeny objekt do GC HANDLE TABLE, pricom instancia GCHandle vratena METHOD GCHandle.Alloc() umoznuje riadit zivotnost OBJECT. OBJECT NEMOZE byt ODSTRANENY z MEMORY a to dokonca ani ked NEMA ROOT, az kym nie je zavolana METHOD GCHandleType.Free(). OBJECT vsak MOZE byt COMPACTED. To znaci, ze pri HEAP COMPACTION MOZE byt PRESUNUTY v MEMORY. Tento FLAG sa NESMIE VYUZIT ak sa prenasa OBJECT do UNMANAGED CODE, pretoze POZICIA OBJECT v MEMORY sa MOZE ZMENIT. Avsak je ho mozne pouzit, ako OPAQUE HANDLER preneseny do UNMANAGED CODE, ktory UNMANAGED CODE NESKUMA, iba ho napriklad pri CALLBACK zasle SPAT do MANAGED CODE ako PARAMETER MANAGED CALLBACK FUNCTION.
   !!!!! D. VALUE GCHandleType.Pinned. OBJECT bude vlozeny objekt do GC HANDLE TABLE, pricom instancia GCHandle vratena METHOD GCHandle.Alloc() umoznuje riadit zivotnost OBJECT. OBJECT NEMOZE byt ODSTRANENY z MEMORY a to dokonca ani ked NEMA ROOT, az kym nie je zavolana METHOD GCHandleType.Free(). OBJECT NEMOZE byt ani COMPACTED. To znaci, ze pri HEAP COMPACTION NEMOZE byt PRESUNUTY v MEMORY. Taketo typy OBJECTS sa pouzivaju pri praci s UNMANAGED CODE.
48. S VALUE TYPE GCHandle sa pracuje nasledujucim sposobom.
   A. Pri zavolani STATIC METHOD GCHandle.Alloc() sa vyhlada v GARBAGE COLLECTOR HANDLE TABLE RECORD do ktoreho sa ulozi OBJECT zadany ako PARAMETER METHOD GCHandle.Alloc() ako aj FLAG taktiez zadany ako PARAMETER METHOD GCHandle.Alloc().
   B. VALUE TYPE GCHandle ma JEDINY FIELD typu [IntPtr], ktory je INDEXOM do GARBAGE COLLECTOR HANDLE TABLE RECORD.
   C. VALUE TYPE GCHandle je uvolneny volanim INSTANCE METHOD GCHandle.Free(), ktory vynuluje FIELD typu [IntPtr].
49. GARBAGE COLLECTOR pri vykonavani svojho algoritmu pristupuje k GARBAGE COLLECTOR HANDLE TABLE nasledujucim sposobom.
   !!! A. GARBAGE COLLECTOR vykona MARKING vsetkych OBJECTS ktore maju ROOT a nasledne prechadza GARBAGE COLLECTOR HANDLE TABLE. Ak v nom najde RECORD s FLAGS GCHandleType.Normal, alebo GCHandleType.Pinned, tak tieto OBJECTS su MARKED ako ROOTED OBJECTS, ktore NEMOZU byt odstranene z MEMORY.
   !!! B. GARBAGE COLLECTOR prehladava GARBAGE COLLECTOR HANDLE TABLE so RECORDS oznacenymi FLAG GCHandleType.Weak. Ak taketo OBJECTS NEMAJU ROOT, tak su oznacene za GARBAGE a zaroven FIELDS GCHandle.Target pre RECORDS prisluchajuce danym OBJECTS su nastavene na NULL.
   C. Vsetky OBJECTS, ktore nie su MARKED, ale MAJU FINALIZER METHOD su presunute do F-REACHABLE QUEUE, kde sa AUTOMATICKY stavaju ROOTED OBJECTS a GARBAGE COLLECTOR ich NEMOZE ODSTRANIT.
   !!! D. GARBAGE COLLECTOR prehladava GARBAGE COLLECTOR HANDLE TABLE s RECORDS s nastavenym FLAG GCHandleType.WeakTrackResurrection. Ak taketo OBJECTS NEMAJU ROOT a teda NIE SU ani v F-REACHABLE QUEUE (kedy F-REACHABLE QUEUE je ich ROOT) potom to znamena, ze FINALIZER METHOD pre tieto OBJECTS uz BOLA VOLANA a tieto OBJECT sa stavaju GARBAGE. Pre RECORDS v GARBAGE COLLECTOR HANDLE TABLE, ktore prisluchaju tymto OBJECTS je FIELD GCHandle.Target pre RECORDS nastavena na NULL.
   !!! E. GARBAGE COLLECTOR urobi MEMORY COMPATCION s vynimkou tych OBJECTS, ktore maju v GARBAGE COLLECTOR HANDLE TABLE RECORD s nastavenym FLAG GCHandleType.Pinned.
!!!!! 50. Pouzitie FLAG GCHandleType.Normal je nasledovne.
   A. FLAG GCHandleType.Normal ma vyznam ak sa do UNMANAGED CODE ma preniest OPAQUE HANDLER, ktory UNMANAGED CODE NEBUDE PRIAMO POUZIVAT, ale po skonceni svojej cinnosti vrati jeho hodnotu spat do MANAGED CODE.
   !!! B. Kedze OBJECT je oznaceny FLAG GCHandleType.Normal, NEBUDE GARBAGE COLLECTOR ZLIKVIDOVANY a to dokonca NIE VTEDY, ak NEMA v MANAGED CODE ROOT, pretoze sa v UNMANAGED CODE DALEJ POUZIVA. OBJECT oznaceny v GARBAGE COLLECTOR HANDLE TABLE pomocou FLAG [GCHandleType.Normal] je zlikvidovany az ked sa zavola METHOD GCHandle.Free().
   C. Pomocou OPERATOR CASTING sa vytvori z instancie VALUE TYPE GCHandle s FLAG [GCHandleType.Normal] hodnota [IntPtr], ktora sa posle ako OPAQUE HANDLER do UNMANAGED CODE.
   !!!!! D. UNAMNAGED CODE NESMIE pristupovat k MEMORY zaslanej ako [IntPtr], pretoze FLAG [GCHandleType.Normal] NEZNAMENA, ze MANAGED MEMORY nemoze byt COMPACTED. To znaci, ze [IntPtr] moze byt pomocou GARBAGE COLLECTOR HOCIKEDY PRESUNUTY v MEMORY, takze UNMANAGED CODE k nemu NESMIE PRISTUPOVAT a musi ho brat ako OPAQUE HANDLE.
   !!! E. Ak vsak UNMANAGED CODE chce vykonat CALLBACK do MANAGED CODE, tak PARAMETER typu [IntPtr] MOZE preniest spat do MANAGED CODE ako nejaky unikatny HANDLER, alebo IDENTIFIER.
   !!!!!! F. MANAGED CALLBACK nasledne moze hodnotu [IntPtr] pomocou OPERATION CASTING na OBJECT, ktory dany hodnota [IntPtr] reprezentuje. Pri konverzii CLR pozrie do GARBAGE COLLECTOR HANDLE TABLE a najde prislusny RECORD z ktoreho vytiahne zodpovedajuci MANAGED OBJECT (PROPERTY GCHandle.Target).
   !!! G. Cize GCHandle, ktory ma RECORD s FLAG GCHandleType.Normal je vhodny NAJMA pre ROUND-TRIP OPAQUE HANDLE Z MANAGED do UNMANAGED CODE a spat.
!!!!! 51. Pouzitie FLAG GCHandleType.Pinned je nasledovne.
   A. FLAG GCHandleType.Pinned ma vyznam ak sa do UNMANAGED CODE ma preniest BUFFER, z ktoreho bude UNMANAGED CODE citat, alebo do zapisovat. Kedze FLAG [GCHandleType.Pinned] zabezpecuje, ze OBJECT NEMOZE byt v procese GARBAGE COLLECTION posunuty v MEMORY, tak takyto OBJECT moze byt pouzivany v UNMANAGED CODE bez rizika, zeby doslo k pristupu k neplatnej MEMORY.
   !!!!! B. CLR pri volani UMNANAGED FUNCTION AUTOMATICKY vykonava PINNING VSETKYCH PARAMETERS, ktory trva az do SKONCENIA vykonavanie CODE v UNMANAGED FUNCTION. Ak teda volana UMNANAGED FUNCTION pouzije prenesene PARAMETERS IBA pocas svojho volania EXPLICITNY PINNING NIE JE POTREBNY. EXPLICITNY PINNING je vsak NEVYHNUTNY, ak UNMANAGED FUNCTION si uklada PARAMETERS do FIELDS ci GLOBAL VARIABLES, ktore pouziva aj po SKONCENI VOLANIA UNMANAGED FUNCTION.
   !!! C. OBJECT oznaceny v GARBAGE COLLECTOR HANDLE TABLE pomocou FLAG [GCHandleType.Pinned] NEMOZE byt UVOLNENY z MEMORY ani PRESUNUTY v MEMORY pri GARBAGE COLLECTIONS a to dokonca ani vtedy NIE, ak NEMA v MANAGED CODE ROOT, pretoze sa v UNMANAGED CODE DALEJ POUZIVA. OBJECT oznaceny v GARBAGE COLLECTOR HANDLE TABLE pomocou FLAG [GCHandleType.Pinned] je zlikvidovany az ked sa zavola METHOD GCHandle.Free().
   D. Ak ma byt OBJECT oznaceny FLAG [GCHandleType.Pinned] preneseny do UNMANAGED CODE, musi sa ziskat jeho ADDRESS volanim METHOD GCHandle.AddrOfPinnedObject(). Tato METHOD vracia ADDRESS na OBJECT IBA ak bol nastaveny FLAG [GCHandleType.Pinned]. Takato ADDRESS moze byt prenesena do UMNANAGED CODE.
   !!!!! E. UNAMNAGED CODE MOZE pristupovat k MEMORY zaslanej ako [IntPtr], pretoze FLAG [GCHandleType.Pinned] ZNAMENA, ze MANAGED MEMORY NEMOZE byt COMPACTED. To znaci, ze [IntPtr] NEMOZE byt pomocou GARBAGE COLLECTOR PRESUNUTY v MEMORY, takze UNMANAGED CODE k nemu MOZE LUBOVOLNE PRISTUPOVAT.
   !!! F. Ak UNMANAGED CODE zmeni hodnotu OBJECT oznaceneho FLAG [GCHandleType.Pinned], tak tato zmena sa PREJAVI v MANAGED CODE. Preto pouzitie FLAG [GCHandleType.Pinned] je idealne ak sa do UNMANAGED CODE ma preniest BUFFER, s ktorym ma UNMANAGED CODE pracovat.
!!!!! 52. Pre DELEGATES NIKDY NIE JE TREBA robit PINNING. To znaci, ze DELEGATES by NIKDY NEMALI byt PINNED. Ak sa o to MANAGED CODE pokusi, METHOD GCHandle.Alloc() GENERUJE EXCEPTION. Je to dosledok toho, ze CLR pri MARSHALINGU DYNAMICKY GENERUJE STUB FUNCTION pre NATIVE CODE, ktora sa vola pri volani MANAGED CALLBACK METHOD z NATIVE CODE. Tento STUB CODE je AUTOMATICKY vytvoreny v PINNED MEMORY, a preto NIE JE TREBA robit PINNING DELEGATES, ktore sa pouzivaju ako MANAGED CALLBACK METODY aj keby CALLBACK METHOD bola volana po skonceni METHOD, ktora NATIVE CODE zavolala. CLR teda GARANTUJE, ze DELEGATE zaslany do UNMANAGED CODE bude VZDY PINNED.
!!!!! 53. To co je pri volani MANAGED CALLBACK FUNCTION z NATIVE CODE NUTNE zabezpecit je, aby DELEGATE OBJECT, ktory bol zaslany do MANAGED CODE bol ROOTED pocas CELEJ DOBY pocas ktorej moze NATIVE CODE MANAGED CALLBACK FUNCTION volat. Je to dosledok toho, ze pri GARBAGE COLLECTION (ak DELEGATE OBJECT nie je ROOTED) sa ODSTRANI aj STUB FUNCTION, ktora bola DYNAMICKY GENEROVANA pri volani NATIVE FUNCTION. Preto DELEGATE OBJECT preneseny do NATIVE CODE, MUSI byt pocas CELEJ DOBY, ked NATIVE CODE moze volat MANAGED CALLBACK FUNCTION ROOTED OBJECT. Najjedoduchsie ako to dosiahnut je ulozit takyto DELEGATE do STATIC FIELD.
54. C# poskytuje KEYWORD [fixed], ktory prinuti C# generovat CODE, ktory v danom SCOPE ZABRANI UVOLNENIU ako i PRESUNU MEMORY na ktoru refereruje VARIABLE urcena v deklaracii KEYWORD [fixed].
55. CLASS WeakRerefence je IBA WRAPPER okolo VALUE TYPE GCHandle, ktora pouziva FLAG [GCHandleType.Weak]. Tato CLASS by sa vsak NEMALA POUZIVAT, lebo NEIMPLEMENTUJE IDisposable a tak jediny sposob ako uvolnit GCHandle, ktory interne pouziva je pockat na vykonanie GARBAGE COLLECTION.
!!! 56. CLASS ConditionalWeakTable<TKey,TValue> umoznuje ASOCIOVAT CUSTOM OBJECT s lubovolnym OBJECT, ktory je ulozeny v GARBAGE COLLECTOR HANDLE TABLE s FLAG [GCHandleType.Weak]. To znamena, ze v instancii CLASS ConditionalWeakTable<TKey,TValue> sa TValue udrzuje tak dlho, pokym je TKey OBJECT ROOTED OBJECT. Akonahle TKey OBJECT prestane byt ROOTED OBJECT, tak sa hodnota z ConditionalWeakTable<TKey,TValue> ODSTRANI.
57. CLASS MemoryFailPoint je HELPER CLASS, ktora umoznuje ZISTIT a REZERVOVAT (ak je k dispozicii) VELKE MNOZSTVO MEMORY a ZVYSIT tak pravdepodobnost, ze algoritmus, ktory vyzaduje VELKE MNOZSTVO MEMORY NEHODI OutOfMemoryException pocas svojho behu. Pouzitie takejto CLASS je nasledovne.
   A. Vytvorim sa instanciu CLASS MemoryFailPoint s definovanim predpokladanej velkosti MEMORY potrebnej na vykonanie PAMATOVO NAROCNEHO ALGORITMU.
   B. CONSTRUCTOR kontroluje ci PROCESS ma dost VOLNEJ MEMORY a dost VOLNEHO ADDRESS SPACE. Ak nieco z toho nepostacuje, tak CLR SPUSTI GARBAGE COLLECTION a po jeho skonceni ZNOVA zisti ci PROCESS ma dost MEMORY a ADDRESS SPACE.
   !!! C. Ak PROCESS ma dost VOLNEJ MEMORY a ADDRESS SPACE, tak sa vykona MEMORY RESERVATION, ale NESPRAVI sa MEMORY COMMIT. Takto sa ZNIZI PRAVDEPODOBNOST hodenia EXCEPTION [OutOfMemoryException], avsak jej generovanie je STALE MOZNE, ak pocas vykonavania ALGORITMU narocneho na MEMORY sa nad RESERVED MEMORY nepodari COMMIT.
   D. Ak NIE JE dost VOLNEJ MEMORY, alebo ADDRESS SPACE tak CONSTRUCTOR CLASS MemoryFailPoint hodi EXCEPTION [MemoryFailException] naco PROGRAM moze zareagovat napriklad upozornenim pouzivatela, alebo skusit MEMORY uvolnit (napriklad nejaku internu CACHE).
   E. Ked ALGORITMUS narocny na MEMORY SKONCI je treba zavolat METHOR MemoryFailPoint.Dispose(), ktora uvolni RESERVED MEMORY.
!!! 58. CLR pri vykonavani GARBAGE COLLECTION musi zabezpecit, aby VSETKY THREADS boli pocas GARBAGE COLLECTION v SUSPENDED stave. Inak by nemohol bezpecne presuvat OBJECTS v MEMORY. Mechanizmus ako sa THREADS dostanu do SUSPENDED STATE je nasledovny.
   A. Ak CLR chce vykonat GARBAGE COLLECTION, tak OKAMZITE spravi SUSPEND VSETKYCH MANAGED THREADS.
   !!! B. Nasledne je KAZDY MANAGED THREAD preskumany na zaklade JIT-generovanych TABLES na ktorej NATIVE INSTRUCTION sa nachadza. CLR zistuje podla TABLES vytvorenych JIT COMPILER, ci sa jednotlive THREADS nachadzaju na takzvanych SAFE-POINTS.
   C. Ak sa MANAGED THREAD nachadza v SAFE-POINT tak OSTANE v SUSPEDNED STATE.
   !!! D. Ak MANAGED THREAD sa NENACHADZA v SAFE-POINT tak CLR MODIFIKUJE STACK, tak aby pri NAVRATE z AKTUALNE VYKONAVANEJ METHOD THREAD zacal vykonavat SPECIALNU FUNCTION, ktora dany THREAD privedie do SUSPEDED STATE.
   E. Po modifikacii THREAD STACK aby pri NAVRATE z AKTUALNE VYKONAVANEJ METHOD bola vykonana specialna FUNCTION, ktora uvedie THREAD do SUSPEDED STATE je THREAD RESUMED.
   !!!!! F. CLR da isty cas THREADU aby UKONCIL AKTUALNE VYKONAVANU METHOD a vyvolal SPECIALNU METODU, ktora privedie THREAD do SUSPEDED STATE. Ak do stanoveneho casu AKTUALNE VYKONAVANA METHOD NESKONCI, tak je THREAD ZNOVA SUSPEDED a ALORITMUS sa OPAKUJE a ak METHOD s MODIFIKOVANYM STACK vstupila do INEJ METHOD, tak znova sa modifikuje STACK, aby pri navrate z nej bola vyvolana SPECIALIZOVANA FUNCTION, ktora privedie THREAD do SUSPEDNED STATE.
   G. Az ked su VSETKY THREADS privedene do SUSPEDED STATE, tak moze sa zacat proces GARBAGE COLLECTION.
!!! 59. CLR podporuje i SYNCHRONIZATION-FREE ALOKACIU OBJECTS. V tomto pripade ma KAZDY THREAD VYHRADENU CAST HEAP v ktorej moze alokovat OBJECTS NEZAVISLE na INYCH THREADS. Vyhodou je, ze CELA HEAP NEMUSI BYT POCAS ALOKOVANIA OBJECT LOCKED.
//-------------------------------------------------------------------------------------------------------
Poznamka z WEBU o NEPOTREBNOSTI PINNINGU pre DELEGATES.

1. Finally, a word on pinning. I often see applications that aggressively pin managed objects or managed delegates that have been passed to unmanaged code. In many cases, the explicit pin is unnecessary. It arises because the developer has confused the requirement of tracking an object instance via a handle with the requirement of keeping the bytes of that object at a fixed location in memory.
2. For normal PInvokes, a blittable type exposes the bytes of an object in the GC heap directly to unmanaged code. This obviously means that the bytes mustn’t be moved by a GC relocation until the unmanaged code has stopped accessing them. In most cases, the PInvoke layer can automatically pin the bytes for the lifetime of the call. And this layer can pin those bytes in a more efficient manner than you could with a pinned GCHandle. (The PInvoke layer is hooked into the CLR’s stack crawling mechanism for GC reporting. So it can defer all overhead related to pinning unless a GC actually occurs while the PInvoke call is in progress). Applications that explicitly pin buffers around PInvoke calls are often doing so unnecessarily.
3. Along the same lines, managed Delegates can be marshaled to unmanaged code, where they are exposed as unmanaged function pointers.  Calls on those pointers will perform an unmanaged to managed transition; a change in calling convention; entry into the correct AppDomain; and any necessary argument marshaling.  Clearly the unmanaged function pointer must refer to a fixed address.  It would be a disaster if the GC were relocating that! This leads many applications to create a pinning handle for the delegate. This is completely unnecessary. The unmanaged function pointer actually refers to a native code stub that we dynamically generate to perform the transition & marshaling. This stub exists in fixed memory outside of the GC heap.
!!! 4. However, the application is responsible for somehow extending the lifetime of the delegate until no more calls will occur from unmanaged code. The lifetime of the native code stub is directly related to the lifetime of the delegate. Once the delegate is collected, subsequent calls via the unmanaged function pointer will crash or otherwise corrupt the process.  In our recent release, we added a Customer Debug Probe which allows you to cleanly detect this – all too common – bug in your code. If you haven’t started using Customer Debug Probes during development, please take a look.
//-------------------------------------------------------------------------------------------------------