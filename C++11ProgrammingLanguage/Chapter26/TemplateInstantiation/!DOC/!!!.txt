//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje TEMPLATE INSTANTIATION.
2. Na to, aby TEMPLATES mohli byt pouzite v CODE je nutne vytvorit z TEMPLATES vytvorit ich instancie. TEMPLATE INSTANCES su vytvarane dvoma sposobmi.
   A. IMPLICIT TEMPLATE INSTANTIATION. C++ vytvori instanciu TEMPLATE pri jej prvom pouziti.
   B. EXPLICIT TEMPLATE INSTANTIATION. V CODE je mozne EXPLICITNE pre konkretne TYPES definovat TEMPLATE INSTANCE, ktore C++ nasledne vygeneruje.
!!! 3. C++ vykona IMPLICIT TEMPLATE INSTANTIATION v pripade pouzitia danej TEMPLATE. IMPLICIT TEMPLATE INSTANTIATION sa vykona IBA VTEDY, ak CODE pouzije TEMPLATE sposobom, ktory vyzaduje TEMPLATE DEFINITION. To napriklad znamena, ze v pripade TEMPLATE CLASS sa TEMPLATE INSTANTION NEVYKONA pri definovani POINTER na TEMPLATE CLASS, pretoze ten vyzaduje IBA TEMPLATE CLASS DECLARATION.
!!! 4. Pri IMPLICIT TEMPLATE INSTANTIATION sa pri vytvarani TEMPLATE INSTANCES z CLASSES automaticky NEVYTVARAJU INSTANCES zo vsetkych METHODS, ale iba z tych METHODS, ktore sa v CODE realne pouziju.
5. EXPLICIT TEMPLATE INSTANTIATION sa realizuje explicitne v CODE pomocou KEYWORD [template] za ktorym nasleduje TEMPLATE DECLARATION s uz asociovanymi TYPES.
!!!!! 6. Pri EXPLICIT TEMPLATE INSTANTIATION ak sa vykonava TEMPLATE INSTANCE z CLASS, C++ OKAMZITE generuje CODE pre VSETKY METHODS TEMPLATE CLASS.
!!! 7. Pomocou KEYWORD [extern] pre pri TEMPLATE DECLARATION sa COMPILERU oznamuje, ze NEMA generovat CODE pre danu TEMPLATE, pretoze v INOM .CPP FILE bol CODE pre tuto TEMPLATE EXPLICITNE vygenerovany.
8. NAME BINDING je proces pri ktorom C++ pre kazdy NAMED ENTITY (meno CLASS, meno FUNCTION, meno OPERATOR, meno VARIABLE) pouzity v TEMPLATE hlada podla tohto mena ELEMENT (CLASS, FUNCTION, OPERATOR, VARIABLE). Pri NAME BINDING sa rozlisuju 2 typy NAMES.
   A. DEPENDENT NAMES su mena ENTITIES, ktore zavisia na TYPE PARAMETERS danej TEMPLATE.
   B. NON-DEPENDENT NAMES su mena ENTITIES, ktore nezavisia na TYPE PARAMETERS danej TEMPLATE. Su to mena CLASSES ci FUNCTIONS, ktore TEMPLATE CODE moze volat ako napriklad [vector<>] ci [printf()].
9. RESOLVING DEPENDENT NAMES C++ vykonava az v case TEMPLATE INSTANTIATION, pretoze az vtedy pozna konkretne TYPES, ktore sa substituovali za TYPE PARAMETERS.
10. RESOLVING NON-DEPENDENT NAMES C++ vykonava uz v TEMPLATE DEFINITION. To znaci, ze ENTITIES pre NON-DEPENDENT NAMES musia byt v SCOPE v ktorom je TEMPLATE definovana. Napriklad ak TEMPLATE vola FUNCTION XXX(), ktorej PARAMETERS NEZAVISIA na TEMPLATE PARAMETERS, tak FUNTION XXX() MUSI byt v case TEMPLATE DEFINITION DEKLAROVANA, inak COMPILER hodi ERROR.
!!! 11. Pri RESOLVING NON-DEPENDENT NAMES sa uvazuju IBA ENTITIES, ktore su v SCOPE v case TEMPLATE DEFINITION. To napriklad znaci, za ak sa v TEMPLATE vola FUNCTION XXX(100), pricom v case DEFINITION je pristupna iba FUNCTION [void XXX(double)], pricom NIZSIE v CODE za TEMPLATE DEFINITION sa nachadza FUNCTION [void XXX(int)], ktora LEPSIE splna kriteria pre volanie FUNCTION XXX(100), tak C++ aj napriek tomu pouzije FUNCTION [void XXX(double)], pretoze iba tato bola v case TEMPLATE DEFINITION deklarovana.
!!! 12. Ak DEPENDENT NAME odkazuje na TYPE, je NUTNE pouzit KEYWORD [typename]. Napriklad ak TYPE [XXX] definuje TYPE [XXX::Value], tak v TEMPLATE CODE je nutne pri definicii VARIABLE tohto TYPE pouzit CODE [typename XXX::Value SomeVariable].
!!!!! 13. Ak DEPENDENT NAME odkazuje na MEMBER TEMPLATE, je NUTNE pouzit KEYWORD [template]. Napriklad ak TYPE [XXX] definuje MEMBER TEMPLATE TYPE [XXX::SomeMemberTemplate()], tak v TEMPLATE CODE pri volani tejte TEMPLATE METHOD je pouzit CODE [SomeXXXVariable.template SomeMemberTemplate()], kde 'SomeXXXVariable' je VARIABLE TYPE [XXX].
14. Pre DEPENDENT NAMES INSTANTINATION POINT, teda bod v ktorom C++ vytvoreny TEMPLATE CODE vlozi do C++ CODE zavisi do typu TEMPLATE.
   A. Pri TEMPLATE CLASSES je INSTANTINATION POINT definovany hned PRED 1. miestom pouzitia TEMPLATE CLASS. To znamena, ze ak FUNCTION [XXX()] pouzije TEMPLATE CLASS [CTemplate<>] pre TYPE [int], tak C++ DEKLARACIU TEMPLATE CLASS INSTANCE [CTemplate<int>] vlozi PRED telo FUNCTION XXX().
   B. Pri TEMPLATE FUNCTIONS je INSTANTINATION POINT definovany hned ZA 1. miestom pouzitia TEMPLATE FUNCTION. To znamena, ze ak FUNCTION [XXX()] pouzije TEMPLATE FUNCTION[YYY()] pre TYPE [int], tak C++ DEKLARACIU TEMPLATE FUNCTION INSTANCE [YYY<int>()] vlozi ZA telo FUNCTION XXX().
15. Ak DEPENDENT NAME zavisi na TYPE PARAMETER, ktory je definovany v NAMESPACE, potom C++ pri vykonani ich RESOLVING vykonava hladanie nielen v aktualnom SCOPE, ale aj v SCOPE daneho NAMESPACE.
16. Ak je CLASS TEMPLATE DERIVED z BASE CLASS NAME RESOLVING zavisi od toho ci je BASE CLASS zavisla na TYPE PARAMETERS DERIVED CLASS.
!!! 17. Ak BASE CLASS NEZAVISI na TYPE PARAMETERS, potom NAME RESOLVING prebieha sa vykonava podla nasledujucich pravidel.
   A. V DERIVED CLASS su pristupne vsetky PUBLIC a PROTECTED MEMBERS BASE CLASS.
   B. Ak DERIVED CLASS definuje vlastne MEMBERS s IDENTICKYM NAMES ako NAMES MEMBERS v BASE CLASS, alebo GLOBAL NAMESPACE, potom C++ pri volani tychto MEMBERS zavola MEMBERS definovane v DERIVED CLASS, pricom MEMBERS definovane v BASE CLASS a GLOBAL NAMESPACE su prekryte.
!!! 18. Ak BASE CLASS ZAVISI na TYPE PARAMETERS, potom NAME RESOLVING prebieha sa vykonava podla nasledujucich pravidel.
   !!! A. Ak DERIVED CLASS vola MEMBER, ktory NEZAVISI na TYPE PARAMETER (napriklad METHOD, ktora NEMA ziaden PARAMETER, ktory by bol typu TYPE PARAMETER), potom sa NAME RESOLVING robi uz pocas DEFINITION. To znamena, ze aj ked BASE CLASS definuje MEMBER s danym NAME, tento sa NEZAVOLA a namiesto neho sa zavola rovnako pomenovany MEMBER z inej NON-DEPENDENT BASE CLASS, alebo GLOBAL NAMESPACE. Ak takyto ELEMENT neexistuje, COMPILER hodi ERROR.
   !!! B. Ak DERIVED CLASS vola MEMBER, ktory ZAVISI na TYPE PARAMETER (napriklad METHOD, ktora ma PARAMETER, ktory je typu TYPE PARAMETER), potom sa NAME RESOLVING robi v INSTANCE TIME a v tomto pripade sa vola MEMBER BASE CLASS.
   !!!!! C. Ak DERIVED CLASS chce EXPLICITNE pristupit k MEMBER z BASE CLASS, ktory NEZAVISI na TYPE PARAMETER (napriklad METHOD, ktora NEMA ziaden PARAMETER, ktory by bol typu TYPE PARAMETER), potom MUSI pouzit EXPLICITNU kvalifikaciu, bud pomocou OPERATOR:: (napriklad 'XXX::MEMBER'), alebo pomocou KEYWORD [this] (napriklad 'this->XXX').
//-------------------------------------------------------------------------------------------------------