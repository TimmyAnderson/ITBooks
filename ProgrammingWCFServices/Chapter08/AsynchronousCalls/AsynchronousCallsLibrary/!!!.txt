//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzivanie ASYNCHONOUS CALLS.
!!!!! 2. Asynchronne volania mozu byt REALIZOVANE na 2 UROVNIACH. Toto je OVERENE PRIAMO s MSDN.
   A. Su realizovane ako CISTO ZALEZITOST CLIENTA a na SERVER NEKLADU ZIADNE DODATOCNE NAROKY. SERVER implementuje IBA SYNCHRONNE VERZIE OPERACII, ktore CLIENT moze volat BUD SYNCHRONNE, alebo ASYCHRONNE - ak ma na to CLIENT usposobeny svoj PROXY objekt.
   B. Su realizovane ako CISTO ZALEZITOST SERVICE a na CLIENTA NEKLADU ZIADNE DODATOCNE NAROKY. CLIENT implementuje IBA SYNCHRONNE VERZIE OPERACII, ktore sa na SERVICE volaju BUD SYNCHRONNE, alebo ASYCHRONNE. DEFAULT sa vsak vola SYNCHRONNA VERZIA.
   C. Su realizovane ako na CLIENT tak i na SERVICE v OBOCH - SYNCHRONNEJ i ASYNCHRONNEJ verzii.
!!!!! 3. Aj na SERVICE je mozne realizovat ASYNCHRONNE OPERATIONS a to ROVNAKYM PATTERNOM ako na CLIENT. Platia pritom nasledujuce zasady.
   A. SERVICE musi vystavit OPERATION, ktora bude mat PROTOTYP: [IAsyncResult BeginXXX(INPUT_PARAMS, AsyncCallback CB, object AS)]. Tato operation MUSI mat atribut [OperationContract(AsyncPattern=true)].
   B. SERVICE musi vystavit OPERATION, ktora bude mat PROTOPYP: [RET_VALUE EndXXX(IAsyncResult AR)].
   C. SERVICE musi IMPLEMENTOVAT BeginXXX() pomocou STANDARDNEHO .NET ASYNCHRONNEHO PATTERN. Kludne moze pri realizacii BeginXXX() pouzit DELEGATE, ktoreho metoda BeginInvoke() vrati objekt typu IAsyncResult, ktory potom vratim z metody ako navratovu hodnotu.
   D. SERVICE musi IMPLEMENTOVAT EndXXX() pomocou STANDARDNEHO .NET ASYNCHRONNEHO PATTERN. Kludne moze pri realizacii BeginXXX() pouzit DELEGATE, ktoreho metoda EndInvoke() ukonci ASYNCHRONNU OPERACIU. Objekt DELEGATE MUSI BYT TEN ISTY, aby bol pouzity v BeginXXX().
   E. CLIENT nasledne moze volat metodu BeginXXX() a po skonceni ASYNCHRONNEHO volania EndXXX() ako by sa jednalo o bezny .NET ASYNCHRONNY PATTERN.
   !!!!! F. Ak SERVICE ma definovanu okrem ASYNCHRONNYCH METOD, aj SYNCHRONNU VERZIU METODY XXX(), potom DEFAULT pri volani ASYNCHRONNEJ METODY z CLIENT sa na SERVICE NEZAVOLA ASYNCHRONNA VERZIA, ale SYNCHRONNA. Ak chcem aby sa volala ASYNCHRONNA VERZIA, potom SERVICE NESMIE MAT SYNCHRONNU VERZIU. ??? Mozno existuje aj nejaky iny sposob ako prinutit WCF, aby namiesto SYNCHRONNEJ volal ASYNCHRONNU OPERACIU na SERVICE, ale to sa mi nepodarilo zistit.
!!! 4. CLIENT musi definovat SPECIALNE PROXY, kde kazda metoda service XXX() musi mat este dve ASYCNHRONNE METODY BeginXXX() a EndXXX().
   A. Metoda BeginXXX() ma vsetky [in] parametre ako XXX() a zaroven parametre AsyncCallback Callback, object AsyncState. Callback sluzi na definoanie Callback metody a AsyncState na definovanie stavu, ktore sa prenesie do Callback. Metoda vracia IAsyncResult, ktoru musim zaslat do EndXXX() aby WCF vedelo, vysledky ktoreho asnychronneho volania pozadujem. METODA MUSI BYT OZNACENA ATRIBUTOM [OperationContract(AsyncPattern=true)].
   B. Metoda EndXXX() ma vsetky [ref], [out] parametre ako XXX() a parameter IAsyncResult, cez ktory musim preniest objekt, ktory vratil BeginXXX() nato aby WCF vedelo vysledky, ktoreho asynchronneho volania pozadujem.
5. EXCEPTIONS sa prenasaju aj v asynchronnych volaniach pri volani EndXXX().
!!! 6. Ak BeginXXX() HODI EXCEPTION, tak sa CALLBACK METODA NEZAVOLA.
!!! 7. Hodnota IAsyncResult.AsyncWaitHandle obsahuje HANDLE a ten sa ani po volani EndXXX() sam neuzatvori. Kedze sa jedna o nemanageovany zdroj je dobre ho vzdy uvolnil cez Close().
!!! 8. Ak vznikne pocas asnychronneho volania neocakavana EXCEPTION, tak kanal je vo Faulted state a proxy klakne - nejde volat ziadne dalsie metody. Tuto EXCEPTION je mozne chytit pri volani EndXXX() metody.
9. Na testovanie konca volania metody sa da pouzit bud IAsyncResult.AsyncWaitHandle, alebo IAsyncResult.IsCompleted. Aj v priapde Exception sa nastavia.
!!!!! 10. Ak je ZAPNUTY TRANPORT SESSION, PROXY objekt NESMIEM UZAVRIET volanim Close() SKOR ako sa UKOCNI ASYCNHRONNE VOLANIE. Inak sa volanie OPERACIE VOBEC NEDOKONCI, kdeze RESPONSE MESSAGE po uzavreti PROXY uz NEBUDE zo SERVICE AKO DOPRAVIT na CLIENTA. Ak je NASTAVENY CALLBACK, tak sa OKAMZTIE po volani Close() ZAVOLA a EndXXX() hodi EXCEPTION.
!!!!! 11. Ak je VYPNUTY TRANPORT SESSION, potom PROXY objekt MOZEM KLUDNE ZAVRIET VOLANIM Close(). Close() vsak SKONCI AZ KED SKONCI ASYNCHRONNE VOLANIE. Avsak AJ PO ZAVOLANI Proxy.Close() este MOZEM NAD TYMTO PROXY zavolat Proxy.EndXXX() a to KOREKTNE PREBEHNE.
!!!!! 12. Pri volani BeginXXX() metoda vracia IAsyncResult, ktora v PROPERTY AsyncWaitHandle obsahuje WaitHandle. Ten je treba PO VOLANI EndXXX() UZAVRIET, aby sa uvolnil UNMANAGED RESOURCE.
!!! 13. Trieda ClientBase<T> i DuplexClientBase<T> obsahuju HELPER METODU InvokeAsync(), ktora umoznuje volat ASYNCHRONNU CALLBACK METODU cez SYNCHRONIZATION CONTEXT. Ak napriklad GUI aplikacia ma SYNCHRONIZATION CONTEXT, tak SendOrPostCallback, ktory je parametrom InvokeAsync() sa vyvola na GUI THREADE. Tato metoda ako parametre prijma BeginXXX() a EndXXX() ASYNCHRONNEJ OPERATION, ktory ma na SERVICE VOLAT.
!!! 14. Generovane PROXY VYUZIVA EVENT-BASED ASYNCHRONOUS PATTERN, ktory je realizovany pomocou InvokeAsync(). Vygenerovane PROXY poskytuje EVENT, ktory sa vola, ked ASYNCHRONNA OPERACIE SKONCI. Tento EVENT je volany na THREADE cez SYNCHRONIZATION CONTEXT.
//-------------------------------------------------------------------------------------------------------
Poznamky k urovni aplikovania ASYNCHRONNYCH OPERATIONS.

1. Use the AsyncPattern property to build service operations that can be called asynchronously on the server, the client, or both. The AsyncPattern property informs the runtime that a Begin method has a matched End method that conforms to the .NET Framework asynchronous method design pattern. Building server asynchronous methods that implement a service operation increases server scalability and performance without affecting the clients of the service, and is recommended when a service operation must return something to the client after performing a lengthy operation that can be performed asynchronously. 
2. Clients remain unaffected because the asynchronous method pair on the server is an implementation detail that does not affect the underlying Web Services Description Language (WSDL) description of the operation. Such methods appear to clients as a single operation with <input> and correlated <output> messages. automatically routes inbound messages to the Begin<methodName> method and routes the results of the End<methodName> call to the outbound message. Client channels, therefore, can represent the method pair as either a single synchronous operation or as an asynchronous operation pair. In no case does the client representation affect the asynchronous implementation on the server in any way.
3. Client contracts can use the AsyncPattern property to indicate an asynchronous method pair that the client can use to invoke the operation asynchronously. Typically, client applications use the ServiceModel Metadata Utility Tool (Svcutil.exe) tool and the /async option to generate a Begin<methodName> and End<methodName> method pair that the client can use to invoke the operation asynchronously.
4. If a service operation has both an asynchronous and a synchronous version, the default behavior on the service is to invoke the synchronous version.
//-------------------------------------------------------------------------------------------------------