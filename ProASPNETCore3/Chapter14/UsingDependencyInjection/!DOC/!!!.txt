//----------------------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie DEPENDENCY INJECTION.
2. SERIVCE je lubovolny CLASS, ktory obsahuje lubovolnu FUNCTIONALITY. SERVICES svoju FUNCTIONALITY spravidla vystavuju pomocou INTERFACES (BASE CLASS), ktore implementuju.
3. SERVICES mozu byt registrovane v DEPENDENCY INJECTION FRAMEWORK, vdaka comu su SERVICES pristupne v rozlicnych castiach ASP.NET CORE PROGRAMU.
4. DEPENDENCY INJECTION je programatorska technika, ktora vychadza a nasledujucich principov.
   A. Kazda SHARED FUNCIONALITY v PROGRAME by mala byt definovana pomocou INTERFACES (eventualne BASE CLASSES), ktore definuju CONTRACT, ktory musi CLASS implementujuca dany INTERFACE (eventualne DERIVED CLASS) implementovat.
   B. CLASSES implementujuce SHARED FUNCIONALITY sa nazyvaju SERVICES.
   C. Kedze SERVICES implementuju specificku FUNCTIONALITY, ta je skryta v implementacii PROPERTIES a METHODS tychto SERVICES, INTERFACES (eventualne BASE CLASS) definuju iba CONTRACT, no ziadne IMPLEMENTATION DETAILS.
   C. DEPENDENCY INJECTION teda klasicky princip OOP - POLYMORPHISM.
   D. V ASP.NET CORE existuje DEPENDENCY INJECTION FRAMEWORK, ktory poskytuje mechanizmus zaregistrovat pre dany INTERFACE (eventualne BASE CLASS) SERVICE, ktory tento INTERFACE (eventualne BASE CLASS) implementuje.
   E. Jednou z velkych vyhod DEPENDENCY INJECTION FRAMEWORK v ASP.NET CORE je moznost vytavarat instancie SERVICES na poziadanie v rozlicnych castiach PROGRAMU.
   !!! F. DEPENDENCY INJECTION FRAMEWORK je podla definovaneho SCOPE daneho SERVICE bud vytvorit novu instanciu SERVICE, alebo vratit instanciu existujuceho SERVICE, ak je SERVICE zaregistrovany ako SINGLETON, alebo SCOPED.
   !!! G. Pri vytvarani novych instancii SERVICES, ak DEPENDENCY INJECTION FRAMEWORK zisti, ze CONSTRUCTOR daneho MAIN SERVICE obsahuje ako PARAMETERS instancie inych SERVICES, instancie tychto SERVICES vytvara REKURZIVNE, takze vytvorenie instancie MAIN SERVICE spusta vytvaranie instancii dalsich SERVICES, na ktorych je  MAIN SERVICE zavisly.
5. ASP.NET podporuje vlastnu implementaciu DEPENDENCY INJECTION FRAMEWORK, ktoru ASP.NET pouziva vzdy ked potrebuje vytvorit instancie CONTROLLERS ci instancie inych CLASSES, ktore ASP.NET CORE vytvara.
6. ASP.NET CORE pri spracovavani HTTP REQUEST vyuziva interny DEPENDENCY INJECTION FRAMEWORK nasledujucim sposobom.
   A. Pri prichode HTTP REQUEST ASP.NET CORE na zaklade ROUTES urci, ktory CONTROLLER a ktora ACTION METHOD ma byt zavolana.
   B. ASP.NET CORE poziada DEPENDENCY INJECTION FRAMEWORK o vytvorenie instancie CONTROLLER.
   C. DEPENDENCY INJECTION FRAMEWORK preskuma CONSTRUCTOR vybraneho CONTROLLER a zisti TYPES jeho PARAMTERS.
   D. DEPENDENCY INJECTION FRAMEWORK pre kazdy najdeny CONSTRUCTOR PARAMETER TYPE sa vyhladava SERVICE zaregistrovany v DEPENDENCY INJECTION FRAMEWORK. Ak TYPE je INTERFACE, alebo BASE CLASS, tak DEPENDENCY INJECTION FRAMEWORK vyhlada SERVICE CLASS, ktory dany INTERFACE (BASE CLASS) implementuje.
   E. DEPENDENCY INJECTION FRAMEWORK vytvori pre vsetky CONSTRUCTOR PARAMETER TYPES instancie zaregistrovanych SERVICES.
   F. Nasledne DEPENDENCY INJECTION FRAMEWORK vytvori instanciu CONTROLLER pricom v CONSTRUCTOR su PARAMETERS nahradene vytvorenymi SERVICES.
   G. DEPENDENCY INJECTION FRAMEWORK vrati vytvorenu instanciu CONTROLLER pre ktoru ASP.NET CORE zavola jej ACTION METHOD, ktora spracuje HTTP REQUEST.
   !!! H. Ak po spracovani HTTP REQUEST MESSAGE skonci SCOPE vytvorenych SERVICES, potom su tieto SERVICES odstranene. SCOPE pri ukonceni spracovania HTTP REQUEST sa konci u TRANSIENT a SCOPED SERVICES. Naopak, SCOPE SINGLETON SERVICES sa konci az ukocenim ASP.NET CORE PROGRAMU.
!!! 7. ASP.NET CORE postupuje pri pouzivani MIDDLEWARE COMPONENTS identickym sposobom ako pri spracovanim HTTP MESSAGES. To znaci, ze ak je nutne vytvorit instanciu MIDDLEWARE COMPONENT, ktora ma v CONTRUCTOR SERVICES zaregistrovane v DEPENDENCY INJECTION FRAMEWORK, tak su tieto SERVICES pomocou DEPENDENCY INJECTION FRAMEWORK vytvorene.
8. ASP.NET CORE implementuje DEPENDENCY INJECTION FRAMEWORK pomocou CLASS, ktora implementuje INTERFACE [IServiceCollection]. INTERFACE [IServiceCollection] ma nasledujuce MEMBERS.
   A. METHOD [IServiceCollection AddTransient<TService>()] umoznuje pridat TRANSIENT SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. Instancia TRANSIENT SERVICE je vytvorena vzdy ked je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie REFERENCE na SERVICE 'TService'.
   B. METHOD [IServiceCollection AddTransient<TService>(Func<IServiceProvider,TService> ImplementationFactory)] umoznuje pridat TRANSIENT SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. Instancia TRANSIENT SERVICE je vytvorena vzdy ked je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie REFERENCE na SERVICE 'TService'.
   C. METHOD [IServiceCollection AddTransient<TService,TImplementation>()] umoznuje pridat TRANSIENT SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. Instancia TRANSIENT SERVICE je vytvorena vzdy ked je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie REFERENCE na SERVICE 'TService'.
   D. METHOD [IServiceCollection AddTransient<TService,TImplementation>(Func<IServiceProvider,TImplementation> ImplementationFactory)] umoznuje pridat TRANSIENT SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. Instancia TRANSIENT SERVICE je vytvorena vzdy ked je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie REFERENCE na SERVICE 'TService'.
   E. METHOD [IServiceCollection AddTransient<TService>()] umoznuje pridat SCOPED SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SCOPED SERVICE iba raz pocas celeho trvania daneho SCOPE. To znaci, ze ak instancia SERVICE 'TService' v danom SCOPE este nebola vytvorena, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu SERVICE 'TService'. Ak vsak instancia SERVICE 'TService' v danom SCOPE uz bola vytvorena, DEPENDENCY INJECTION FRAMEWORK vracia existujuci instanciu a nova instancia sa uz NEVYTVARA. SCOPE typicky trva pocas spracovania 1 HTTP REQUEST.
   F. METHOD [IServiceCollection AddTransient<TService>(Func<IServiceProvider,TService> ImplementationFactory)] umoznuje pridat SCOPED SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SCOPED SERVICE iba raz pocas celeho trvania daneho SCOPE. To znaci, ze ak instancia SERVICE 'TService' v danom SCOPE este nebola vytvorena, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu SERVICE 'TService'. Ak vsak instancia SERVICE 'TService' v danom SCOPE uz bola vytvorena, DEPENDENCY INJECTION FRAMEWORK vracia existujuci instanciu a nova instancia sa uz NEVYTVARA. SCOPE typicky trva pocas spracovania 1 HTTP REQUEST.
   G. METHOD [IServiceCollection AddTransient<TService,TImplementation>()] umoznuje pridat SCOPED SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SCOPED SERVICE iba raz pocas celeho trvania daneho SCOPE. To znaci, ze ak instancia SERVICE 'TService' v danom SCOPE este nebola vytvorena, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu SERVICE 'TService'. Ak vsak instancia SERVICE 'TService' v danom SCOPE uz bola vytvorena, DEPENDENCY INJECTION FRAMEWORK vracia existujuci instanciu a nova instancia sa uz NEVYTVARA. SCOPE typicky trva pocas spracovania 1 HTTP REQUEST.
   H. METHOD [IServiceCollection AddTransient<TService,TImplementation>(Func<IServiceProvider,TImplementation> ImplementationFactory)] umoznuje pridat SCOPED SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SCOPED SERVICE iba raz pocas celeho trvania daneho SCOPE. To znaci, ze ak instancia SERVICE 'TService' v danom SCOPE este nebola vytvorena, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu SERVICE 'TService'. Ak vsak instancia SERVICE 'TService' v danom SCOPE uz bola vytvorena, DEPENDENCY INJECTION FRAMEWORK vracia existujuci instanciu a nova instancia sa uz NEVYTVARA. SCOPE typicky trva pocas spracovania 1 HTTP REQUEST.
   I. METHOD [IServiceCollection AddSingleton<TService>()] umoznuje pridat SINGLETON SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
   !!! J. METHOD [IServiceCollection AddSingleton<TService>(TService ImplementationInstance)] umoznuje pridat SINGLETON SERIVCE 'TService'. Instanciu SERVICE 'TService' DEPENDENCY INJECTION FRAMEWORK NEVYTVARA, ale vracia instanciu, ktora bola zaslana ako PARAMETER tejto METHOD. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
   K. METHOD [IServiceCollection AddSingleton<TService>(Func<IServiceProvider,TService> ImplementationFactory)] umoznuje pridat SINGLETON SERIVCE 'TService'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
   L. METHOD [IServiceCollection AddSingleton<TService,TImplementation>()] umoznuje pridat SINGLETON SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana volanim DEFAULT CONSTRUCTOR. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
   M. METHOD [IServiceCollection AddSingleton<TService,TImplementation>(Func<IServiceProvider,TImplementation> ImplementationFactory)] umoznuje pridat SINGLETON SERIVCE 'TService', ktory je implementovany pomocou CLASS 'TImplementation'. Instancia SERVICE 'TService' je vytvarana pomocou DELEGATE 'ImplementationFactory'. DEPENDENCY INJECTION FRAMEWORK vytvara instanciu SINGLETON SERVICE iba raz pocas celeho behu PROGRAMU a vzdy vracia REFERENCE na tu istu instanciu SERVICE 'TService'.
!!! 9. ASP.NET CORE DEPENDENCY INJECTION FRAMEWORK umoznuje CHAINING DEPENDENCY INJECTIONS. To znaci, ze ak DEPENDENCY INJECTION FRAMEWORK vytvara instanciu zaregistrovanej CLASS implementujucej hladany INTERFACE (eventualne BASE CLASS), preskumava CONSTRUCTOR tejto CLASS ci nahodou aj on nema CONSTRUCTOR PARAMETERS, ktorych TYPES su INTERFACES (eventualne BASE CLASSES). Ak ano, tak aj pre tieto sa pokusi vykonat RESOLVING DEPENDENCY INJECTION. A takto proces pokracuje, az kym vsetky zaregistrovane INTERFACES (eventualne BASE CLASSES) nie su RESOLVED. Nasledne je vytvorena instancia CLASS, ktora bola od DEPENDENCY INJECTION FRAMEWORK pozadovana.
!!! 10. Pri CHAINING DEPENDENCY INJECTIONS su instancie CHILD SERVICES vytvarane v case vytvorenia PARENT SERVICE. To znamena, ze LIFESCOPE CHILD SERVICE zavisly od LIFESCOPE PARENT SERVICE. Ak napriklad LIFESCOPE PARENT SERVICE je SCOPED, pricom tento vo svojom CONSTRUCTOR vyuziva TRANSIENT CHILD SERVICE, tak instancia tohto TRANSIENT CHILD SERVICE sa vytvori IBA v case vytvorenia SCOPED PARENT SERVICE, tak LIFESCOPE CHILD SERVICE je de-facto SCOPED, pretoze nova instancia TRANSIENT CHILD SERVICE je vytvorena az vtedy, ked je vytvorena nova instancia SCOPED CHILD SERVICE. Teda az v novom SCOPE.
11. ASP.NET CORE DEPENDENCY INJECTION FRAMEWORK umoznuje zaregistrovat aj konkretne typy CLASSES bez toho aby implementovali nejaky INTERFACE (eventualne BASE CLASS). Tieto CLASSES potom ASP.NET DEPENDENCY INJECTION FRAMEWORK subsituuje v CONSTRUCTORS rovnako ako CLASSES implementujuce dany INTERFACE (eventualne BASE CLASS).
12. Instancie SERVICES je mozne ziskat pomocou INTERFACE [IServiceProvider]. INTERFACE ma nasledujuce METHODS.
   A. METHOD [TService GetService<TService>()] vracia instanciu SERVICE, ktora implementuje TYPE 'TService'. V pripade, ze SERVICE NIE je zaregistrovany v DEPENDENCY INJECTION FRAMEWORK, METHOD vrati NULL VALUE.
   B. METHOD [object GetRequiredService(Type ServiceType)] vracia instanciu SERVICE, ktora implementuje TYPE 'ServiceType'. V pripade, ze SERVICE NIE je zaregistrovany v DEPENDENCY INJECTION FRAMEWORK, METHOD hodi EXCEPTION.
   C. METHOD [TService GetRequiredService<TService>()] vracia instanciu SERVICE, ktora implementuje TYPE 'TService'. V pripade, ze SERVICE NIE je zaregistrovany v DEPENDENCY INJECTION FRAMEWORK, METHOD hodi EXCEPTION.
   D. METHOD [IEnumerable<object> GetServices(Type ServiceType)] vracia vsetky instancie SERVICES, ktore implementuju TYPE 'ServiceType'. V pripade, ze SERVICE NIE je zaregistrovany v DEPENDENCY INJECTION FRAMEWORK, METHOD vrati EMPTY COLLECTION.
   E. METHOD [IEnumerable<TService> GetRequiredServices<TService>()] vracia vsetky instancie SERVICES, ktore implementuje TYPE 'TService'. V pripade, ze SERVICE NIE je zaregistrovany v DEPENDENCY INJECTION FRAMEWORK, METHOD vrati EMPTY COLLECTION.
   F. METHOD [IServiceScope CreateScope()] vytvori novy SCOPE.
13. ASP.NET CORE umoznuje pomocou METHODS STATIC CLASS [ActivatorUtilities] vytvarat v CODE instancie CLASSES, alebo SERVICES, ktore su zavisle na inych SERVICES, pricom DEPENDENCY INJECTION korektne naplni CONSTRUCTOR PARAMETERS instanciami pozadovanych SERVICES. CLASS [ActivatorUtilities] ma nasledujuce MEMBERS.
   A. METHOD [object CreateInstance<TType>(IServiceProvider Provider, Type InstanceType, params object[] Parameters)] vytvara instanciu TYPE 'InstanceType', pricom REKURZIVNE vykona DEPENDENCY INJECTION RESOLVING vsetkych CONSTRUCTOR PARAMETERS. PARAMETER 'Parameters' obsahuje CONSTRUCTOR PARAMETERS. Tieto PARAMETERS su pouzite, ako DEPENDENCY INJECTION FRAMEWORK nebol schopny vykonat RESOLVING vsetkych CONSTRUCTOR PARAMETERS.
   B. METHOD [TType CreateInstance<TType>(IServiceProvider Provider, params object[] Parameters)] vytvara instanciu TYPE 'TType', pricom REKURZIVNE vykona DEPENDENCY INJECTION RESOLVING vsetkych CONSTRUCTOR PARAMETERS. PARAMETER 'Parameters' obsahuje CONSTRUCTOR PARAMETERS. Tieto PARAMETERS su pouzite, ako DEPENDENCY INJECTION FRAMEWORK nebol schopny vykonat RESOLVING vsetkych CONSTRUCTOR PARAMETERS.
   C. METHOD [object GetServiceOrCreateInstance(IServiceProvider Provider, Type Type)] vytvara instanciu SERVICE TYPE 'Type'. V pripade, ze SERVICE TYPE 'Type' NIE je zaregistrovany v DEPENDENCY INJECTION FRAMEWORK, tak METHOD vytvori novu instanciu TYPE 'Type'. V oboch pripadoch REKURZIVNE vykona DEPENDENCY INJECTION RESOLVING vsetkych CONSTRUCTOR PARAMETERS.
   D. METHOD [TType GetServiceOrCreateInstance<TType>(IServiceProvider Provider)] vytvara instanciu SERVICE TYPE 'TType'. V pripade, ze SERVICE TYPE 'TType' NIE je zaregistrovany v DEPENDENCY INJECTION FRAMEWORK, tak METHOD vytvori novu instanciu TYPE 'TType'. V oboch pripadoch REKURZIVNE vykona DEPENDENCY INJECTION RESOLVING vsetkych CONSTRUCTOR PARAMETERS.
14. DEPENDENCY INJECTION FRAMEWORK umoznuje definovat pre kazdy SERVICE jeho LIFESCOPE. DEPENDENCY INJECTION FRAMEWORK definuje nasledujuce LIFESCOPES.
   A. TRANSIENT LIFESCOPE znamena, ze NOVA instancia daneho SERVICE je vytvorena VZDY ked o nu USER DEPENDENCY INJECTION FRAMEWORK poziada.
   B. SCOPED LIFESCOPE znamena, ze SERVICE LIFETIME trva pocas trvania JEDNEHO SCOPE. To znaci, ze ak v ramci daneho SCOPE je DEPENDENCY INJECTION FRAMEWORK poziadany o SERVICE a tento este v danom SCOPE nebol vytvoreny, tak DEPENDENCY INJECTION FRAMEWORK vytvori novu instanciu daneho SERVICE. Ak vsak v ramci toho isteho SCOPE je DEPENDENCY INJECTION FRAMEWORK poziadany o vratenie tejto SERVICE, tak je vratena UZ VYTVORENA instancia SERVICE. Ked sa SCOPE skonci, tak je SERVICE UVOLNENY a pre novy SCOPE sa vytvara nova instancia SERVICE. Prikladom jedneho SCOPE je spracovanie 1 HTTP REQUEST, ktory je spracovany v tom istom SCOPE.
   C. TRANSIENT LIFESCOPE znamena, ze NOVA instancia daneho SERVICE je vytvorena VZDY ked o nu USER DEPENDENCY INJECTION FRAMEWORK PRVYKRAT poziada. Pri nasledovnych poziadavkach o tento SERVICE uz nova instancia SERVICE NIE JE VYTVARANA a stale sa vracia uz vytvorena instancia daneho SERVICE.
15. ASP.NET CORE DEPENDENCY INJECTION FRAMEWORK podporuje SCOPES. Pre SCOPES platia nasledujuce fakty.
   A. SCOPE urcuje LIFETIME OBJECTS vytvaranych pomocou DEPENDENCY INJECTION FRAMEWORK.
   !!! B. Vsetky CLASSES zaregistrovane pomocou DEPENDENCY INJECTION FRAMEWORK, ktore boli zaregistrovane pomocou volania METHOD [IServiceCollection.AddScoped()] maju zivotvnost identicku so zivotnostou SCOPE. To znaci, ze pocas trvania SCOPE je pre kazdy TYPE zaregistrovany v DEPENDENCY INJECTION FRAMEWORK vytvorena iba 1 INSTANCIA daneho SERVICE, ktory je pocas celej doby SCOPE znova pouzity, bez toho, aby boli vytvarane nove instancie tohto SERVICE. Az po skonceni SCOPE je znova vytvarana nova instancia SERVICE.
   C. SCOPE je standardne nastaveny na spracovanie 1 HTTP REQUEST. To znaci, ze pre kazdu CLASS zaregistrovanu pomocou volania METHOD [IServiceCollection.AddScoped()] je vytvorena iba 1 INSTANCIA, ktora je pouzita pocas celeho spracovanie HTTP REQUEST na RESOLVING DEPENDENCY INJECTION.
   !!! D. ASP.NET umoznuje vytvarat aj CUSTOM SCOPES s vlastnym LIFETIME.
!!! 16. DEPENDENCY INJECTION FRAMEWORK je mozne pouzivat aj na urovni METHODS, ktore vola ASP.NET CORE. Napriklad ENDPOINT METHOD, ktoru vola ASP.NET CORE pri vykonani daneho ENDPOINT moze obsahovat PARAMETERS, ktorych VALUES su RESOLVED pomocou DEPENDENCY INJECTION FRAMEWORK.
17. ASP.NET CORE podporuje DEPENDENCY INJECTION aj v CONSTRUCTOR STARTUP CLASS. No ako PARAMETERS CONSTRUCTOR STARTUP CLASS je mozne definovat iba niektore SERVICES, ktore vytvara ASP.NET CORE pri svojej inicializacii ako napriklad SERVICE implementujuci INTERFACE [IConfiguration] obsahuju CONFIGURATION PROGRAMU.
!!! 18. ASP.NET CORE umoznuje vykonavat DEPENDENCY INJECTION aj na urovni ACTION METHODS.
   A. PARAMETERS ACTION METHODS, ktore maju byt RESOLVED pomocou DEPENDENCY INJECTION MUSIA byt oznacene pomocou ATTRIBUTE [FromServicesAttribute].
   B. ASP.NET CORE pri volani ACTION METHOD, ked zisti, ze niektore jej PARAMETERS su oznacene pomocou ATTRIBUTE [FromServicesAttribute], tak vykona DEPENDENCY INJECTION RESOLVING pre tieto PARAMETERS.
   !!! C. Vyhoda DEPENDENCY INJECTION na urovni ACTION METHODS spociva v tom, ze ked je vytvaranie instancii CLASSES zaregistrovanych v DEPENDENCY INJECTION FRAMEWORK casovo narocne, pricom tieto OBJECTS sa vyuzivaju iba v NIEKTORYCH ACTION METHODS, potom je zbytocne vytvarat tieto instancie v CONSTRUCTORS pri volani kazdej ACTION METHOD. DEPENDENCY INJECTION na urovni ACTION METHODS umoznuje vytarat instancie CLASS, iba ked sa realne pouziju.
19. ASP.NET CORE podporuje aj DEPENDENCY INJECTION CONTROLLER PROPERTIES. PROPERTIES CONTROLLER CLASSES musia byt oznacene ATTRIBUTES, aby ich ASP.NET CORE DEPENDENCY INJECTION FRAMEWORK vedel subsituovat.
   A. ATTRIBUTE [ControllerContextAttribute] naplni PROPERTY instanciu CLASS [ControllerContext].
   B. ATTRIBUTE [ActionContextAttribute] naplni PROPERTY instanciu CLASS [ActionContext].
   C. ATTRIBUTE [ViewContextAttribute] naplni PROPERTY instanciu CLASS [ViewContext].
   D. ATTRIBUTE [ViewComponentContextAttribute] naplni PROPERTY instanciu CLASS [ViewComponentContext].
   E. ATTRIBUTE [ViewDataDictionaryAttribute] naplni PROPERTY instanciu CLASS [ViewDataDictionary].
20. DEPENDENCY INJECTION FRAMEWORK umoznuje, aby bol jeden SERVICE implementovany viacerymi CLASSES. To znaci, ze pre SERVICE definovany INTERFACE (alebo BASE CLASS) mozu byt v DEPENDENCY INJECTION FRAMEWORK zaregistrovanie viacere CLASSES, ktore dany INTERFACE (BASE CLASS) implementuju. Pre SERVICE implementovany viacerymi CLASSES platia nasledujuce fakty.
   A. Ak dany SERVICE INTERFACE (BASE CLASS) implementuje viacero CLASSES, potom je potrebne OPAKOVANE volat METHODS CLASS [IServiceCollection] na registraciu kazdeho jedneho SERVICE.
   B. DEPENDENCY INJECTION FRAMEWORK pri vykonavani RESOLVING SERVICE implementovanej viacerymi CLASSES vracia VZDY POSLEDNU ZAREGISTROVANU CLASS.
   !!! C. DEPENDENCY INJECTION FRAMEWORK umoznuje ziskat VSETKY CLASSES, ktore implementuju dany SERVICE volanim METHOD [IEnumerable<object> IServiceProvider.GetServices(Type ServiceType)], alebo METHOD [IEnumerable<TService> IServiceProvider.GetRequiredServices<TService>()].
21. DEPENDENCY INJECTION FRAMEWORK umoznuje registrovat aj SERVICES, ktore maju NEDEFINOVANE GENERIC PARAMETERS. Pre SERVICES, ktore maju NEDEFINOVANE GENERIC PARAMETERS platia nasledujuce fakty.
   A. SERVICES sa registruju v DEPENDENCY INJECTION FRAMEWORK tak, ze sa NEDEFINUJU GENERIC TYPES. To znaci, ze GENERIC SERVICE TYPE, ani GENERIC CLASS, ktora implementuje GENERIC SERVICE INTERFACE (GENERIC BASE CLASS) volanim NON-GENERIC METHODS INTERFACE [IServiceCollection]. GENERIC METHODS INTERFACE [IServiceCollection] NEFUNGUJU.
   B. Pri DEPENDENCY INJECTION RESOLVING je NUTNE definovat NON-GENERIC TYPE. DEPENDENCY INJECTION FRAMEWORK nahradi GENERIC SERVICE TYPE za pozadovany NON-GENERIC CLASS.
//----------------------------------------------------------------------------------------------------------------------