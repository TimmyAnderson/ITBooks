//-----------------------------------------------------------------------------
1. Solution demonstruje pozitie CONTAINERS a ALGORITHMS v C++.
2. C++ STANDARD LIBRARY je definovana v NAMESPACE [std] a jeho SUBNAMESPACES.
3. LIBRARIES, ktorych nazov zacina PREFIXOM 'c' su WRAPPERS okolo C STANDARD LIBRARIES, pricom C STRUCTURES a F FUNCTIONS su definovane v NAMESPACE [std].
4. C++ STANDARD LIBRARY definuje pre VSETKY C STANDARD LIBRARIES verzie C++ STANDARD LIBRARIES s PREFIXOM 'c'.
5. C++ STANDARD LIBRARY obsahuje  nasledujuce LIBRARIES.
   1. LIBRARY <vector> implementuje dynamicky zvacsovatelne jednorozmerne ARRAY.
   2. LIBRARY <deque> implementuje QUEUE do ktorej mozno pridavat a odstranovat ITEM z oboch koncov.
   3. LIBRARY <forward_list> implementuje jednosmerny LIST.
   4. LIBRARY <list> implementuje dvojsmerny LIST.
   5. LIBRARY <map> implementuje SORTED DICTIONARY.
   6. LIBRARY <set> implementuje SORTED SET.
   7. LIBRARY <unordered_map> implementuje UNSORTED DICTIONARY.
   8. LIBRARY <unordered_set> implementuje UNSORTED SET.
   9. LIBRARY <queue> implementuje QUEUE.
   10. LIBRARY <stack> implementuje STACK.
   11. LIBRARY <array> implementuje jednorozmerne ARRAY o pevnej dlzke.
   12. LIBRARY <bitset> implementuje jednorozmerne ARRAY obsahujuce BOOL VALUES.
   13. LIBRARY <utility> implementuje PAIR a pomocne UTILITIES.
   14. LIBRARY <tuple> implementuje TUPLES.
   15. LIBRARY <type_traits> implementuje TYPE TRAITS pouzivane v METAPROGRAMMING.
   16. LIBRARY <typeindex> implementuje podporne UTILITIES na pouzitie CLASS [type_info] ako KEY, alebo HASH CODE.
   17. LIBRARY <functional> implementuje FUNCTION OBJECTS, ktore umoznuju ulozit CALLABLE OBJECTS ako su FUNCTIONS ci METHODS.
   18. LIBRARY <memory> implementuje SHARED POINTERS a UTILITIES na pracu s MEMORY.
   19. LIBRARY <scoped_allocator> implementuje SCOPED ALLOCATORS.
   20. LIBRARY <ratio> implementuje COMPILE-TIME aritmetiku nad racionalnymi cislami.
   21. LIBRARY <chrono> implementuje TIME UTILITY CLASSES pre pracu s relativnym casom.
   22. LIBRARY <ctime> implementuje C FUNCTIONS pre pracu s DATE a TIME.
   23. LIBRARY <iterator> implementuje ITERATORS a podpore UTILITIES pre pracu s ITERATORS.
   24. LIBRARY <algorithm> implementuje standardne ALGORITHMS.
   25. LIBRARY <cstdlib> implementuje standardne ALGORITHMS z jazyka C ako aj TERMINATION FUNCTION pre ukoncenie PROGRAMU.
   26. LIBRARY <exception> implementuje BASE EXCEPTION CLASS.
   27. LIBRARY <stdexcept> implementuje standardne EXCEPTION CLASSES.
   28. LIBRARY <stdexcept> implementuje C ASSERTS.
   29. LIBRARY <cerrno> implementuje C ERROR CODES pre spracovanie ERRORS z C FUNCTIONS.
   30. LIBRARY <system_error> implementuje UTILITIES pre spracovanie SYSTEM ERRORS.
   31. LIBRARY <string> implementuje STRING CLASS.
   32. LIBRARY <cctype> implementuje UTILITIES pre klasifikaciu CHARACTERS.
   33. LIBRARY <cwctype> implementuje UTILITIES pre klasifikaciu WIDE CHARACTERS.
   34. LIBRARY <cstring> implementuje UTILITIES pre pracu s C STRING.
   35. LIBRARY <cwchar> implementuje UTILITIES pre pracu s C WIDE STRING.
   36. LIBRARY <cstdlib> implementuje UTILITIES pre MEMORY ALLOCATION C FUNCTIONS.
   37. LIBRARY <cuchar> implementuje UTILITIES pre pracu s C MULTIBYTE CHARACTERS.
   38. LIBRARY <regex> implementuje REGULAR EXPRESSIONS.
   39. LIBRARY <iosfwd> implementuje FORWARD DECLARATIONS pre C++ STREAMS.
   40. LIBRARY <iostream> implementuje standardne C++ STREAMS a operacie nad nimi.
   41. LIBRARY <ios> implementuje BASE CLASSES pre C++ STREAMS.
   42. LIBRARY <streambuf> implementuje C++ STREAM BUFFERS.
   43. LIBRARY <istream> implementuje C++ INPUT STREAMS.
   44. LIBRARY <ostream> implementuje C++ OUTPUT STREAMS.
   45. LIBRARY <iomanip> implementuje MANIPULATORS nad C++ STREAMS.
   46. LIBRARY <sstream> implementuje C++ STREAMS nad STRINGS.
   47. LIBRARY <sstream> implementuje C++ STREAMS nad STRINGS.
   48. LIBRARY <fstream> implementuje C++ STREAMS nad FILES.
   49. LIBRARY <cstdio> implementuje C FUNCTIONS pre IO SYSTEM.
   50. LIBRARY <cwchar> implementuje WIDE CHARACTERS C FUNCTIONS pre IO SYSTEM.
   51. LIBRARY <locale> implementuje UTILITIES pre pouzivanie LOCALES.
   52. LIBRARY <clocale> implementuje C FUNCTIONS pre pouzivanie LOCALES.
   53. LIBRARY <codecvt> implementuje UTILITIES pre konverzie CHARACTERS.
   54. LIBRARY <limits> implementuje NUMERIC LIMITS.
   55. LIBRARY <climits> implementuje C MACROS pre NUMERIC LIMITS.
   56. LIBRARY <cfloat> implementuje C MACROS pre FLOAT NUMERIC LIMITS.
   57. LIBRARY <cstdint> implementuje standardizovane TYPES pre INTEGER TYPES.
   58. LIBRARY <new> implementuje DYNAMIC MEMORY MANAGEMENT vratane OPERATOR NEW a OPERATOR DELETE.
   59. LIBRARY <typeinfo> implementuje UTILITIES pre pracu s RUN TIME TYPE IDENTIFICATION.
   60. LIBRARY <initializer_list> implementuje CLASS umoznujucu inicializaciu COLLECTIONS cez SYNTAX [{}].
   61. LIBRARY <cstddef> implementuje standardne pomocne C FUNCTIONS.
   62. LIBRARY <cstdarg> implementuje C FUNCTIONS pre pracu s FUNCTIONS, ktore maju variabilny pocet PARAMETERS.
   63. LIBRARY <csetjmp> implementuje C FUNCTIONS pre STACK UNWINDING.
   64. LIBRARY <csignal> implementuje C FUNCTIONS pre SIGNAL HANDLING.
   65. LIBRARY <complex> implementuje komplexne cisla.
   66. LIBRARY <valarray> implementuje NUMERIC VALUES ARRAY nad ktorym je mozne vykonavat matematicke operacie.
   67. LIBRARY <numeric> implementuje standardizovane numericke C++ ALGORITHMS.
   68. LIBRARY <cmath> implementuje matematicke C FUNCTIONS.
   69. LIBRARY <random> implementuje C++ RANDOM GENERATORS.
   70. LIBRARY <atomic> implementuje atomicke operacie.
   71. LIBRARY <condition_variable> implementuje CONDITIONAL VARIABLES pouzivane na THREAD BLOCKING.
   72. LIBRARY <future> implementuje ASYNCHRONOUS TASKS.
   73. LIBRARY <mutex> implementuje MUTEXES pouzivane na THREAD SYNCHRONIZATION.
   74. LIBRARY <thread> implementuje THREADS.
   75. LIBRARY <cinttypes> implementuje C ALIASES pre INTEGER TYPES.
   76. LIBRARY <cstdbool> implementuje C verziu BOOL TYPE.
   77. LIBRARY <ccomplex> obsahuje INCLUDE na LIBRARY <complex>.
   78. LIBRARY <cfenv> implementuje FLOATING POINT ENVIRONMENT obsahujuci STATUS FLAGS a COMMAND MODES, ktorymi mozno ovplyvnit pracu s FLOATING POINTS.
   79. LIBRARY <cstdalign> obsahuje MACRO pre C ALIGNMENT.
   80. LIBRARY <ctgmath> obsahuje INCLUDE na LIBRARY <ccomplex> a LIBRARY <cmath>.
6. C++ STANDARD LIBRARY definuje nasledujuce LANGUAGE SUPPORT LIBRARIES.
   A. LIBRARY <new> definuje OPERATOR NEW a OPERATOR DELETE.
   B. LIBRARY <typeinfo> definuje OPERATOR typeid() a TYPE [type_info].
   C. LIBRARY <iterator> definuje RANGE-FOR SYNTAX.
   D. LIBRARY <initializer_list> definuje CLASS [initializer_list].
7. CLASS [basic_string<TCharacter,TTraits,TAllocator>] reprezentuje implementaciu STRING v C++. Pre [basic_string<TCharacter,TTraits,TAllocator>] platia nasleldujuce fakty.
   A. STRING je definovany v LIBRARY <string>.
   B. 1. TEMPLATE PARAMETER definuje TYPE pre CHARACTERS, ktore STRING pouziva.
   C. 2. TEMPLATE PARAMETER definuje TYPE pre TRAITS, ktory STRING pouziva.
   D. 3. TEMPLATE PARAMETER definuje TYPE pre ALLOCATOR, ktory STRING pouziva.
   E. C++ definuje instancie CLASS [hash<TCharacter>] pre CLASS [string], CLASS [wstring], CLASS [u16string] a CLASS [u32string]. Tieto CLASSES reprezentuju HASH CODES danych STRINGS.
8. CLASS [basic_string<TCharacter,TTraits,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu STRING. OVERLOADED VERSIONS reprezentuju COPY CONSTRUCTOR a MOVE CONSTRUCTOR. Dalsie OVERLOADED VERSIONS umoznuju vytvarat STRINGS z C-STRING ci ako SUBSTRINGS z inych STRINGS.
   2. DESTRUCTOR uvolnuje instanciu STRING.
   3. TYPE [traits_type] urcuje TYPE pre TYPE TRAITS STRING. Je rovny TEMPLATE PARAMETER 'TTraits'.
   4. TYPE [value_type] urcuje TYPE pre CHARACTERS ulozene v STRING. Je rovny TEMPLATE PARAMETER 'TCharacter'.
   5. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR. Je rovny TEMPLATE PARAMETER 'TAllocator'.
   6. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet pri praci so STRING.
   7. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel pri praci so STRING.
   8. TYPE [reference] urcuje REFERENCE TYPE pre CHARACTERS ulozene v STRING.
   9. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre CHARACTERS ulozene v STRING.
   10. TYPE [pointer] urcuje POINTER TYPE pre CHARACTERS ulozene v STRING.
   11. TYPE [const_pointer] urcuje CONST POINTER TYPE pre CHARACTERS ulozene v STRING.
   12. TYPE [iterator] urcuje TYPE pre ITERATOR daneho STRING.
   13. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR daneho STRING.
   14. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR daneho STRING.
   15. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR daneho STRING.
   !!! 16. STATIC CONSTANT [npos] identifikuje MAXIMALNU VALUE reprezentovatelnu TYPE [size_type]. Pouziva sa vo viacerych FIND METHODS na urcenie, ze hladany SUBSTRING sa v STRING nenasiel.
   17. OPERATOR= priradzuje do STRING CHARACTERS ineho STRING. STRING obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   18. OPERATOR== zistuje ci dve instancie STRING su lexikograficky rovne. OVERLOADED VERSION umoznuje porovnat STRING s C-STRING.
   19. OPERATOR!= zistuje ci dve instancie STRING su lexikograficky rozne. OVERLOADED VERSION umoznuje porovnat STRING s C-STRING.
   20. OPERATOR< zistuje ci 1. STRING je lexikograficky mensi ako 2. STRING. OVERLOADED VERSION umoznuje porovnat STRING s C-STRING.
   21. OPERATOR<= zistuje ci 1. STRING je lexikograficky mensi, alebo rovny ako 2. STRING. OVERLOADED VERSION umoznuje porovnat STRING s C-STRING.
   22. OPERATOR> zistuje ci 1. STRING je lexikograficky vacsi ako 2. STRING. OVERLOADED VERSION umoznuje porovnat STRING s C-STRING.
   23. OPERATOR>= zistuje ci 1. STRING je lexikograficky vacsi, alebo rovny ako 2. STRING. OVERLOADED VERSION umoznuje porovnat STRING s C-STRING.
   !!! 24. OPERATOR[] vracia REFERENCES k CHARACTERS daneho STRING. OPERATOR[] NEROBI kontrolu hranic daneho STRING. Pre INDEX rovny SIZE vracia NULL-CHARACTER.
   25. OPERATOR+ vytvara NOVU INSTANCIU STRING z dvojice existujucich instancii STRING. OVERLOADED VERSION umoznuje zlucovat aj STRINGS a C-STRINGS.
   26. OPERATOR+= do instancie STRING pridava CHARACTERS z inej instancie STRING. OVERLOADED VERSION umoznuje pridavat do STRINGS aj C-STRINGS.
   27. OPERATOR""s konvertuje C-STRING na instanciu STRING.
   28. OPERATOR basic_string_view() konvertuje STRING na instanciu CLASS [basic_string_view<TCharacter,TTraits>].
   29. OPERATOR<< zapise hodnotu STRING do OUTPUT STREAM.
   30. OPERATOR>> zapise hodnotu STRING z INPUT STREAM.
   !!! 31. METHOD at() vracia REFERENCES k CHARACTERS daneho STRING. METHOD ROBI kontrolu hranic STRING, a v pripade zistenia chybneho pristupu generuje EXCEPTION [out_of_range]. EXCEPTION [out_of_range] je generovana aj ked INDEX je rovny SIZE.
   32. METHOD assign() priradzuje do CHARACTERS ineho STRING do aktualnej instancie STRING. OVERLOADED VERSIONS umoznuje priradit CHARACTERS z C-STRING, alebo CHARACTERS z INITIALIZER LIST ci STRING VIEW.
   33. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani CHARACTERS daneho STRING.
   34. METHOD front() vracia REFERENCE na PRVY CHARACTER v STRING.
   35. METHOD back() vracia REFERENCE na POSLEDNY CHARACTER v STRING.
   36. METHOD data() vracia POINTER na interny BUFFER, ktory instancia STRING pouziva na ulozenie CHARACTERS.
   37. METHOD c_str() vracia CONST POINTER na interny BUFFER, ktory instancia STRING pouziva na ulozenie CHARACTERS.
   38. METHOD begin() vracia ITERATOR ukazujuci na PRVY CHARACTER STRING.
   39. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY CHARACTER STRING.
   40. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY CHARACTER STRING.
   41. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY CHARACTER STRING.
   42. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY CHARACTER STRING.
   43. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY CHARACTER STRING.
   44. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY CHARACTER STRING.
   45. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY CHARACTER STRING.
   46. METHOD empty() vracia informaciu ci STRING je prazdny.
   47. METHOD size() vracia pocet CHARACTERS vo STRING.
   48. METHOD length() vracia pocet CHARACTERS vo STRING.
   49. METHOD max_size() vracia maximalny pocet CHARACTERS, ktore je do STRING mozne ulozit.
   50. METHOD reserve() alokuje INTERNY BUFFER STRING na zadanu CAPACITY. Ak zadana velkost je mensia, alebo rovna aktualnemu poctu CHARACTERS v STRING, METHOD moze, ale NEMUSI skratit velkost BUFFER.
   51. METHOD capacity() vracia CAPACITY urcujucu pocet CHARACTERS na ktory je alokovany INTERNY BUFFER daneho STRING.
   !!! 52. METHOD shrink_to_fit() sa pokusi uvolnit INTERNY BUFFER daneho STRING, tak aby mal identicku dlzku ako realny pocet CHARACTERS v STRING. Tato METHOD je len POZIADAVKA na vykonanie SHRINK, ktora je implementacne zavisla. To znaci, ze v zavislosti od implementacie SHRINK moze, ale aj NEMUSI VYKONAT.
   53. METHOD clear() odstranuje vsetky CHARACTERS zo STRING. CAPACITY METHOD NEMENI.
   54. METHOD insert() pridava 1-N CHARACTERS PRED stanovenu poziciu v STRING. Pozicie sa urcuju pomocou ITERATORS.
   55. METHOD erase() odstranuje 1-N CHARACTERS na stanovenych poziciach v STRING. Pozicie sa urcuju pomocou ITERATORS.
   56. METHOD push_back() pridava CHARACTER na koniec STRING.
   57. METHOD pop_back() odstranuje 1 CHARACTER z konca STRING.
   58. METHOD append() pridava 1-N CHARACTERS na koniec STRING.
   59. METHOD compare() vykonava LEXIKOGRAFICKE POROVNANIE dvoch STRING. Vracia ZAPORNU VALUE ak [STRING_1<STRING_2], KLADNU VALUE ak [STRING_1>STRING_2] a 0 ak [STRING_1==STRING_2].
   60. METHOD replace() nahradzuje SUBSTRING inym SUBSTRING.
   61. METHOD substr() vracia SUBSTRING z daneho STRING.
   62. METHOD copy() kopiruje CHARACTERS daneho STRING do C-STRING.
   63. METHOD resize() meni pocet CHARACTERS v STRING na pocet stanoveny PARAMETER. V pripade, ze stanoveny pocet je MENSI ako pocet CHARACTERS v STRING, dochadza k ostraneniu ITEMS zo STRING. Ak je stanoveny pocet VACSI ako pocet CHARACTERS v STRING, dochadza k pridavaniu novych CHARACTERS do STRING, pricom OVERLOADED verzia METHOD umoznuje definovat CHARACTER, ktoreho kopia za priradi za nove CHARACTERS.
   64. METHOD swap() vymiena obsah dvoch instancii STRING vymenou ich vnutornych FIELDS.
   65. METHOD find() hlada PRVY vyskyt SUBSTRING v STRING, ktory je rovny zadanemu SUBSTRING. OVERLOADED VERSION umoznuje vyhladavat CHARACTER.
   66. METHOD rfind() hlada POSLEDNY vyskyt SUBSTRING v STRING, ktory je rovny zadanemu SUBSTRING. OVERLOADED VERSION umoznuje vyhladavat CHARACTER.
   67. METHOD find_first_of() v STRING hlada PRVY VYSKYT niektoreho zo zadanych CHARACTERS.
   68. METHOD find_first_not_of() v STRING hlada PRVY VYSKYT CHARACTER, ktory NIE JE ROVNY niektoremu zo zadanych CHARACTERS.
   69. METHOD find_last_of() v STRING hlada POSLEDNY VYSKYT niektoreho zo zadanych CHARACTERS.
   70. METHOD find_last_not_of() v STRING hlada POSLEDNY VYSKYT CHARACTER, ktory NIE JE ROVNY niektoremu zo zadanych CHARACTERS.
   71. FUNCTION swap() vymiena obsah dvoch instancii STRING vymenou ich vnutornych FIELDS.
   72. FUNCTION getline() nacitava CHARACTERS ukoncene NEW LINE CHARACTER z INPUT STREAM a ukada ich do instancie STRING.
   73. FUNCTION stoi() konvertuje STRING na TYPE [int].
   74. FUNCTION stol() konvertuje STRING na TYPE [long].
   75. FUNCTION stoll() konvertuje STRING na TYPE [long long].
   76. FUNCTION stoul() konvertuje STRING na TYPE [unsigned long].
   77. FUNCTION stoull() konvertuje STRING na TYPE [unsigned long long].
   78. FUNCTION stof() konvertuje STRING na TYPE [float].
   79. FUNCTION stod() konvertuje STRING na TYPE [double].
   80. FUNCTION stold() konvertuje STRING na TYPE [long double].
   81. FUNCTION to_string() konvertuje NUMBERIC VALUES na STRING.
   82. FUNCTION to_wstring() konvertuje NUMBERIC VALUES na WSTRING.
9. STREAM je v IO LIBRARY definovany ako C++ OBJECT, ktory reprezentuje tok CHARACTERS. Pre STREAMS platia nasledujuce fakty.
   A. OUTPUT je interpretovany ako tok dat DO STREAMU.
   B. INPUT je interpretovany ako tok dat ZO STREAMU.
   C. IO LIBRARY definuje GLOBAL OBJECTS, ktore reprezentuju STANDARD IO STREAMS.
   D. STREAMS su definovane ako TEMPLATES, ktore maju ako TEMPLATE PARAMETER CHARACTER TYPE urcujuci TYPE CHARACTERS nad ktorymi pracuju.
10. C++ IO LIBRARY definuje nasledujuce GLOBAL OBJECTS, ktore reprezentuju STANDARD IO STREAMS.
   A. CLASS [cin] reprezentuje STANDARD INPUT STREAM, ktory obaluje C STREAM [stdin].
   B. CLASS [cout] reprezentuje STANDARD OUTPUT STREAM, ktory obaluje C STREAM [stdout].
   C. CLASS [cerr] reprezentuje STANDARD OUTPUT ERROR STREAM, ktory obaluje C STREAM [stderr]. Vystup z CLASS [cerr] NIE JE BUFFERED.
   D. CLASS [clog] reprezentuje ERROR STREAM, ktory JE BUFFERED. Tento OBJECT NEMA analogiu v C STREAMS.
11. C++ IO LIBRARY definuje nasledujuce OPERATORS pre citanie a zapis dat do STREAMS.
   A. OPERATOR>> cita data zo STREAM.
   B. OPERATOR<< zapisuje data do STREAM.
12. C++ IO LIBRARY definuje mnozstvo MANIPULATORS, ktore umoznuju ovplyvnovat cinnost STREAMS. Pre MANIPULATORS platia nasledujuce fakty.
   A. MANIPULATORS umoznuju zmenit format dat, ktore menit format dat, ktore su citane a zapisovane do STREAMS.
   B. MANIPULATORS umoznuju vykonat rozlicne IO OPERATIONS nad STREAMS.
13. C++ IO LIBRARY definuje nasledujuce zakladne CLASSES.
   A. CLASS [ios_base] definuje zakladne PROPERTIES STREAMU, ktore su NEZAVISLE na type CHARACTERS a CHARACTER TRAITS nad ktorymi STREAM pracuje. CLASS [ios_base] obsahuje informacie o STREAM STATE a FORMATTING FLAGS.
   B. CLASS [basic_ios<TCharacter,TTraits>] definuje zakladne PROPERTIES STREAMU, ktore su ZAVISLE na type CHARACTERS a CHARACTER TRAITS nad ktorymi STREAM pracuje. CLASS [basic_ios<TCharacter,TTraits>] obsahuje STREAM BUFFER. STREAM BUFFER je instancia CLASS DERIVED z CLASS [basic_streambuf<TCharacter,TTraits>], ktora vykonava IO OPERATIONS nad specifikovanym STORE.
   C. CLASS [basic_istream<TCharacter,TTraits>] definuje zakladne INPUT OPERATIONS, ktore je mozne vykonavat nad STREAMS.
   D. CLASS [basic_ostream<TCharacter,TTraits>] definuje zakladne OUTPUT OPERATIONS, ktore je mozne vykonavat nad STREAMS.
   E. CLASS [basic_iostream<TCharacter,TTraits>] definuje zakladne INPUT OPERATIONS a OUTPUT OPERATIONS, ktore je mozne vykonavat nad STREAMS.
   F. CLASS [basic_streambuf<TCharacter,TTraits>] reprezentuje KLUCOVU CLASS IO LIBRARY. CLASS [basic_streambuf<TCharacter,TTraits>] definuje ZAKLADNY INTERFACE pre INPUT OPERATIONS a OUTPUT OPERATIONS, ktore je potrebne pre dany DATA STORE implementovat, aby nad nim bolo mozne realizovat STREAM OPERATIONS.
!!!!! 14. C++ IO LIBRARY je postavena na nasledujucich principoch.
   A. C++ IO LIBRARY rozdeluje INPUT a OUTPUT OPERATIONS a na FORMATTING OPERATIONS.
   !!! B. INPUT a OUTPUT OPERATIONS su implementovane v STREAM BUFFERS. STREAM BUFFERS su DERIVED z CLASS [basic_streambuf<TCharacter,TTraits>].
   !!! C. FORMATTING OPERATIONS su implementovane vo FORMATTERS. FORMATTERS su DERIVED z CLASS [basic_ios<TCharacter,TTraits>].
   !!!!! D. STREAM BUFFERS predstavuju ABSTRAKCIU DATA STORES. Implementuju LOW LEVEL INPUT a OUTPUT OPERATIONS nad danym DATA STORE ako napriklad STRING ci FILE.
   !!! E. STREAM BUFFERS NEOBSAHUJU ZIADNE FORMATTING OPERATIONS. FORMATTING OPERATIONS su implementovane vo FORMATTERS.
   !!! F. Prepojenie medzi FORMATTERS a STREAM BUFFERS je realizovane tak, ze FORMATTERS obsahuju FIELD reprezentujuci STREAM BUFFER nad ktorym dany FORMATTER pracuje.
   !!!!! G. Ak je potrebne podporit novy STREAM BUFFER (DATA STORE), staci implementovat CUSTOM CLASS, ktora bude DERIVED z CLASS [basic_streambuf<TCharacter,TTraits>]. Vdaka STRIKTNEMU oddeleniu medzi STREAM BUFFERS a FORMATTERS je potom na novy STREAM BUFFER mozne okamzite aplikovat implementovane FORMATTERS.
15. Na citanie dat z INPUT STREAMS sa v IO LIBRARY pouziva OPERATOR>>. Pre OPERATOR>> platia nasledujuce fakty.
   A. OPERATOR>> reprezentuje mechanizmus umoznujuci citat data z INPUT STREAMS.
   B. Ako 1. PARAMETER OPERATOR>> definuje instanciu CLASS [basic_istream<TCharacter,TTraits>]. Instancia CLASS [basic_istream<TCharacter,TTraits>] reprezentuje INPUT STREAM z ktoreho sa citaju data.
   C. Ako 2. PARAMETER OPERATOR>> definuje OBJECT, ktory ma byt nacitany zo STREAM. STANDARD LIBRARY definuje OPERATOR>> pre vsetky PRIMITIVE TYPES aj viacere TYPES C++ STANDARD LIBRARY.
   D. Ako RETURN VALUE OPERATOR>> definuje instanciu CLASS [basic_istream<TCharacter,TTraits>]. Vratenie instancie CLASS [basic_istream<TCharacter,TTraits>] umoznuje OPERATOR CHAINING.
16. Na zapis dat do OUTPUT STREAMS sa v IO LIBRARY pouziva OPERATOR<<. Pre OPERATOR<< platia nasledujuce fakty.
   A. OPERATOR<< reprezentuje mechanizmus umoznujuci zapisovat data do OUTPUT STREAMS.
   B. Ako 1. PARAMETER OPERATOR<< definuje instanciu CLASS [basic_ostream<TCharacter,TTraits>]. Instancia CLASS [basic_ostream<TCharacter,TTraits>] reprezentuje OUTPUT STREAM do ktoreho sa zapisuju data.
   C. Ako 2. PARAMETER OPERATOR<< definuje OBJECT, ktory ma byt zapisany do STREAM. STANDARD LIBRARY definuje OPERATOR<< pre vsetky PRIMITIVE TYPES aj viacere TYPES C++ STANDARD LIBRARY.
   D. Ako RETURN VALUE OPERATOR<< definuje instanciu CLASS [basic_ostream<TCharacter,TTraits>]. Vratenie instancie CLASS [basic_ostream<TCharacter,TTraits>] umoznuje OPERATOR CHAINING.
17. C++ STREAMS su STATEFUL OBJECTS. Pre C++ STREAM STATES platia nasledujuce fakty.
   A. C++ STREAM STATES reprezentuje PUBLIC STATE daneho STREAM. Obsahuje informaciu o tom ci STREAM je v korektnom, alebo chybnom stave a ci chyba je nefatalna, alebo fatalna.
   B. C++ STREAM STATES su definovane ako CONSTANTS v CLASS [ios_base]. TYPE C++ STREAM STATES je PLATFORM DEPENDENT.
   C. C++ STREAM STATES su reprezentovane ako FLAGS, a preto C++ STREAM moze v danom case nadobudat naraz VIACERO STATES.
   !!!!! D. C++ STREAM BUFFERS NIE SU STATEFUL OBJECTS. Iba C++ STREAMS su STATEFUL OBJECTS.
   E. C++ STREAM STATE je definovany ako FIELD v CLASS [basic_ios<TCharacter,TTraits>].
   !!! F. Ak je STREAM v niektorom z ERROR STATES, potom pre uspesne vykonanie nasledujucej IO OPERATION (ak STREAM uplne nezlyhal) je nutne EXPLICITNE zmenit STREAM STATE volanim METHOD basic_ios<TCharacter,TTraits>::clear().
18. Implementacia IO OPERATIONS nad C++ STREAMS pre CUSTOM CLASSES vyzaduje implementaciu nasledujucich OPERATORS.
   A. Pre citanie instancii CUSTOM CLASSES z C++ STREAM je nutne implementovat NON-MEMBER OPERATOR>> s PROTOTYPE [istream& operator>>(istream& Stream, CUSTOM_CLASS& Object)].
   B. Pre zapis instancii CUSTOM CLASSES do C++ STREAM je nutne implementovat NON-MEMBER OPERATOR<< s PROTOTYPE [ostream& operator<<(ostream& Stream, const CUSTOM_CLASS& Object)].
19. Ak CUSTOM CLASS sa nachadza v CLASS HIERARCHY ju implementaciu IO OPERATIONS pre citanie a zapis instancie CUSTOM CLASSES z C++ STREAMS nutne vykonat nasledujucim sposobom.
   A. BASE CLASS v CLASS HIERARCHY musia definovat PUBLIC VIRTUAL METHODS pre citanie a zapis svojich FIELDS do C++ STREAM. V pripade, ze BASE CLASS nie je ABSTRACT, tak PUBLIC VIRTUAL METHODS implementuju aj realne citanie a zapis dat, inak su deklarovane ako PURE VIRTUAL.
   B. BASE CLASS definuje OPERATOR>> a OPERATOR<<, ktore volaju PUBLIC VIRTUAL METHODS BASE CLASS.
   C. DERIVED CLASSES implementuju OVERLOADED PUBLIC VIRTUAL METHODS pre citanie a zapis svojich FIELDS do C++ STREAM.
   !!! D. DERIVED CLASSES uz NEIMPLEMENTUJU OPERATOR>> a OPERATOR<<. Pri vykonani IO OPERATIONS sa volaju OPERATOR>> a OPERATOR<< BASE CLASS.
!!! 20. Pre implementaciu OPERATOR<< a OPERATOR>> platia nasledujuce odporucania.
   A. Pri implementacii OPERATOR<< ak CLASS ma viacero FIELDS je vhodne OPERATOR>> implementovat tak, ze interne pouzije STRING STREAM do ktoreho vykona zapis svojich FIELDS a az obsah STRING STREAM zapise do C++ STREAM. Tento mechanizmus umoznuje vyporiadat sa s FORMATTING FLAG [width], ktory je po PRVOM volanie OPERATOR<< AUTOMATICKY nastaveny na 0 a teda pri opakovanom volani OPERATOR<< nad C++ STREAM by sa aplikoval iba na jeho prve volanie.
   B. OPERATOR<< a OPERATOR>> je vhodne implementovat ako TEMPLATE OPERATOR s CHARACTER TYPE ako TEMPLATE PARAMETER. Takato implementacia umoznuje citanie a zapis pre rozlicne typy CHARACTERS.
21. C++ STREAMS umoznuju ukladat CUSTOM DATA priamo do C++ STREAM OBJECTS. Pre CUSTOM DATA asociavane s C++ STREAMS platia nasledujuce fakty.
   A. CUSTOM DATA mozu byt TYPE [int] a TYPE [void*].
   B. CUSTOM DATA su ulozene ako ARRAYS v CLASS [ios_base].
   C. Pristup ku CUSTOM DATA je vykonavany prostrednictvom METHOD ios_base::iword() a METHOD ios_base::pword().
   !!! D. Pri pristupe ku CUSTOM DATA sa pouziva INDEX, ktory je vygenerovany volanim STATIC METHOD ios_base::xalloc(). STATIC METHOD ios_base::xalloc() je THREAD SAFE METHODS, ktora generuje UNIKATNY INDEX pomocou ktoreho je mozne pristupovat ku CUSTOM DATA v kazdej instancii C++ STREAM OBJECT.
   !!! E. Platnost dat v CUSTOM DATA konci PRVYM VOLANIM METHOD ios_base::iword(), alebo METHOD ios_base::pword(). Preto by CUSTOM DATA NEMALI byt trvalo ukladane do inych VARIABLES.
   F. CUSTOM DATA sa primarne pouzivaju na prenos FORMATTING DATA medzi MANIPULATORS a IO OPERATIONS pre dany C++ STREAM.
   !!!!! G. METHOD ios_base::copyfmt() vykonava kopiu FORMAT FLAGS, VRATANE CUSTOM DATA ARRAYS. To sposobuje PROBLEM, pretoze tie iste CUSTOM DATA mozu byt v vdaka tomu SHARED medzi VIACERYMI INSTANCIAMI C++ STREAMS. Riesenim je pouzitie USER DEFINED CALLBACKS v C++ STREAMS, ktore su volane pri volani METHOD ios_base::copyfmt() a umoznuju vytvorit DEEP COPY FORMATTING OBJECTS ulozenych v CUSTOM DATA ARRAYS. Pomocou USER DEFINED CALLBACKS je mozne CUSTOM DATA aj odstranit pri odstranovani instancie C++ STREAM.
22. CUSTOM DATA sa v C++ STREAMS pouzivaju nasledujucim sposobom.
   A. Pre CUSTOM DATA sa volanim STATIC METHOD ios_base::xalloc() vytvori UNIKATNY INDEX, ktory sa pouzije na pristup k CUSTOM DATA. Tento INDEX MUSI BYT UNIKATNY a to znamena, ze pre kazde CUSTOM DATA sa STATIC METHOD ios_base::xalloc() vola IBA RAZ.
   B. CUSTOM MANIPULATORS pouzivaju vygenerovany INDEX na zapis CUSTOM DATA do CUSTOM DATA ARRAY daneho C++ STREAM.
   C. IO OPERATIONS pouzivaju vygenerovany INDEX na citanie CUSTOM DATA zo CUSTOM DATA ARRAY daneho C++ STREAM.
   !!!!! D. Ak CUSTOM DATA obsahuju OBJECTS, je nutne implementovat USER DEFINED CALLBACKS, ktore vytvoria DEEP COPY tychto OBJECTS pri volani METHOD ios_base::copyfmt() a odstrania CUSTOM DATA pri odstranovani instancie C++ STREAM.
23. CLASS [array<TItem,N>] reprezentuje TEMPLATE CLASS, ktora je WRAPPER nad klasickym C-ARRAY. Pre CLASS [array<TItem,N>] platia nasledujuce fakty.
   A. ARRAY je definovany v LIBRARY <array>.
   B. ARRAY ma konstatny pocet ITEMS, ktory sa definuje ako TEMPLATE PARAMETER a je teda sucastou TYPE.
   C. Do ARRAY nie je mozne ITEMS pridavat, ani ich z nej odstranovat.
   D. ARRAY umoznuje RANDOM ACCESS k ITEMS, ktore su v nom ulozene.
   E. PERFORMANCE ARRAY nie je horsia ako PERFORMANCE C-ARRAY.
   !!!!! F. Instancia ARRAY je spravidla alokovana na STACK a NIE na HEAP. Iba pre velke ARRAYS su tieto alokovane na HEAP.
   !!! G. Pri praci s ARRAY NEDOCHADZA k realokacii MEMORY.
   !!! H. ARRAY GARANTUJE, ze ITEMS su ulozene VZDY v KONTINUALNOM BLOKU MEMORY.
24. CLASS [array<TItem,N>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu ARRAY a vytvara jednotlive ITEMS. COPY CONSTRUCTOR a MOVE CONSTRUCTOR su IMPLICITNE generovane COMPILER.
   2. DESTRUCTOR uvolnuje instanciu ARRAY ako aj jednotlive ITEMS. DESTRUCTOR je IMPLICITNE generovany COMPILER.
   3. TYPE [value_type] urcuje TYPE pre ITEMS ulozene v ARRAY.
   4. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   5. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   6. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v ARRAY.
   7. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v ARRAY.
   8. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v ARRAY.
   9. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v ARRAY.
   10. TYPE [iterator] urcuje TYPE pre ITERATOR daneho ARRAY.
   11. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR daneho ARRAY.
   12. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR daneho ARRAY.
   13. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR daneho ARRAY.
   14. OPERATOR= prepisuje jednotlive ITEMS daneho ARRAY. COPY OPERATOR= a MOVE OPERATOR= su IMPLICITNE generovane COMPILER.
   15. OPERATOR== zistuje ci dve instancie ARRAY su lexikograficky rovne.
   16. OPERATOR!= zistuje ci dve instancie ARRAY su lexikograficky rozne.
   17. OPERATOR< zistuje ci 1. ARRAY je lexikograficky mensi ako 2. ARRAY.
   18. OPERATOR<= zistuje ci 1. ARRAY je lexikograficky mensi, alebo rovny ako 2. ARRAY.
   19. OPERATOR> zistuje ci 1. ARRAY je lexikograficky vacsi ako 2. ARRAY.
   20. OPERATOR>= zistuje ci 1. ARRAY je lexikograficky vacsi, alebo rovny ako 2. ARRAY.
   !!! 21. OPERATOR[] vracia REFERENCES k ITEMS daneho ARRAY. OPERATOR[] NEROBI kontrolu hranic ARRAY.
   !!! 22. METHOD at() vracia REFERENCES k ITEMS daneho ARRAY. METHOD array<TItem,N>.at() ROBI kontrolu hranic ARRAY, a v pripade zistenia chybneho pristupu generuje EXCEPTION [out_of_range].
   23. METHOD front() vracia REFERENCE na PRVY ITEM v ARRAY.
   24. METHOD back() vracia REFERENCE na POSLEDNY ITEM v ARRAY.
   25. METHOD data() vracia POINTER na interny C-ARRAY, ktory instancia ARRAY zapuzdruje.
   26. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM ARRAY.
   27. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM ARRAY.
   28. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM ARRAY.
   29. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM ARRAY.
   30. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM ARRAY.
   31. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM ARRAY.
   32. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM ARRAY.
   33. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM ARRAY.
   34. METHOD empty() vracia informaciu ci ARRAY je prazdne.
   35. METHOD size() vracia pocet ITEMS v ARRAY. Tato hodnota je konstantna a je rovna hodnote TEMPLATE PARAMETER 'N'.
   36. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do ARRAY mozne ulozit.
   37. METHOD fill() nastavuje hodnotu kazdeho ITEM na hodnotu definovanu PARAMETER tejto METHOD.
   !!! 38. METHOD swap() vymiena obsah dvoch instancii ARRAY vymenou kopirovanim VSETKYCH ITEMS ARRAY. To je ZASADNY ROZDIEL oproti implementaciam METHOD swap() pre ine CONTAINERS, ktore su implementovane tak, ze dochadza iba k vymene vnutornych FIELDS a nerobi sa kopirovanie ITEMS.
   !!! 39. FUNCTION swap() vymiena obsah dvoch instancii ARRAY kopirovanim VSETKYCH ITEMS ARRAY. To je ZASADNY ROZDIEL oproti implementaciam FUNCTION swap() pre ine CONTAINERS, ktore su implementovane tak, ze dochadza iba k vymene vnutornych FIELDS a nerobi sa kopirovanie ITEMS.
   40. FUNCTION get<X>() vracia REFERENCE na 'X'-ty ITEM daneho ARRAY.
25. CLASS [vector<TItem,TAllocator>] reprezentuje DYNAMIC ARRAY. Pre CLASS [vector<TItem,TAllocator>] platia nasledujuce fakty.
   A. VECTOR je definovany v LIBRARY <vector>.
   B. VECTOR reprezentuje DYNAMIC ARRAY, ktory umoznuje EFEKTIVNE pridavat a odoberat ITEMS z konca VECTOR.
   C. VECTOR umoznuje v 2. TEMPLATE PARAMETER definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii VECTOR.
   !!! D. VECTOR spravidla alokuje interny BUFFER pre vacsi pocet ITEMS ako su vo VECTOR realne ulozene. To umoznuje vysoku PERFORMANCE pri pridavani a odstranovani ITEMS z konca VECTOR, pretoze pri pridavani ITEMS, pokial nie je prekrocena kapacita interneho BUFFER, NIE JE NUTNE vykonat casovo narocnu realokaciu. Ta je nutna az ked pri pridavani ITEM je tato kapacita prekrocena.
   E. VECTOR umoznuje RANDOM ACCESS k jednotlivym ITEMS.
   F. VECTOR ma vysoku PERFORMANCE pri pridavani a odstranovani ITEMS z konca VECTOR.
   G. VECTOR ma nizku PERFORMANCE pri pridavani a odstranovani ITEMS zo zaciatku a zo stredu VECTOR.
   !!!!! H. VECTOR pri realokacii interneho BUFFER NEVOLA COPY OPERATOR= ani MOVE OPERATOR=. ITEMS sa presunu do noveho BUFFER pomocou RAW COPY MEMORY.
26. CLASS [vector<TItem,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu VECTOR. OVERLOADED verzia umoznuje alokovat zadany pocet ITEMS, pricom pre tieto ITEMS je volany DEFAULT CONSTRUCTOR.
   2. DESTRUCTOR uvolnuje instanciu VECTOR ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [value_type] urcuje TYPE pre ITEMS ulozene vo VECTOR.
   4. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   5. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   7. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene vo VECTOR.
   8. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene vo VECTOR.
   9. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene vo VECTOR.
   10. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene vo VECTOR.
   11. TYPE [iterator] urcuje TYPE pre ITERATOR daneho VECTOR.
   12. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR daneho VECTOR.
   13. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR daneho VECTOR.
   14. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR daneho VECTOR.
   15. OPERATOR= priradzuje do VECTOR ITEMS ineho VECTOR. VECTOR obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   16. OPERATOR== zistuje ci dve instancie VECTOR su lexikograficky rovne.
   17. OPERATOR!= zistuje ci dve instancie VECTOR su lexikograficky rozne.
   18. OPERATOR< zistuje ci 1. VECTOR je lexikograficky mensi ako 2. VECTOR.
   19. OPERATOR<= zistuje ci 1. VECTOR je lexikograficky mensi, alebo rovny ako 2. VECTOR.
   20. OPERATOR> zistuje ci 1. VECTOR je lexikograficky vacsi ako 2. VECTOR.
   21. OPERATOR>= zistuje ci 1. VECTOR je lexikograficky vacsi, alebo rovny ako 2. VECTOR.
   !!! 22. OPERATOR[] vracia REFERENCES k ITEMS daneho VECTOR. OPERATOR[] NEROBI kontrolu hranic VECTOR.
   !!! 23. METHOD at() vracia REFERENCES k ITEMS daneho VECTOR. METHOD vector<TItem,TAllocator>.at() ROBI kontrolu hranic VECTOR, a v pripade zistenia chybneho pristupu generuje EXCEPTION [out_of_range].
   24. METHOD assign() priradzuje do VECTOR ITEMS ineho CONTAINER, ktory je definovany pomocou paru ITERATORS. OVERLOADED VERSION umoznuje priradit 'N' krat kopiu zadaneho ITEMS, alebo ITEMS z INITIALIZER LIST.
   25. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS daneho VECTOR.
   26. METHOD front() vracia REFERENCE na PRVY ITEM vo VECTOR.
   27. METHOD back() vracia REFERENCE na POSLEDNY ITEM vo VECTOR.
   28. METHOD data() vracia POINTER na interny BUFFER, ktory instancia ARRAY pouziva na ulozenie ITEMS.
   29. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM VECTOR.
   30. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM VECTOR.
   31. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM VECTOR.
   32. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM VECTOR.
   33. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM VECTOR.
   34. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM VECTOR.
   35. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM VECTOR.
   36. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM VECTOR.
   37. METHOD empty() vracia informaciu ci VECTOR je prazdny.
   38. METHOD size() vracia pocet ITEMS vo VECTOR.
   39. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do VECTOR mozne ulozit.
   40. METHOD reserve() alokuje INTERNY BUFFER VECTOR na zadanu CAPACITY. Ak zadana velkost je mensia, alebo rovna aktualnemu poctu ITEMS vo VECTOR, METHOD nerobi nic.
   41. METHOD capacity() vracia CAPACITY urcujucu pocet ITEMS na ktory je alokovany INTERNY BUFFER VECTOR.
   !!! 42. METHOD shrink_to_fit() sa pokusi uvolnit INTERNY BUFFER daneho VECTOR, tak aby mal identicku dlzku ako realny pocet ITEMS vo VECTOR. Tato METHOD je len POZIADAVKA na vykonanie SHRINK, ktora je implementacne zavisla. To znaci, ze v zavislosti od implementacie SHRINK moze, ale aj NEMUSI VYKONAT.
   43. METHOD clear() odstranuje vsetky ITEMS z VECTOR. CAPACITY METHOD NEMENI.
   44. METHOD insert() pridava 1-N ITEMS PRED stanovenu poziciu vo VECTOR. Pozicie sa urcuju pomocou ITERATORS.
   45. METHOD emplace() pridava ITEM PRED stanovenu poziciu vo VECTOR pomocou PLACEMENT NEW. PARAMETERS METHOD vector<TItem,TAllocator>.emplace() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do VECTOR.
   46. METHOD erase() odstranuje 1-N ITEMS na stanovenych poziciach vo VECTOR. Pozicie sa urcuju pomocou ITERATORS.
   47. METHOD push_back() pridava ITEM na koniec VECTOR.
   48. METHOD emplace_back() pridava ITEM na koniec VECTOR pomocou PLACEMENT NEW. PARAMETERS METHOD emplace_back() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do VECTOR.
   49. METHOD pop_back() odstranuje 1 ITEM z konca VECTOR.
   50. METHOD resize() meni pocet ITEMS vo VECTOR na pocet stanoveny PARAMETER METHOD vector<TItem,TAllocator>.resize(). V pripade, ze stanoveny pocet je MENSI ako pocet ITEMS vo VECTOR, dochadza k ostraneniu ITEMS z VECTOR. Ak je stanoveny pocet VACSI ako pocet ITEMS vo VECTOR, dochadza k pridavaniu novych ITEMS do VECTOR, pricom OVERLOADED verzia METHOD vector<TItem,TAllocator>.resize() umoznuje definovat ITEM, ktoreho kopia za priradi za nove ITEMS.
   51. METHOD swap() vymiena obsah dvoch instancii VECTOR vymenou ich vnutornych FIELDS.
   52. FUNCTION swap() vymiena obsah dvoch instancii VECTOR vymenou ich vnutornych FIELDS.
27. CLASS [deque<TItem,TAllocator>] reprezentuje DOUBLE ENDED QUEUE. Pre CLASS [deque<TItem,TAllocator>] platia nasledujuce fakty.
   A. DEQUEUE je definovana v LIBRARY <deque>.
   B. DEQUEUE reprezentuje DOUBLE ENDED QUEUE, ktora umoznuje EFEKTIVNE pridavat a odoberat ITEMS zo zaciatku a konca DEQUEUE.
   C. DEQUEUE umoznuje v 2. TEMPLATE PARAMETER definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii DEQUEUE.
   !!!!! D. DEQUEUE je interne reprezentovana ako 2 DIMENSIONAL ARRAY, kde kazdy ROW obsahuje MEMORY BLOCK umoznujuci ulozit 'N' ITEMS. Prvy a posledny MEMORY BLOCK maju spravidla mensi pocet ako 'N' ITEMS a az ked sa naplnia, je pridany novy MEMORY BLOCK do DEQUEUE.
   !!!!! E. Pristup k ITEMS v DEQUEUE je o MALICKO POMALSI ako v pripade VECTOR, pretoze su nutne DVOJNASOBNE DEREFERENCOVANIE POINTER. PRVYM DEREFERENCOVANIM sa urci MEMORY BLOCK v ktorom sa ITEM nachadza a DRUHYM DEREFERENCOVANIM sa urci ITEM v MEMORY BLOCK.
   !!! F. DEQUEUE na rozdiel od VECTOR NEGARANTUJE, ze ITEMS su ulozene v KONTINUALNOM MEMORY BLOCK.
   !!! G. DEQUEUE umoznuje RANDOM ACCESS k jednotlivym ITEMS. ITERATOR je vsak implementovany ako STRUCTURE a nie iba ako obycajny POINTER ako je to v pripade VECTORS.
   H. DEQUEUE ma vysoku PERFORMANCE pri pridavani a odstranovani ITEMS zo zaciatku a konca DEQUEUE.
   I. DEQUEUE ma nizku PERFORMANCE pri pridavani a odstranovani ITEMS zo zo stredu DEQUEUE.
   J. Po pridani, alebo odstraneni ITEM zo stredu DEQUEUE (mimo zaciatku a konca) su VSETKY ITERATORS, REFERENCES a POINTERS NEPLATNE.
28. CLASS [deque<TItem,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu DEQUEUE. OVERLOADED VERSIONS umoznuju alokovat zadany pocet ITEMS, pricom pre tieto ITEMS je volany DEFAULT CONSTRUCTOR, alebo sa vytvoria kopie zadaneho ITEM.
   2. DESTRUCTOR uvolnuje instanciu DEQUEUE ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [value_type] urcuje TYPE pre ITEMS ulozene vo DEQUEUE.
   4. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   5. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   7. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v DEQUEUE.
   8. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v DEQUEUE.
   9. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v DEQUEUE.
   10. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v DEQUEUE.
   11. TYPE [iterator] urcuje TYPE pre ITERATOR danej DEQUEUE.
   12. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej DEQUEUE.
   13. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR danej DEQUEUE.
   14. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR danej DEQUEUE.
   15. OPERATOR= priradzuje do DEQUEUE ITEMS inej DEQUEUE. DEQUEUE obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   16. OPERATOR== zistuje ci dve instancie DEQUEUE su lexikograficky rovne.
   17. OPERATOR!= zistuje ci dve instancie DEQUEUE su lexikograficky rozne.
   18. OPERATOR< zistuje ci 1. DEQUEUE je lexikograficky mensia ako 2. DEQUEUE.
   19. OPERATOR<= zistuje ci 1. DEQUEUE je lexikograficky mensia, alebo rovna ako 2. DEQUEUE.
   20. OPERATOR> zistuje ci 1. DEQUEUE je lexikograficky vacsia ako 2. DEQUEUE.
   21. OPERATOR>= zistuje ci 1. DEQUEUE je lexikograficky vacsia, alebo rovna ako 2. DEQUEUE.
   !!! 22. OPERATOR[] vracia REFERENCES k ITEMS danej DEQUEUE. OPERATOR[] NEROBI kontrolu hranic DEQUEUE.
   !!! 23. METHOD at() vracia REFERENCES k ITEMS danej DEQUEUE. METHOD deque<TItem,TAllocator>.at() ROBI kontrolu hranic DEQUEUE, a v pripade zistenia chybneho pristupu generuje EXCEPTION [out_of_range].
   24. METHOD assign() priradzuje do DEQUEUE ITEMS ineho CONTAINER, ktory je definovany pomocou paru ITERATORS. OVERLOADED VERSION umoznuje priradit 'N' krat kopiu zadaneho ITEMS, alebo ITEMS z INITIALIZER LIST.
   25. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej DEQUEUE.
   26. METHOD front() vracia REFERENCE na PRVY ITEM v DEQUEUE.
   27. METHOD back() vracia REFERENCE na POSLEDNY ITEM v DEQUEUE.
   28. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM DEQUEUE.
   29. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM DEQUEUE.
   30. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM DEQUEUE.
   31. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM DEQUEUE.
   32. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM DEQUEUE.
   33. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM DEQUEUE.
   34. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM DEQUEUE.
   35. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM DEQUEUE.
   36. METHOD empty() vracia informaciu ci DEQUEUE je prazdna.
   37. METHOD size() vracia pocet ITEMS vo DEQUEUE.
   38. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do DEQUEUE mozne ulozit.
   !!! 39. METHOD shrink_to_fit() sa pokusi uvolnit INTERNU MEMORY, ktoru pouziva DEQUEUE, tak aby mala identicku dlzku ako realny pocet ITEMS v DEQUEUE. Tato METHOD je len POZIADAVKA na vykonanie SHRINK, ktora je implementacne zavisla. To znaci, ze v zavislosti od implementacie SHRINK moze, ale aj NEMUSI VYKONAT.
   40. METHOD clear() odstranuje vsetky ITEMS z DEQUEUE.
   41. METHOD insert() pridava 1-N ITEMS PRED stanovenu poziciu v DEQUEUE. Pozicie sa urcuju pomocou ITERATORS.
   42. METHOD emplace() pridava ITEM PRED stanovenu poziciu v DEQUEUE pomocou PLACEMENT NEW. PARAMETERS METHOD deque<TItem,TAllocator>.emplace() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do DEQUEUE.
   43. METHOD erase() odstranuje 1-N ITEMS na stanovenych poziciach v DEQUEUE. Pozicie sa urcuju pomocou ITERATORS.
   44. METHOD push_front() pridava ITEM na zaciatok DEQUEUE.
   45. METHOD emplace_front() pridava ITEM na zaciatok DEQUEUE pomocou PLACEMENT NEW. PARAMETERS METHOD emplace_back() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do DEQUEUE.
   46. METHOD pop_front() odstranuje 1 ITEM zo zaciatku DEQUEUE.
   47. METHOD push_back() pridava ITEM na koniec DEQUEUE.
   48. METHOD emplace_back() pridava ITEM na koniec DEQUEUE pomocou PLACEMENT NEW. PARAMETERS METHOD emplace_back() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do DEQUEUE.
   49. METHOD pop_back() odstranuje 1 ITEM z konca DEQUEUE.
   50. METHOD resize() meni pocet ITEMS v DEQUEUE na pocet stanoveny PARAMETER METHOD deque<TItem,TAllocator>.resize(). V pripade, ze stanoveny pocet je MENSI ako pocet ITEMS v DEQUEUE, dochadza k ostraneniu ITEMS z DEQUEUE. Ak je stanoveny pocet VACSI ako pocet ITEMS v DEQUEUE, dochadza k pridavaniu novych ITEMS do DEQUEUE, pricom OVERLOADED verzia METHOD deque<TItem,TAllocator>.resize() umoznuje definovat ITEM, ktoreho kopia za priradi za nove ITEMS.
   51. METHOD swap() vymiena obsah dvoch instancii DEQUEUE vymenou ich vnutornych FIELDS.
   52. FUNCTION swap() vymiena obsah dvoch instancii DEQUEUE vymenou ich vnutornych FIELDS.
29. CLASS [list<TType,TAllocator>] reprezentuje DOUBLY LINKED LIST. Pre CLASS [list<TType,TAllocator>] platia nasledujuce fakty.
   A. LIST je definovany v LIBRARY <list>.
   !!! B. LIST je implementovany ako DOUBLY LINKED LIST.
   C. LIST umoznuje v TEMPLATE PARAMETER 'TAllocator' definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii LIST.
   D. LIST ma FORWARD a BACKWARD ITERATORS. Nema vsak RANDOM ACCESS ITERATORS.
   E. LIST umoznuje RYCHLE pridavanie a odstranovanie ITEMS ak na ne je k dispozicii ITERATOR. Zlozitost takejto operacie je O(1). Pridavanie a odstranovanie ITEMS nesposobuje neplatnost ITERATORS.
   F. LIST ma POMALE vyhladavanie ITEMS so zlozitostou O(N).
   !!!!! G. Velkou VYHODOU LISTS je, ze VSETKY OPERATIONS okrem ASSIGNMENTS a METHOD list<TType,TAllocator>.sort() su ATOMICKE. To znaci, ze bud sa cela OPERATION kompletne vykona, alebo pri vzniku EXCEPTION ostane LIST NEMODIFIKOVANY.
30. CLASS [list<TType,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu LIST.
   2. DESTRUCTOR uvolnuje instanciu LIST ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [value_type] urcuje VALUE TYPE ITEMS ulozenych vo LIST.
   4. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   5. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   7. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v LIST.
   8. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v LIST.
   9. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v LIST.
   10. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v LIST.
   11. TYPE [iterator] urcuje TYPE pre ITERATOR daneho LIST.
   12. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR daneho LIST.
   13. TYPE [reverser_iterator] urcuje TYPE pre REVERSE ITERATOR daneho LIST.
   14. TYPE [const_reverser_iterator] urcuje TYPE pre CONST REVERSE ITERATOR daneho LIST.
   15. OPERATOR= priradzuje do LIST ITEMS ineho LIST. LIST obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   16. OPERATOR== zistuje ci dve instancie LIST su lexikograficky rovne.
   17. OPERATOR!= zistuje ci dve instancie LIST su lexikograficky rozne.
   18. OPERATOR< zistuje ci 1. LIST je lexikograficky mensi ako 2. LIST.
   19. OPERATOR<= zistuje ci 1. LIST je lexikograficky mensi, alebo rovna ako 2. LIST.
   20. OPERATOR> zistuje ci 1. LIST je lexikograficky vacsi ako 2. LIST.
   21. OPERATOR>= zistuje ci 1. LIST je lexikograficky vacsi, alebo rovna ako 2. LIST.
   22. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS daneho LIST.
   23. METHOD assign() priradzuje do LIST ITEMS ineho CONTAINER, ktory je definovany pomocou paru ITERATORS. OVERLOADED VERSION umoznuje priradzovat do LIST 'N' instancii CONST VALUE ako aj instanciu INITIALIZER LIST.
   24. METHOD front() vracia REFERENCE na PRVY ITEM v LIST.
   25. METHOD back() vracia REFERENCE na POSLEDNY ITEM v LIST.
   26. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM LIST.
   27. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM LIST.
   28. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM LIST.
   29. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM LIST.
   30. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM LIST.
   31. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM LIST.
   32. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM LIST.
   33. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM LIST.
   34. METHOD empty() vracia informaciu ci LIST je prazdny.
   35. METHOD size() vracia pocet ITEMS v LIST.
   36. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do LIST mozne ulozit.
   37. METHOD clear() odstranuje vsetky ITEMS z LIST.
   38. METHOD insert() pridava 1 az 'N' ITEMS do LIST PRED poziciu urcenu ITERATOR. OVERLOADED VERSION METHOD pridavajuca 1 ITEM vracia ITERATOR na pridany ITEM. OVERLOADED VERSION METHOD pridavajuca 'N' ITEMS vracia ITERATOR na prvy vlozeny ITEM.
   39. METHOD emplace() pridava ITEM do LIST za poziciu urcenu ITERATOR pomocou PLACEMENT NEW. PARAMETERS METHOD list<TType,TAllocator>.emplace() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do LIST. METHOD vracia ITERATOR na pridany ITEM.
   40. METHOD erase() odstranuje 1 az 'N' ITEMS do LIST. OVERLOADED VERSION METHOD odstranujuca 1 ITEM odstranuje ITEM ZA ITEM na ktory ITERATOR odkazuje a vracia ITERATOR na ITEM, ktory nasleduje za odstranenym ITEM. OVERLOADED VERSION METHOD odstranujuca 'N' ITEMS vracia ITERATOR odkazujuci na ITEM za poslednym odstranenym ITEM.
   41. METHOD push_front() pridava ITEM na zaciatok LIST.
   42. METHOD emplace_front() pridava ITEM na zaciatok LIST pomocou PLACEMENT NEW. PARAMETERS METHOD list<TType,TAllocator>.emplace_front() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do LIST.
   43. METHOD pop_front() odstranuje ITEM zo zaciatku LIST.
   44. METHOD push_back() pridava ITEM na koniec LIST.
   45. METHOD emplace_back() pridava ITEM na koniec LIST pomocou PLACEMENT NEW. PARAMETERS METHOD list<TType,TAllocator>.emplace_back() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do LIST.
   46. METHOD pop_back() odstranuje ITEM z konca LIST.
   47. METHOD resize() meni pocet ITEMS v LIST na pocet stanoveny PARAMETER METHOD list<TType,TAllocator>.resize(). V pripade, ze stanoveny pocet je MENSI ako pocet ITEMS v LIST, dochadza k ostraneniu ITEMS z LIST. Ak je stanoveny pocet VACSI ako pocet ITEMS v LIST, dochadza k pridavaniu novych ITEMS do LIST, pricom OVERLOADED verzia METHOD list<TType,TAllocator>.resize() umoznuje definovat ITEM, ktoreho kopia za priradi za nove ITEMS.
   48. METHOD swap() vymiena obsah dvoch instancii LIST vymenou ich vnutornych FIELDS.
   !!! 49. METHOD merge() vybera ITEMS z LIST definovaneho ako PARAMETER a uklada ich do LIST pre ktory bola METHOD volana. Obe LISTS MUSIA byt SORTED. OVERLOADED VERSION METHOD umoznuje definovat CUSTOM SORTING CRITERIA. Ak sa nezadaju BY-DEFAULT sa pouziva OPERATOR<. ITEMS su prenasane pomocou MOVE OPERATION, takze LIST definovany ako PARAMETER je po skonceni volania METHOD PRAZDNY. ITEMS, ktore maju rovnaku hodnotu v SOURCE a DESTINATION LIST su prenesene do DESTINATION LIST pricom su umiestnene az za ITEMS s rovnakou hodnotou, ktore v DESTINATION LIST sa uz nachadzali.
   !!! 50. METHOD splice() vybera ITEMS z LIST definovaneho ako PARAMETER a uklada ich do LIST pre ktory bola METHOD volana PRED poziciu zadanu ITERATOR. LISTS NA ROZDIEL od METHOD list<TType,TAllocator>.merge() NEMUSIA byt SORTED. OVERLOADED VERSION umoznuje definovat ITERATOR PAIR, ktory sa urcuje, ktore ITEMS sa zo SOURCE LIST prenesu. ITEMS su prenasane pomocou MOVE OPERATION.
   51. METHOD remove() odstranuje VSETKY ITEMS, ktore maju rovnaku hodnotu ako hodnota zadana v PARAMETER METHOD. Na porovnanie ITEMS sa pouziva OPERATOR==.
   52. METHOD remove_if() odstranuje VSETKY ITEMS, ktore splnaju PREDICATE zadany ako PARAMETER METHOD.
   53. METHOD reverse() obracia poradie ITEMS v LIST.
   54. METHOD unique() odstranuje za sebou nasledujuce ITEMS, ktore maju ROVNAKU VALUE. Na porovnanie ITEMS sa pouziva OPERATOR==, pricom OVERLOADED VERSION umoznuje preniest CUSTOM PREDICATE, ktory sa na porovnanie pouzije.
   55. METHOD sort() vykonava triedenie ITEMS. Na triedenie ITEMS sa pouziva OPERATOR<, pricom OVERLOADED VERSION umoznuje preniest CUSTOM PREDICATE, ktory sa na triedenie pouzije. Poradie ITEMS s rovnakou hodnotou je zachovane.
   56. FUNCTION swap() vymiena obsah dvoch instancii LIST vymenou ich vnutornych FIELDS.
31. CLASS [forward_list<TType,TAllocator>] reprezentuje SINGLY LINKED LIST. Pre CLASS [forward_list<TType,TAllocator>] platia nasledujuce fakty.
   A. FORWARD LIST je definovany v LIBRARY <forward_list>.
   !!! B. FORWARD LIST je implementovany ako SINGLY LINKED LIST.
   C. FORWARD LIST umoznuje v TEMPLATE PARAMETER 'TAllocator' definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii FORWARD LIST.
   D. FORWARD LIST je zjednodusenou veziou LIST. Nema ziadnu dodatocnu funkcionalitu oproti LISTS.
   E. FORWARD LIST ma iba FORWARD ITERATORS. Ine typy ITERATORS FORWARD LIST nepodporuje.
   F. FORWARD LIST ma minimum funkcionality, pretoze je silne orientovana na vysoku PEFORMANCE a nizke pamatove naroky.
   G. FORWARD LIST NEMA RANDOM ACCESS k ITEMS a jedina moznost pristupit k lubovolnemu ITEM je iterovat celym FORWARD LIST.
   H. FORWARD LIST umoznuje RYCHLE pridavanie a odstranovanie ITEMS ak na ne je k dispozicii ITERATOR. Zlozitost takejto operacie je O(1). Pridavanie a odstranovanie ITEMS nesposobuje neplatnost ITERATORS.
   I. FORWARD LIST ma POMALE vyhladavanie ITEMS so zlozitostou O(N).
32. CLASS [forward_list<TType,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu FORWARD LIST.
   2. DESTRUCTOR uvolnuje instanciu FORWARD LIST ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [value_type] urcuje VALUE TYPE ITEMS ulozenych vo FORWARD LIST.
   4. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   5. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   7. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene vo FORWARD LIST.
   8. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene vo FORWARD LIST.
   9. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene vo FORWARD LIST.
   10. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene vo FORWARD LIST.
   11. TYPE [iterator] urcuje TYPE pre ITERATOR daneho FORWARD LIST.
   12. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR daneho FORWARD LIST.
   13. OPERATOR= priradzuje do FORWARD LIST ITEMS ineho FORWARD LIST. FORWARD LIST obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   14. OPERATOR== zistuje ci dve instancie FORWARD LIST su lexikograficky rovne.
   15. OPERATOR!= zistuje ci dve instancie FORWARD LIST su lexikograficky rozne.
   16. OPERATOR< zistuje ci 1. FORWARD LIST je lexikograficky mensi ako 2. FORWARD LIST.
   17. OPERATOR<= zistuje ci 1. FORWARD LIST je lexikograficky mensi, alebo rovna ako 2. FORWARD LIST.
   18. OPERATOR> zistuje ci 1. FORWARD LIST je lexikograficky vacsi ako 2. FORWARD LIST.
   19. OPERATOR>= zistuje ci 1. FORWARD LIST je lexikograficky vacsi, alebo rovna ako 2. FORWARD LIST.
   20. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS daneho FORWARD LIST.
   21. METHOD assign() priradzuje do FORWARD LIST ITEMS ineho CONTAINER, ktory je definovany pomocou paru ITERATORS. OVERLOADED VERSION umoznuje priradzovat do FORWARD LIST 'N' instancii CONST VALUE ako aj instanciu INITIALIZER LIST.
   22. METHOD front() vracia REFERENCE na PRVY ITEM vo FORWARD LIST.
   23. METHOD before_begin() vracia ITERATOR ukazujuci PRED PRVY ITEM FORWARD LIST. METHOD sa pouziva pri vkladani ITEMS na zaciatok FORWARD LIST. Vratene ITERATORS NESMU BYT DEREFERENCED pretoze NEUKAZUJU na ITEM a ich DEREFERENCING by sposobil RUNTIME ERROR.
   24. METHOD cbefore_begin() vracia CONST ITERATOR ukazujuci PRED PRVY ITEM FORWARD LIST. METHOD sa pouziva pri vkladani ITEMS na zaciatok FORWARD LIST. Vratene ITERATORS NESMU BYT DEREFERENCED pretoze NEUKAZUJU na ITEM a ich DEREFERENCING by sposobil RUNTIME ERROR.
   25. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM FORWARD LIST.
   26. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM FORWARD LIST.
   27. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM FORWARD LIST.
   28. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM FORWARD LIST.
   29. METHOD empty() vracia informaciu ci FORWARD LIST je prazdny.
   30. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do FORWARD LIST mozne ulozit.
   31. METHOD clear() odstranuje vsetky ITEMS z FORWARD LIST.
   32. METHOD insert_after() pridava 1 az 'N' ITEMS do FORWARD LIST za poziciu urcenu ITERATOR. OVERLOADED VERSION METHOD pridavajuca 1 ITEM vracia ITERATOR na pridany ITEM. OVERLOADED VERSION METHOD pridavajuca 'N' ITEMS vracia ITERATOR na posledny vlozeny ITEM.
   33. METHOD emplace_after() pridava ITEM do FORWARD LIST za poziciu urcenu ITERATOR pomocou PLACEMENT NEW. PARAMETERS METHOD forward_list<TType,TAllocator>.emplace_after() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do FORWARD LIST. METHOD vracia ITERATOR na pridany ITEM.
   34. METHOD erase_after() odstranuje 1 az 'N' ITEMS z FORWARD LIST. OVERLOADED VERSION METHOD odstranujuca 1 ITEM odstranuje ITEM ZA ITEM na ktory ITERATOR odkazuje a vracia ITERATOR na ITEM, ktory nasleduje za odstranenym ITEM. OVERLOADED VERSION METHOD odstranujuca 'N' ITEMS vracia ITERATOR zadany ako 2. PARAMETER tejto METHOD.
   35. METHOD push_front() pridava ITEM na zaciatok FORWARD LIST.
   36. METHOD emplace_front() pridava ITEM na zaciatok FORWARD LIST pomocou PLACEMENT NEW. PARAMETERS METHOD forward_list<TType,TAllocator>.emplace_front() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do FORWARD LIST.
   37. METHOD pop_front() odstranuje ITEM zo zaciatku FORWARD LIST.
   38. METHOD resize() meni pocet ITEMS vo FORWARD LIST na pocet stanoveny PARAMETER METHOD forward_list<TType,TAllocator>.resize(). V pripade, ze stanoveny pocet je MENSI ako pocet ITEMS vo FORWARD LIST, dochadza k ostraneniu ITEMS z FORWARD LIST. Ak je stanoveny pocet VACSI ako pocet ITEMS vo FORWARD LIST, dochadza k pridavaniu novych ITEMS do FORWARD LIST, pricom OVERLOADED verzia METHOD forward_list<TType,TAllocator>.resize() umoznuje definovat ITEM, ktoreho kopia za priradi za nove ITEMS.
   39. METHOD swap() vymiena obsah dvoch instancii FORWARD LIST vymenou ich vnutornych FIELDS.
   !!! 40. METHOD merge() vybera ITEMS z FORWARD LIST definovaneho ako PARAMETER a uklada ich do FORWARD LIST pre ktory bola METHOD volana. Obe FORWARD LISTS MUSIA byt SORTED. OVERLOADED VERSION METHOD umoznuje definovat CUSTOM SORTING CRITERIA. Ak sa nezadaju BY-DEFAULT sa pouziva OPERATOR<. ITEMS su prenasane pomocou MOVE OPERATION, takze FORWARD LIST definovany ako PARAMETER je po skonceni volania METHOD PRAZDNY. ITEMS, ktore maju rovnaku hodnotu v SOURCE a DESTINATION FORWARD LIST su prenesene do DESTINATION FORWARD LIST pricom su umiestnene az za ITEMS s rovnakou hodnotou, ktore v DESTINATION FORWARD LIST sa uz nachadzali.
   !!! 41. METHOD splice_after() vybera ITEMS z FORWARD LIST definovaneho ako PARAMETER a uklada ich do FORWARD LIST pre ktory bola METHOD volana ZA poziciu zadanu ITERATOR. FORWARD LISTS NA ROZDIEL od METHOD forward_list<TType,TAllocator>.merge() NEMUSIA byt SORTED. OVERLOADED VERSION umoznuje definovat ITERATOR PAIR, ktory sa urcuje, ktore ITEMS sa zo SOURCE FORWARD LIST prenesu. ITEMS su prenasane pomocou MOVE OPERATION.
   42. METHOD remove() odstranuje VSETKY ITEMS, ktore maju rovnaku hodnotu ako hodnota zadana v PARAMETER METHOD. Na porovnanie ITEMS sa pouziva OPERATOR==.
   43. METHOD remove_if() odstranuje VSETKY ITEMS, ktore splnaju PREDICATE zadany ako PARAMETER METHOD.
   44. METHOD reverse() obracia poradie ITEMS vo FORWARD LIST.
   45. METHOD unique() odstranuje za sebou nasledujuce ITEMS, ktore maju ROVNAKU VALUE. Na porovnanie ITEMS sa pouziva OPERATOR==, pricom OVERLOADED VERSION umoznuje preniest CUSTOM PREDICATE, ktory sa na porovnanie pouzije.
   46. METHOD sort() vykonava triedenie ITEMS. Na triedenie ITEMS sa pouziva OPERATOR<, pricom OVERLOADED VERSION umoznuje preniest CUSTOM PREDICATE, ktory sa na triedenie pouzije. Poradie ITEMS s rovnakou hodnotou je zachovane.
   47. FUNCTION swap() vymiena obsah dvoch instancii FORWARD LIST vymenou ich vnutornych FIELDS.
33. CLASS [set<TKey,TCompare,TAllocator>] reprezentuje BALANCED BINARY TREE BEZ moznosti OPAKOVANIA ITEMS s rovnakou hodnotou VALUES. Pre CLASS [set<TKey,TCompare,TAllocator>] platia nasledujuce fakty.
   A. SET je definovana v LIBRARY <set>.
   !!! B. SET je implementovana ako BALANCED BINARY TREE.
   C. SETS NEMOZU obsahovat VIACERO ITEMS s TOU ISTOU VALUE.
   D. ITEMS v SETS su SORTED. Poradie ITEMS je definovane pomocou TEMPLATE PARAMETER 'TCompare'.
   E. ITEMS MUSIA byt COPYABLE, MOVABLE, EQUATABLE pomocou TEMPLATE PARAMETER 'TCompare'.
   F. EQUIVALENCE 2 ITEMS 'X' a 'Y' nastava vtedy ak [TCompare(X,Y)==FALSE && TCompare(Y,X)==FALSE]. V takomto pripade je ITEM pri pridavani do SET nepridany, pretoze ho SET uz obsahuje.
   G. SET umoznuje v TEMPLATE PARAMETER 'TAllocator' definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii SET.
   !!!!! H. SET ma vysoku PERFORMANCE pri pristupe k ITEMS. Zlozitost pri pristupe k ITEMS je O(LOG(N)).
   I. SET ma vysoku PERFORMANCE pri pridavani ITEMS.
   J. SET ma vysoku PERFORMANCE pri odstranovani ITEMS.
   !!! K. Hodnota ITEM je CONSTANT a NESMIE sa MENIT. Ak je potrebne hodnotu ITEM zmenit, je nutne ITEM odstranit zo SET a ITEM s novou hodnotou znova do SET vlozit.
34. ITEMS v SET a MULTISET MUSIA byt SORTED pricom SORTING CRITERIA musi splnit nasledujuce podmienky.
   A. SORTING CRITERIA MUSI byt ANTISYMETRIC. SORTING CRITERIA je ANTISYMETRIC ak plati, ze ak [SORT(X,Y)==TRUE], potom [SORT(Y,X)==FALSE].
   B. SORTING CRITERIA MUSI byt TRANSITIVE. SORTING CRITERIA je TRANSITIVE ak plati, ze ak [SORT(X,Y)==TRUE && SORT(Y,Z)==TRUE], potom [SORT(X,Z)==TRUE].
   C. SORTING CRITERIA MUSI byt IRREFLEXIVE. SORTING CRITERIA je IRREFLEXIVE ak plati, ze [SORT(X,X)==FALSE].
   D. SORTING CRITERIA MUSI splnat TRANSITIVITY OF EQUIVALENCE. SORTING CRITERIA splna TRANSITIVITY OF EQUIVALENCE ak plati, ze ak [SORT(X,Y)==FALSE && SORT(Y,X)==FALSE && SORT(Y,Z)==FALSE && SORT(Z,Y)==FALSE], potom [SORT(X,Z)==FALSE && SORT(Z,X)==FALSE].
35. CLASS [set<TKey,TCompare,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu SET.
   2. DESTRUCTOR uvolnuje instanciu SET ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [key_type] urcuje KEY TYPE ITEMS ulozenych v SET. KEY TYPE je identicky s VALUE TYPE.
   4. TYPE [value_type] urcuje VALUE TYPE ITEMS ulozenych v SET. VALUE TYPE je IDENTICKY s KEY TYPE.
   5. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   7. TYPE [key_compare] obsahuje TYPE pouzivany na porovnanie hodnot KEYS. KEYS a VALUES su reprezentovane tym istym TYPE.
   8. TYPE [value_compare] obsahuje TYPE pouzivany na porovnanie hodnot VALUES. KEYS a VALUES su reprezentovane tym istym TYPE.
   9. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   10. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v SET.
   11. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v SET.
   12. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v SET.
   13. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v SET.
   14. TYPE [iterator] urcuje TYPE pre ITERATOR daneho SET.
   15. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej SET.
   16. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR danej SET.
   17. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR danej SET.
   18. TYPE [node_type] urcuje TYPE pre SET NODE reprezentujuci NODES ulozene v SET.
   19. TYPE [insert_return_type] urcuje TYPE pouzivany na reprezentaciu vysledku vkladania ITEM do SET. Obsahuje informaciu ci ITEM bol do SET vlozeny a ITERATOR na poziciu na ktoru bol vlozeny.
   20. OPERATOR= priradzuje do SET ITEMS inej SET. SET obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   21. OPERATOR== zistuje ci dve instancie SET su lexikograficky rovne.
   22. OPERATOR!= zistuje ci dve instancie SET su lexikograficky rozne.
   23. OPERATOR< zistuje ci 1. SET je lexikograficky mensia ako 2. SET.
   24. OPERATOR<= zistuje ci 1. SET je lexikograficky mensia, alebo rovna ako 2. SET.
   25. OPERATOR> zistuje ci 1. SET je lexikograficky vacsia ako 2. SET.
   26. OPERATOR>= zistuje ci 1. SET je lexikograficky vacsia, alebo rovna ako 2. SET.
   27. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej SET.
   28. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM SET.
   29. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM SET.
   30. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM SET.
   31. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM SET.
   32. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM SET.
   33. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM SET.
   34. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM SET.
   35. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM SET.
   36. METHOD empty() vracia informaciu ci SET je prazdna.
   37. METHOD size() vracia pocet ITEMS v SET.
   38. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do SET mozne ulozit.
   39. METHOD clear() odstranuje vsetky ITEMS z SET.
   40. METHOD insert() pridava ITEM, alebo NODE do SET. METHOD vracia informaciu o tom ci ITEM bol pridany do SET a poziciu na ktoru bol ITEM vlozeny.
   41. METHOD emplace() pridava ITEM do SET pomocou PLACEMENT NEW. PARAMETERS METHOD set<TKey,TCompare,TAllocator>.emplace() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do SET. METHOD vracia informaciu ci bol ITEM vlozeny ako aj ITERATOR na poziciu do ktorej bol ITEM vlozeny.
   42. METHOD emplace_hint() pridava ITEM do SET pomocou PLACEMENT NEW, pricom 1. PARAMETER reprezenuje ITERATOR sluziaci ako HINT. HINT urcuje poziciu PRED ktorou sa v co najmensej vzdialenosti ma SET pokusit ITEM ulozit. PARAMETERS METHOD set<TKey,TCompare,TAllocator>.emplace_hint() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do SET. METHOD vracia ITERATOR na poziciu do ktorej bol ITEM vlozeny.
   43. METHOD erase() odstranuje 1-N ITEMS z SET. Pri odstranovani 1 ITEM SET definuje OVERLOADED verziu, kde sa zadava hodnota ITEM. Ostatne OVERLOADED verzie vyzaduju zadanie 1, alebo 2 ITERATORS. Verzia s 2 ITERATORS umoznuju odstranenie viacerych ITEMS.
   44. METHOD swap() vymiena obsah dvoch instancii SET vymenou ich vnutornych FIELDS.
   !!! 45. METHOD extract() odstranuje NODE z SET. NODE je urceny pomocou ITERATOR, alebo VALUE daneho ITEM.
   !!! 46. METHOD merge() vybera NODES z SET, alebo MULTISET definovanej ako PARAMETER a uklada ich do SET pre ktoru bola METHOD volana. ITEMS, ktore maju rovnaku hodnotu ITEM v SOURCE a DESTINATION SET nie su presunute do DESTINATION SET. METHOD umoznuje efektivne kopirovanie NODES medzi dvoma instanciami SET bez nutnosti vykonat kopiu ITEMS. OVERLOADED verzia umoznuje prenasat NODES z MULTISET.
   47. METHOD count() vracia pocet ITEMS s danou hodnotou SET.
   48. METHOD find() vracia ITERATOR na ITEM s danou hodnotou SET.
   49. METHOD equal_range() vracia ITERATOR PAIR, kde 1. ITERATOR odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU ITEM ako zadana hodnota ITEM a DRUHY ITERATOR odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU ITEM ako zadana hodnota ITEM. Ak SET NEMA ITEM, ktory ma MENSIU HODNOTU ITEM ako zadana hodnota ITEM, 1. ITERATOR odkazuje na END ITERATOR. Ak ITEM NEMA ITEM, ktory ma VACSIU HODNOTU ITEM ako zadana hodnota ITEM, 2. ITERATOR odkazuje na END ITERATOR.
   50. METHOD lower_bound() vracia ITERATOR, ktory odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU ITEM ako zadana hodnota ITEM. Ak SET NEMA ITEM, ktory ma MENSIU HODNOTU ITEM ako zadana hodnota ITEM, RETURN VALUE ITERATOR odkazuje na END ITERATOR.
   51. METHOD upper_bound() vracia ITERATOR, ktory odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU ITEM ako zadana hodnota ITEM. Ak SET NEMA ITEM, ktory ma VACSIU HODNOTU ITEM ako zadana hodnota ITEM, RETURN VALUE ITERATOR odkazuje na END ITERATOR.
   52. METHOD key_comp() vracia FUNCTION OBJECT pouzivany ako COMPARER hodnoty KEYS.
   53. METHOD value_comp() vracia FUNCTION OBJECT pouzivany ako COMPARER hodnoty VALUES. Je identicky s hodnotou, ktoru vracia METHOD set<TKey,TCompare,TAllocator>.key_comp().
   54. FUNCTION swap() vymiena obsah dvoch instancii SET vymenou ich vnutornych FIELDS.
36. CLASS [multiset<TKey,TCompare,TAllocator>] reprezentuje BALANCED BINARY TREE S moznostou OPAKOVANIA ITEMS s rovnakou hodnotou VALUES. Pre CLASS [multiset<TKey,TCompare,TAllocator>] platia nasledujuce fakty.
   A. MULTISET je definovana v LIBRARY <set>.
   !!! B. MULTISET je implementovana ako BALANCED BINARY TREE.
   C. MULTISETS MOZU obsahovat VIACERO ITEMS s TOU ISTOU VALUE.
   D. ITEMS v MULTISETS su SORTED. Poradie ITEMS je definovane pomocou TEMPLATE PARAMETER 'TCompare'.
   E. ITEMS MUSIA byt COPYABLE, MOVABLE, EQUATABLE pomocou TEMPLATE PARAMETER 'TCompare'.
   F. EQUIVALENCE 2 ITEMS 'X' a 'Y' nastava vtedy ak [TCompare(X,Y)==FALSE && TCompare(Y,X)==FALSE]. V takomto pripade je ITEM pri pridavani do MULTISET pridany opakovane.
   !!! G. Poradie ITEMS s rovnakou VALUE je UNDEFINED, ale STABLE. To znaci, ze ITEMS s rovnakou VALUE maju voci sebe NEMENNU POZICIU po pridani do MULTISET.
   H. MULTISET umoznuje v TEMPLATE PARAMETER 'TAllocator' definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii MULTISET.
   !!!!! I. MULTISET ma vysoku PERFORMANCE pri pristupe k ITEMS. Zlozitost pri pristupe k ITEMS je O(LOG(N)).
   J. MULTISET ma vysoku PERFORMANCE pri pridavani ITEMS.
   K. MULTISET ma vysoku PERFORMANCE pri odstranovani ITEMS.
   !!! L. Hodnota ITEM je CONSTANT a NESMIE sa MENIT. Ak je potrebne hodnotu ITEM zmenit, je nutne ITEM odstranit z MULTISET a ITEM s novou hodnotou znova do MULTISET vlozit.
37. CLASS [multiset<TKey,TCompare,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu MULTISET.
   2. DESTRUCTOR uvolnuje instanciu MULTISET ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [key_type] urcuje KEY TYPE ITEMS ulozenych v MULTISET. KEY TYPE je identicky s VALUE TYPE.
   4. TYPE [value_type] urcuje VALUE TYPE ITEMS ulozenych v MULTISET. VALUE TYPE je IDENTICKY s KEY TYPE.
   5. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   7. TYPE [key_compare] obsahuje TYPE pouzivany na porovnanie hodnot KEYS. KEYS a VALUES su reprezentovane tym istym TYPE.
   8. TYPE [value_compare] obsahuje TYPE pouzivany na porovnanie hodnot VALUES. KEYS a VALUES su reprezentovane tym istym TYPE.
   9. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   10. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v MULTISET.
   11. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v MULTISET.
   12. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v MULTISET.
   13. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v MULTISET.
   14. TYPE [iterator] urcuje TYPE pre ITERATOR daneho MULTISET.
   15. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej MULTISET.
   16. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR danej MULTISET.
   17. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR danej MULTISET.
   18. TYPE [node_type] urcuje TYPE pre MULTISET NODE reprezentujuci NODES ulozene v MULTISET.
   19. OPERATOR= priradzuje do MULTISET ITEMS inej MULTISET. MULTISET obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   20. OPERATOR== zistuje ci dve instancie MULTISET su lexikograficky rovne.
   21. OPERATOR!= zistuje ci dve instancie MULTISET su lexikograficky rozne.
   22. OPERATOR< zistuje ci 1. MULTISET je lexikograficky mensia ako 2. MULTISET.
   23. OPERATOR<= zistuje ci 1. MULTISET je lexikograficky mensia, alebo rovna ako 2. MULTISET.
   24. OPERATOR> zistuje ci 1. MULTISET je lexikograficky vacsia ako 2. MULTISET.
   25. OPERATOR>= zistuje ci 1. MULTISET je lexikograficky vacsia, alebo rovna ako 2. MULTISET.
   26. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej MULTISET.
   27. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM MULTISET.
   28. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM MULTISET.
   29. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM MULTISET.
   30. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM MULTISET.
   31. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM MULTISET.
   32. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM MULTISET.
   33. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM MULTISET.
   34. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM MULTISET.
   35. METHOD empty() vracia informaciu ci MULTISET je prazdna.
   36. METHOD size() vracia pocet ITEMS v MULTISET.
   37. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do MULTISET mozne ulozit.
   38. METHOD clear() odstranuje vsetky ITEMS z MULTISET.
   39. METHOD insert() pridava ITEM, alebo NODE do MULTISET. METHOD vracia poziciu na ktoru bol ITEM vlozeny.
   40. METHOD emplace() pridava ITEM do MULTISET pomocou PLACEMENT NEW. PARAMETERS METHOD multiset<TKey,TCompare,TAllocator>.emplace() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do MULTISET. METHOD vracia ITERATOR na poziciu do ktorej bol ITEM vlozeny.
   41. METHOD emplace_hint() pridava ITEM do MULTISET pomocou PLACEMENT NEW, pricom 1. PARAMETER reprezenuje ITERATOR sluziaci ako HINT. HINT urcuje poziciu PRED ktorou sa v co najmensej vzdialenosti ma MULTISET pokusit ITEM ulozit. PARAMETERS METHOD emplace_hint() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do MULTISET. METHOD vracia ITERATOR na poziciu do ktorej bol ITEM vlozeny.
   42. METHOD erase() odstranuje 1-N ITEMS z MULTISET. Pri odstranovani 1 ITEM MULTISET definuje OVERLOADED verziu, kde sa zadava hodnota ITEM. Ostatne OVERLOADED verzie vyzaduju zadanie 1, alebo 2 ITERATORS. Verzia s 2 ITERATORS umoznuju odstranenie viacerych ITEMS.
   43. METHOD swap() vymiena obsah dvoch instancii MULTISET vymenou ich vnutornych FIELDS.
   !!! 44. METHOD extract() odstranuje NODE z MULTISET. NODE je urceny pomocou ITERATOR, alebo VALUE daneho ITEM.
   !!! 45. METHOD merge() vybera NODES z MULTISET, alebo SET definovanej ako PARAMETER a uklada ich do MULTISET pre ktoru bola METHOD volana. ITEMS, ktore maju rovnaku hodnotu ITEM v SOURCE a DESTINATION MULTISET nie su presunute do DESTINATION MULTISET. METHOD umoznuje efektivne kopirovanie NODES medzi dvoma instanciami MULTISET bez nutnosti vykonat kopiu ITEMS. OVERLOADED verzia umoznuje prenasat NODES zo SET.
   46. METHOD count() vracia pocet ITEMS s danou hodnotou MULTISET.
   47. METHOD find() vracia ITERATOR na ITEM s danou hodnotou MULTISET.
   48. METHOD equal_range() vracia ITERATOR PAIR, kde 1. ITERATOR odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU ITEM ako zadana hodnota ITEM a DRUHY ITERATOR odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU ITEM ako zadana hodnota ITEM. Ak MULTISET NEMA ITEM, ktory ma MENSIU HODNOTU ITEM ako zadana hodnota ITEM, 1. ITERATOR odkazuje na END ITERATOR. Ak ITEM NEMA ITEM, ktory ma VACSIU HODNOTU ITEM ako zadana hodnota ITEM, 2. ITERATOR odkazuje na END ITERATOR.
   49. METHOD lower_bound() vracia ITERATOR, ktory odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU ITEM ako zadana hodnota ITEM. Ak MULTISET NEMA ITEM, ktory ma MENSIU HODNOTU ITEM ako zadana hodnota ITEM, RETURN VALUE ITERATOR odkazuje na END ITERATOR.
   50. METHOD upper_bound() vracia ITERATOR, ktory odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU ITEM ako zadana hodnota ITEM. Ak MULTISET NEMA ITEM, ktory ma VACSIU HODNOTU ITEM ako zadana hodnota ITEM, RETURN VALUE ITERATOR odkazuje na END ITERATOR.
   51. METHOD key_comp() vracia FUNCTION OBJECT pouzivany COMPARER ako hodnot KEYS.
   52. METHOD value_comp() vracia FUNCTION OBJECT pouzivany ako COMPARER hodnot VALUES. Je identicky s hodnotou, ktoru vracia METHOD multiset<TKey,TCompare,TAllocator>.key_comp().
   53. FUNCTION swap() vymiena obsah dvoch instancii MULTISET vymenou ich vnutornych FIELDS.
38. CLASS [map<TKey,TValue,TCompare,TAllocator>] reprezentuje BALANCED BINARY TREE BEZ moznosti OPAKOVANIA ITEMS s rovnakou hodnotou KEYS. Pre CLASS [map<TKey,TValue,TCompare,TAllocator>] platia nasledujuce fakty.
   A. MAP je definovana v LIBRARY <map>.
   B. MAP je spravidla implementovana ako BALANCED BINARY TREE. Aj ked to STANDARD vyslovene nedefinuje, vyplyva to z narokov na PERFORMANCE.
   C. MAP ma ako ITEMS instancie CLASS [pair<const TKey,TValue].
   D. MAP uklada ITEMS v SORTED poradi, ktore je definovane TEMPLATE PARAMETER 'TCompare'. Ak TEMPLATE PARAMETER 'TCompare' nie je definovany, ako DEFAULT sa pouziva STRUCTURE less<TKey>, ktora na porovnavanie pouziva OPERATOR<.
   E. KEYS pouzivane v MAPS MUSIA byt COPYABLE, MOVABLE a COMPARABLE pomocou TEMPLATE PARAMETER 'TCompare'.
   F. VALUES pouzivane v MAPS MUSIA byt COPYABLE a MOVABLE.
   !!! G. MAPS NEMOZU obsahovat VIACERO ITEMS s TYM ISTYM KEY.
   H. SORTING definovany pomocou TEMPLATE PARAMETER 'TCompare' MUSI implementovat STRICT WEAK ORDERING.
   I. TEMPLATE PARAMETER 'TCompare' sa okrem urcenia poradia ITEMS v MAP pouziva aj na urcenie ci su 2 ITEMS identicke. Tie su identicke vtedy ak plati, ze [(ITEM_1 COMPARE ITEM_2)==false && (ITEM_2 COMPARE ITEM_1)==false].
   J. MAP umoznuje v 4. TEMPLATE PARAMETER definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii MAP.
   !!!!! K. MAP ma vysoku PERFORMANCE pri pristupe k ITEMS pomocou ich KEYS. Priemerna zlozitost pri pristupe k ITEMS je O(LOG(N)). Najhorsia zlozitost (ak je BINARY TREE rozpadnuty a vytvara LIST) je O(N).
   L. MAP ma nizku PERFORMANCE pri pristupe k ITEMS pomocou ich VALUES.
   M. MAP ma vysoku PERFORMANCE pri pridavani ITEMS.
   N. MAP ma vysoku PERFORMANCE pri odstranovani ITEMS podla hodnoty ich KEYS.
   O. MAP ma nizku PERFORMANCE pri odstranovani ITEMS podla hodnoty ich VALUES.
   !!! P. Hodnoty KEYS su CONSTANT a NESMU sa MENIT. Ak je potrebne hodnotu KEY zmenit, je nutne ITEM odstranit z MAP a pridat ho znova s modifikovanou hodnotou KEY.
39. CLASS [map<TKey,TValue,TCompare,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu MAP.
   2. DESTRUCTOR uvolnuje instanciu MAP ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. INNER CLASS [value_compare] reprezentuje FUNCTION OBJECT s OPERATOR(), ktory sa pouziva na porovnavanie instancii TYPE [map::value_type]. FUNCTION OBJECT porovnava hodnoty KEYS dvojice MAP ITEMS.
   4. TYPE [key_type] urcuje KEY TYPE ITEMS ulozenych v MAP.
   5. TYPE [mapped_type] urcuje VALUE TYPE ITEMS ulozenych v MAP.
   6. TYPE [value_type] urcuje KEY-VALUE PAIR TYPE, ktory reprezentuje ITEMS ulozene v MAP. Ma hodnotu CLASS [pair<const TKey,TValue>].
   7. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   8. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   9. TYPE [key_compare] urcuje TYPE, ktory sa pouziva ako KEY COMPARER.
   10. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   11. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v MAP.
   12. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v MAP.
   13. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v MAP.
   14. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v MAP.
   15. TYPE [iterator] urcuje TYPE pre ITERATOR danej MAP.
   16. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej MAP.
   17. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR danej MAP.
   18. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR danej MAP.
   19. TYPE [node_type] urcuje TYPE pre MAP NODE reprezentujuci NODES ulozene v MAP.
   20. TYPE [insert_return_type] urcuje TYPE pouzivany na reprezentaciu vysledku vkladania ITEM do MAP. Obsahuje informaciu ci ITEM bol do MAP vlozeny, poziciu na ktoru bol vlozeny a instanciu CLASS [node_type] obsahuju NODE do ktoreho bol ITEM vlozeny.
   21. OPERATOR= priradzuje do MAP ITEMS inej MAP. MAP obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   22. OPERATOR== zistuje ci dve instancie MAP su lexikograficky rovne.
   23. OPERATOR!= zistuje ci dve instancie MAP su lexikograficky rozne.
   24. OPERATOR< zistuje ci 1. MAP je lexikograficky mensia ako 2. MAP.
   25. OPERATOR<= zistuje ci 1. MAP je lexikograficky mensia, alebo rovna ako 2. MAP.
   26. OPERATOR> zistuje ci 1. MAP je lexikograficky vacsia ako 2. MAP.
   27. OPERATOR>= zistuje ci 1. MAP je lexikograficky vacsia, alebo rovna ako 2. MAP.
   !!!!! 28. OPERATOR[] vracia REFERENCE na ITEM danej MAP podla hodnoty jeho KEY. V pripade, ze KEY s danou hodnotou sa v MAP NENACHADZA, ITEM sa do MAP ulozi.
   !!! 29. METHOD at() vracia REFERENCE na ITEM danej MAP podla hodnoty jeho KEY. Ak ITEM s danym KEY sa v MAP nenachadza, METHOD map<TKey,TValue,TCompare,TAllocator>.at() generuje EXCEPTION [out_of_range].
   30. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej MAP.
   31. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM MAP.
   32. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM MAP.
   33. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM MAP.
   34. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM MAP.
   35. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM MAP.
   36. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM MAP.
   37. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM MAP.
   38. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM MAP.
   39. METHOD empty() vracia informaciu ci MAP je prazdna.
   40. METHOD size() vracia pocet ITEMS v MAP.
   41. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do MAP mozne ulozit.
   42. METHOD clear() odstranuje vsetky ITEMS z MAP.
   43. METHOD insert() pridava ITEM, alebo NODE do MAP. METHOD vracia informaciu o tom ci ITEM bol pridany do MAP a poziciu na ktoru bol ITEM vlozeny.
   44. METHOD insert_or_assign() pridava ITEM, alebo NODE do MAP, ak KEY v MAP neexistuje. Ak KEY v MAP existuje, zmeni jeho VALUE.
   45. METHOD emplace() pridava ITEM do MAP pomocou PLACEMENT NEW. PARAMETERS METHOD map<TKey,TValue,TCompare,TAllocator>.emplace() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do MAP.
   46. METHOD emplace_hint() pridava ITEM do MAP pomocou PLACEMENT NEW, pricom 1. PARAMETER reprezenuje ITERATOR sluziaci ako HINT. HINT urcuje poziciu PRED ktorou sa v co najmensej vzdialenosti ma MAP pokusit ITEM ulozit. PARAMETERS METHOD map<TKey,TValue,TCompare,TAllocator>.emplace_hint() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do MAP.
   47. METHOD try_emplace() pridava ITEM do MAP pomocou PLACEMENT NEW ak ITEMS s danym KEY v MAP NEEXISTUJE. Ak EXISTUJE, METHOD NIC NEROBI. PARAMETERS METHOD map<TKey,TValue,TCompare,TAllocator>.try_emplace() od 2. PARAMETER (v OVERLOADED VERZIA s HINT od 3. PARAMETER) su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do MAP.
   48. METHOD erase() odstranuje 1-N ITEMS z MAP. Pri odstranovani 1 ITEM MAP definuje OVERLOADED verziu, kde sa zadava hodnota KEY. Ostatne OVERLOADED verzie vyzaduju zadanie 1, alebo 2 ITERATORS. Verzie s 2 ITERATORS umoznuju odstranenie viacerych ITEMS.
   49. METHOD swap() vymiena obsah dvoch instancii MAP vymenou ich vnutornych FIELDS.
   !!! 50. METHOD extract() odstranuje NODE z MAP. NODE je urceny pomocou ITERATOR, alebo KEY.
   !!! 51. METHOD merge() vybera NODES z MAP, alebo MULTIMAP definovanej ako PARAMETER a uklada ich do MAP pre ktoru bola METHOD volana. ITEMS, ktore maju rovnaku hodnotu KEY v SOURCE a DESTINATION MAP nie su presunute do DESTINATION MAP. METHOD umoznuje efektivne kopirovanie NODES medzi dvoma instanciami MAP bez nutnosti vykonat kopiu ITEMS. OVERLOADED verzia umoznuje prenasat NODES z MULTIMAPS.
   52. METHOD count() vracia pocet ITEMS s danou hodnotou KEY.
   53. METHOD find() vracia ITERATOR na ITEM s danou hodnotou KEY.
   54. METHOD equal_range() vracia ITERATOR PAIR, kde 1. ITERATOR odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU KEY ako zadana hodnota KEY a DRUHY ITERATOR odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY. Ak MAP NEMA ITEM, ktory ma MENSIU HODNOTU KEY ako zadana hodnota KEY, 1. ITERATOR odkazuje na END ITERATOR. Ak MAP NEMA ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY, 2. ITERATOR odkazuje na END ITERATOR.
   55. METHOD lower_bound() vracia ITERATOR, ktory odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU KEY ako zadana hodnota KEY. Ak MAP NEMA ITEM, ktory ma MENSIU HODNOTU KEY ako zadana hodnota KEY, RETURN VALUE ITERATOR odkazuje na END ITERATOR.
   56. METHOD upper_bound() vracia ITERATOR, ktory odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY. Ak MAP NEMA ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY, RETURN VALUE ITERATOR odkazuje na END ITERATOR.
   57. METHOD key_comp() vracia FUNCTION OBJECT pouzivany ako KEY COMPARER.
   58. METHOD value_comp() vracia FUNCTION OBJECT, ktory porovnava ITEMS danej MAP reprezentovane ako instancie CLASS [pair<const TKey,TValue>].
   59. FUNCTION swap() vymiena obsah dvoch instancii MAP vymenou ich vnutornych FIELDS.
40. CLASS [multimap<TKey,TValue,TCompare,TAllocator>] reprezentuje BALANCED BINARY TREE s moznostou OPAKOVANIA ITEMS s rovnakou hodnotou KEYS. Pre CLASS [multimap<TKey,TValue,TCompare,TAllocator>] platia nasledujuce fakty.
   A. MULTIMAP je definovana v LIBRARY <map>.
   B. MULTIMAP je spravidla implementovana ako BALANCED BINARY TREE. Aj ked to STANDARD vyslovene nedefinuje, vyplyva to z narokov na PERFORMANCE.
   C. MULTIMAP ma ako ITEMS instancie CLASS [pair<const TKey,TValue].
   D. MULTIMAP uklada ITEMS v SORTED poradi, ktore je definovane TEMPLATE PARAMETER 'TCompare'. Ak TEMPLATE PARAMETER 'TCompare' nie je definovany, ako DEFAULT sa pouziva STRUCTURE less<TKey>, ktora na porovnavanie pouziva OPERATOR<.
   E. KEYS pouzivane v MULTIMAPS MUSIA byt COPYABLE, MOVABLE a COMPARABLE pomocou TEMPLATE PARAMETER 'TCompare'.
   F. VALUES pouzivane v MULTIMAPS MUSIA byt COPYABLE a MOVABLE.
   !!! G. MULTIMAPS MOZU obsahovat VIACERO ITEMS s TYM ISTYM KEY.
   !!! H. MULTIMAPS ukladaju ITEMS s ROVNAKYM KEY v RANDOM, ale STABLE ORDER.
   I. SORTING definovany pomocou TEMPLATE PARAMETER 'TCompare' MUSI implementovat STRICT WEAK ORDERING.
   J. TEMPLATE PARAMETER 'TCompare' sa okrem urcenia poradia ITEMS v MULTIMAP pouziva aj na urcenie ci su 2 ITEMS identicke. Tie su identicke vtedy ak plati, ze [(ITEM_1 COMPARE ITEM_2)==false && (ITEM_2 COMPARE ITEM_1)==false].
   K. MULTIMAP umoznuje v 4. TEMPLATE PARAMETER definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii MULTIMAP.
   !!!!! L. MULTIMAP ma vysoku PERFORMANCE pri pristupe k ITEMS pomocou ich KEYS. Priemerna zlozitost pri pristupe k ITEMS je O(LOG(N)). Najhorsia zlozitost (ak je BINARY TREE rozpadnuty a vytvara LIST) je O(N).
   M. MULTIMAP ma nizku PERFORMANCE pri pristupe k ITEMS pomocou ich VALUES.
   N. MULTIMAP ma vysoku PERFORMANCE pri pridavani ITEMS.
   O. MULTIMAP ma vysoku PERFORMANCE pri odstranovani ITEMS podla hodnoty ich KEYS.
   P. MULTIMAP ma nizku PERFORMANCE pri odstranovani ITEMS podla hodnoty ich VALUES.
   !!! Q. Hodnoty KEYS su CONSTANT a NESMU sa MENIT. Ak je potrebne hodnotu KEY zmenit, je nutne ITEM odstranit z MULTIMAP a pridat ho znova s modifikovanou hodnotou KEY.
41. CLASS [multimap<TKey,TValue,TCompare,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu MULTIMAP.
   2. DESTRUCTOR uvolnuje instanciu MULTIMAP ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. INNER CLASS [value_compare] reprezentuje FUNCTION OBJECT s OPERATOR(), ktory sa pouziva na porovnavanie instancii TYPE [MULTIMAP::value_type]. FUNCTION OBJECT porovnava hodnoty KEYS dvojice MULTIMAP ITEMS.
   4. TYPE [key_type] urcuje KEY TYPE ITEMS ulozenych v MULTIMAP.
   5. TYPE [mapped_type] urcuje VALUE TYPE ITEMS ulozenych v MULTIMAP.
   6. TYPE [value_type] urcuje KEY-VALUE PAIR TYPE, ktory reprezentuje ITEMS ulozene v MULTIMAP. Ma hodnotu CLASS [pair<const TKey,TValue>].
   7. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   8. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   9. TYPE [key_compare] urcuje TYPE, ktory sa pouziva ako KEY COMPARER.
   10. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   11. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v MULTIMAP.
   12. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v MULTIMAP.
   13. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v MULTIMAP.
   14. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v MULTIMAP.
   15. TYPE [iterator] urcuje TYPE pre ITERATOR danej MULTIMAP.
   16. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej MULTIMAP.
   17. TYPE [reverse_iterator] urcuje TYPE pre REVERSE ITERATOR danej MULTIMAP.
   18. TYPE [const_reverse_iterator] urcuje TYPE pre CONST REVERSE ITERATOR danej MULTIMAP.
   19. TYPE [node_type] urcuje TYPE pre MULTIMAP NODE reprezentujuci NODES ulozene v MULTIMAP.
   20. OPERATOR= priradzuje do MULTIMAP ITEMS inej MULTIMAP. MULTIMAP obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   21. OPERATOR== zistuje ci dve instancie MULTIMAP su lexikograficky rovne.
   22. OPERATOR!= zistuje ci dve instancie MULTIMAP su lexikograficky rozne.
   23. OPERATOR< zistuje ci 1. MULTIMAP je lexikograficky mensia ako 2. MULTIMAP.
   24. OPERATOR<= zistuje ci 1. MULTIMAP je lexikograficky mensia, alebo rovna ako 2. MULTIMAP.
   25. OPERATOR> zistuje ci 1. MULTIMAP je lexikograficky vacsia ako 2. MULTIMAP.
   26. OPERATOR>= zistuje ci 1. MULTIMAP je lexikograficky vacsia, alebo rovna ako 2. MULTIMAP.
   27. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej MULTIMAP.
   28. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM MULTIMAP.
   29. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM MULTIMAP.
   30. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM MULTIMAP.
   31. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM MULTIMAP.
   32. METHOD rbegin() vracia REVERSE ITERATOR ukazujuci na POSLEDNY ITEM MULTIMAP.
   33. METHOD crbegin() vracia CONST REVERSE ITERATOR ukazujuci na POSLEDNY ITEM MULTIMAP.
   34. METHOD rend() vracia REVERSE ITERATOR ukazujuci hned pred PRVY ITEM MULTIMAP.
   35. METHOD crend() vracia CONST REVERSE ITERATOR ukazujuci hned pred PRVY ITEM MULTIMAP.
   36. METHOD empty() vracia informaciu ci MULTIMAP je prazdna.
   37. METHOD size() vracia pocet ITEMS v MULTIMAP.
   38. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do MULTIMAP mozne ulozit.
   39. METHOD clear() odstranuje vsetky ITEMS z MULTIMAP.
   40. METHOD insert() pridava ITEM, alebo NODE do MULTIMAP. METHOD vracia poziciu na ktoru bol ITEM vlozeny.
   41. METHOD emplace() pridava ITEM do MULTIMAP pomocou PLACEMENT NEW. PARAMETERS METHOD multimap<TKey,TValue,TCompare,TAllocator>.emplace() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do MULTIMAP.
   42. METHOD emplace_hint() pridava ITEM do MULTIMAP pomocou PLACEMENT NEW, pricom 1. PARAMETER reprezenuje ITERATOR sluziaci ako HINT. HINT urcuje poziciu PRED ktorou sa v co najmensej vzdialenosti ma MULTIMAP pokusit ITEM ulozit. PARAMETERS METHOD multimap<TKey,TValue,TCompare,TAllocator>.emplace_hint() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do MULTIMAP.
   43. METHOD erase() odstranuje 1-N ITEMS z MULTIMAP. Pri odstranovani 1 ITEM MULTIMAP definuje OVERLOADED verziu, kde sa zadava ITERATOR na ITEM, ktory ma byt odstraneny. OVERLOADED verzia s 2 ITERATORS odstranuje vsetky ITEMS medzi tymito ITERATORS. OVERLOADED VERZIA s KEY odstranuje VSETKY ITEMS, ktore maju hodnotu tohto KEY. Tato verzia vracia pocet ITEMS, ktore boli odstranene.
   44. METHOD swap() vymiena obsah dvoch instancii MULTIMAP vymenou ich vnutornych FIELDS.
   !!! 45. METHOD extract() odstranuje NODE z MULTIMAP. NODE je urceny pomocou ITERATOR, alebo KEY.
   !!! 46. METHOD merge() vybera NODES z MULTIMAP, alebo MAP definovanej ako PARAMETER a uklada ich do MULTIMAP pre ktoru bola METHOD volana. ITEMS, ktore maju rovnaku hodnotu KEY v SOURCE a DESTINATION MULTIMAP nie su presunute do DESTINATION MULTIMAP. METHOD umoznuje efektivne kopirovanie NODES medzi dvoma instanciami MULTIMAP bez nutnosti vykonat kopiu ITEMS. OVERLOADED verzia umoznuje prenasat NODES z MAPS.
   47. METHOD count() vracia pocet ITEMS s danou hodnotou KEY.
   48. METHOD find() vracia ITERATOR na ITEM s danou hodnotou KEY. Ak sa v MULTIMAP nachadza viacero ITEMS s tym istym KEY, METHOD moze vratit ITERATOR na LUBOVOLNY z nich.
   49. METHOD equal_range() vracia ITERATOR PAIR, kde 1. ITERATOR odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU KEY ako zadana hodnota KEY a DRUHY ITERATOR odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY. Ak MULTIMAP NEMA ITEM, ktory ma MENSIU HODNOTU KEY ako zadana hodnota KEY, 1. ITERATOR odkazuje na END ITERATOR. Ak MULTIMAP NEMA ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY, 2. ITERATOR odkazuje na END ITERATOR.
   50. METHOD lower_bound() vracia ITERATOR, ktory odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU KEY ako zadana hodnota KEY. Ak MULTIMAP NEMA ITEM, ktory ma MENSIU HODNOTU KEY ako zadana hodnota KEY, RETURN VALUE ITERATOR odkazuje na END ITERATOR.
   51. METHOD upper_bound() vracia ITERATOR, ktory odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY. Ak MULTIMAP NEMA ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY, RETURN VALUE ITERATOR odkazuje na END ITERATOR.
   52. METHOD key_comp() vracia FUNCTION OBJECT pouzivany ako KEY COMPARER.
   53. METHOD value_comp() vracia FUNCTION OBJECT, ktory porovnava ITEMS danej MULTIMAP reprezentovane ako instancie CLASS [pair<const TKey,TValue>].
   54. FUNCTION swap() vymiena obsah dvoch instancii MULTIMAP vymenou ich vnutornych FIELDS.
42. CLASS [unordered_set<TKey,THash,TKeyEqual,TAllocator>] reprezentuje HASH SET BEZ moznosti OPAKOVANIA ITEMS s rovnakou hodnotou KEYS. Pre CLASS [unordered_set<TKey,THash,TKeyEqual,TAllocator>] platia nasledujuce fakty.
   A. UNORDERED SET je definovana v LIBRARY <unordered_set>.
   !!! B. UNORDERED SET je implementovana ako HASH SET, ktora uklada ITEMS do BUCKETS. BUCKETS su implementovane ako JEDNOSMERNE, alebo OBOJSMERNE LISTS.
   C. UNORDERED SETS NEMOZU obsahovat VIACERO ITEMS s TYM ISTYM KEY.
   D. ITEMS v UNORDERED SETS NIE su SORTED. Su ulozene v nedefinovanom poradi co je rozdiel oproti SETS, kde su ITEMS SORTED.
   E. ITEMS MUSIA byt COPYABLE, MOVABLE, EQUATABLE pomocou TEMPLATE PARAMETER 'TKeyEqual' a HASHABLE pomocou TEMPLATE PARAMETER 'THash'.
   !!!!! F. ITEMS su ukladane do BUCKETS VYLUCNE podla HASH hodnoty ich VALUES. V pripade, ze pre 2 rozlicne ITEMS HASH FUNCTION vracia TEN ISTY HASH CODE, ITEMS su ukladane do LIST v TOM ISTOM BUCKET.
   G. TEMPLATE PARAMETER 'THash' reprezentuje HASH FUNCTION, ktora sa pouziva na vypocet HASH VALUES. DEFAULT VALUE je STRUCTURE [hash<TKey>].
   !!! H. TEMPLATE PARAMETER 'TKeyEqual' reprezentuje EQUATABLE FUNCTION, ktora sa pouziva na urcenie ci 2 KEYS su rovnake. Pouziva sa na vyhladanie ITEM v BUCKET. DEFAULT VALUE je STRUCTURE [equal_to<TKey].
   I. UNORDERED SET umoznuje v TEMPLATE PARAMETER 'TAllocator' definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii UNORDERED SET.
   !!!!! J. UNORDERED SET ma vysoku PERFORMANCE pri pristupe k ITEMS. Priemerna zlozitost pri pristupe k ITEMS je O(1). Najhorsia zlozitost (ak HASH TABLE pouziva nedokonalu HASH FUNCTION) je O(N).
   K. UNORDERED SET ma vysoku PERFORMANCE pri pridavani ITEMS.
   L. UNORDERED SET ma vysoku PERFORMANCE pri odstranovani ITEMS.
   !!! M. Hodnota ITEM je CONSTANT a NESMIE sa MENIT. Ak je potrebne hodnotu ITEM zmenit, je nutne ITEM odstranit z UNORDERED SET a pridat ho znova s modifikovanou hodnotou KEY.
   !!!!! N. Pri pridavani ITEMS do UNORDERED SET pomocou METHOD unordered_set<TKey,THash,TKeyEqual,TAllocator>.insert() moze dojst k prekroceniu hranice urcujucej maximalny pocet ITEMS v BUCKET, ktoru je mozne definovat programovo. Ak je tato hranica prekrocena, UNORDERED SET AUTOMATICKY vykona REHASHING. REHASHING je mozne vykonat aj explicitne volanim METHOD unordered_set<TKey,THash,TKeyEqual,TAllocator>.rehash(), alebo METHOD METHOD unordered_set<TKey,THash,TKeyEqual,TAllocator>.reserve(). Pri REHASING su vsetky ITERATOR INVALID.
   O. Pri odstranovani ITEMS z UNORDERED SET pomocou METHOD unordered_set<TKey,THash,TKeyEqual,TAllocator>.erase() NIKDY NEDOCHADZA k REHASING.
   !!!!! P. Pri vyhladavani ITEMS v UNORDERED SET sa NAJPRV pouzije HASH VALUE vypocitana podla TEMPLATE PARAMETER 'THash' na urcenie v ktorom BUCKET sa ITEM nachadza a NASLEDNE sa pomocou TEMPLATE PARAMETER 'TKeyEqual' v danom BUCKET najde hladany ITEM.
43. CLASS [unordered_set<TKey,THash,TKeyEqual,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu UNORDERED SET.
   2. DESTRUCTOR uvolnuje instanciu UNORDERED SET ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [key_type] urcuje KEY TYPE ITEMS ulozenych v UNORDERED SET.
   4. TYPE [value_type] urcuje VALUE TYPE ITEMS ulozenych v UNORDERED SET. VALUE TYPE je IDENTICKY s KEY TYPE.
   5. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   7. TYPE [hasher] obsahuje TYPE pouzivany na vypocet HASH FUNCTION daneho KEY.
   8. TYPE [key_equal] obsahuje TYPE pouzivany na porovnanie hodnot KEYS.
   9. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   10. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v UNORDERED SET.
   11. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v UNORDERED SET.
   12. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v UNORDERED SET.
   13. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v UNORDERED SET.
   14. TYPE [iterator] urcuje TYPE pre ITERATOR daneho UNORDERED SET.
   15. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej UNORDERED SET.
   16. TYPE [local_iterator] urcuje TYPE pre ITERATOR daneho UNORDERED SET pouzivany na prechod ITEMS v ramci jedneho BUCKET. ITERATOR NIE JE MOZNE pouzit na prechod medzi ITEMS v rozlicnych BUCKETS.
   17. TYPE [const_local_iterator] urcuje TYPE pre CONST ITERATOR danej UNORDERED SET pouzivany na prechod ITEMS v ramci jedneho BUCKET. ITERATOR NIE JE MOZNE pouzit na prechod medzi ITEMS v rozlicnych BUCKETS.
   18. TYPE [node_type] urcuje TYPE pre UNORDERED SET NODE reprezentujuci NODES ulozene v UNORDERED SET.
   19. TYPE [insert_return_type] urcuje TYPE pouzivany na reprezentaciu vysledku vkladania ITEM do UNORDERED SET. Obsahuje informaciu ci ITEM bol do UNORDERED SET vlozeny, poziciu na ktoru bol vlozeny a instanciu CLASS [node_type] obsahuju NODE do ktoreho bol ITEM vlozeny.
   20. OPERATOR= priradzuje do UNORDERED SET ITEMS inej UNORDERED SET. UNORDERED SET obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   21. OPERATOR== zistuje ci dve instancie UNORDERED SET su lexikograficky rovne.
   22. OPERATOR!= zistuje ci dve instancie UNORDERED SET su lexikograficky rozne.
   23. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej UNORDERED SET.
   24. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM UNORDERED SET. OVERLOADED verzia vracia ITERATOR na PRVY ITEM v danom BUCKET.
   25. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM UNORDERED SET. OVERLOADED verzia vracia ITERATOR na PRVY ITEM v danom BUCKET.
   26. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM UNORDERED SET. OVERLOADED verzia vracia ITERATOR na POSLEDNY ITEM v danom BUCKET.
   27. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM UNORDERED SET. OVERLOADED verzia vracia ITERATOR hned za POSLEDNY ITEM v danom BUCKET.
   28. METHOD empty() vracia informaciu ci UNORDERED SET je prazdna.
   29. METHOD size() vracia pocet ITEMS v UNORDERED SET.
   30. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do UNORDERED SET mozne ulozit.
   31. METHOD clear() odstranuje vsetky ITEMS z UNORDERED SET.
   32. METHOD insert() pridava ITEM, alebo NODE do UNORDERED SET. METHOD vracia informaciu o tom ci ITEM bol pridany do UNORDERED SET a poziciu na ktoru bol ITEM vlozeny.
   33. METHOD emplace() pridava ITEM do UNORDERED SET pomocou PLACEMENT NEW. PARAMETERS METHOD unordered_set<TKey,THash,TKeyEqual,TAllocator>.emplace() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED SET. METHOD vracia informaciu ci bol ITEM vlozeny ako aj ITERATOR na poziciu do ktorej bol ITEM vlozeny.
   34. METHOD emplace_hint() pridava ITEM do UNORDERED SET pomocou PLACEMENT NEW, pricom 1. PARAMETER reprezenuje ITERATOR sluziaci ako HINT. HINT urcuje poziciu PRED ktorou sa v co najmensej vzdialenosti ma UNORDERED SET pokusit ITEM ulozit. PARAMETERS METHOD unordered_set<TKey,THash,TKeyEqual,TAllocator>.emplace_hint() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED SET. METHOD vracia ITERATOR na poziciu do ktorej bol ITEM vlozeny.
   35. METHOD erase() odstranuje 1-N ITEMS z UNORDERED SET. Pri odstranovani 1 ITEM UNORDERED SET definuje OVERLOADED verziu, kde sa zadava hodnota KEY. Ostatne OVERLOADED verzie vyzaduju zadanie 1, alebo 2 ITERATORS. Verzia s 2 ITERATORS umoznuju odstranenie viacerych ITEMS.
   36. METHOD swap() vymiena obsah dvoch instancii UNORDERED SET vymenou ich vnutornych FIELDS.
   !!! 37. METHOD extract() odstranuje NODE z UNORDERED SET. NODE je urceny pomocou ITERATOR, alebo KEY.
   !!! 38. METHOD merge() vybera NODES z UNORDERED SET, alebo UNORDERED MULTISET definovanej ako PARAMETER a uklada ich do UNORDERED SET pre ktoru bola METHOD volana. ITEMS, ktore maju rovnaku hodnotu KEY v SOURCE a DESTINATION UNORDERED SET nie su presunute do DESTINATION UNORDERED SET. METHOD umoznuje efektivne kopirovanie NODES medzi dvoma instanciami UNORDERED SET bez nutnosti vykonat kopiu ITEMS. OVERLOADED verzia umoznuje prenasat NODES z UNORDERED MULTISET.
   39. METHOD count() vracia pocet ITEMS s danou hodnotou UNORDERED SET.
   40. METHOD find() vracia ITERATOR na ITEM s danou hodnotou UNORDERED SET.
   41. METHOD equal_range() vracia ITERATOR PAIR, kde 1. ITERATOR odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU KEY ako zadana hodnota KEY a DRUHY ITERATOR odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY. Ak UNORDERED SET NEMA ITEM, ktory ma MENSIU HODNOTU KEY ako zadana hodnota KEY, 1. ITERATOR odkazuje na END ITERATOR. Ak UNORDERED SET NEMA ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY, 2. ITERATOR odkazuje na END ITERATOR.
   42. METHOD bucket_count() vracia pocet BUCKETS v UNORDERED SET.
   43. METHOD max_bucket_count() vracia maximalny pocet BUCKETS, ktore moze UNORDERED SET obsahovat.
   44. METHOD bucket_size() vracia pocet ITEMS v danom BUCKET, ktory UNORDERED SET obsahuje.
   45. METHOD bucket() vracia INDEX na BUCKET v ktorom sa ITEM s danym KEY nachadza.
   46. METHOD load_factor() vracia priemerny pocet ITEMS v BUCKETS danej UNORDERED SET.
   47. METHOD max_load_factor() vracia MAXIMALNY pocet ITEMS, ktore mozu byt v BUCKET ulozene predtym ako dojde k REHASHING celej UNORDERED SET. OVERLOADED verzia METHOD max_load_factor() umoznuje nastavit MAXIMALNY pocet ITEMS, ktore mozu byt v BUCKET ulozene predtym ako dojde k REHASHING celej UNORDERED SET.
   48. METHOD rehash() vykona REHASH celej UNORDERED SET, tak aby ITEMS boli rozdelene do poctu BUCKETS, ktory definuje PARAMETER METHOD rehash().
   49. METHOD reserve() nastavi pocet BUCKETS na taku hodnotu aby kazdy BUCKET mohol obsahovat aspon pocet ITEMS zadanom v PARAMETERI METHOD reserve(). METHOD reserve() zaroven vykona REHASH celej UNORDERED SET.
   50. METHOD hash_function() vracia FUNCTION OBJECT pouzivany ako HASH FUNCTION na vypocet HASH CODE, ktory urcuje do ktoreho BUCKET bude ITEM ulozeny.
   51. METHOD key_eq() vracia FUNCTION OBJECT, ktory sa pouziva na porovnavanie rovnosti hodnot KEYS.
   52. FUNCTION swap() vymiena obsah dvoch instancii UNORDERED SET vymenou ich vnutornych FIELDS.
44. CLASS [unordered_multiset<TKey,THash,TKeyEqual,TAllocator>] reprezentuje HASH SET s moznostou OPAKOVANIA ITEMS s rovnakou hodnotou KEYS. Pre CLASS [unordered_multiset<TKey,THash,TKeyEqual,TAllocator>] platia nasledujuce fakty.
   A. UNORDERED MULTISET je definovana v LIBRARY <unordered_set>.
   !!! B. UNORDERED MULTISET je implementovana ako HASH SET, ktora uklada ITEMS do BUCKETS. BUCKETS su implementovane ako JEDNOSMERNE, alebo OBOJSMERNE LISTS.
   C. UNORDERED MULTISETS MOZU obsahovat VIACERO ITEMS s TYM ISTYM KEY.
   D. ITEMS v UNORDERED MULTISETS NIE su SORTED. Su ulozene v nedefinovanom poradi co je rozdiel oproti MULTISETS, kde su ITEMS SORTED.
   E. ITEMS MUSIA byt COPYABLE, MOVABLE, EQUATABLE pomocou TEMPLATE PARAMETER 'TKeyEqual' a HASHABLE pomocou TEMPLATE PARAMETER 'THash'.
   !!!!! F. ITEMS su ukladane do BUCKETS VYLUCNE podla HASH hodnoty ich KEYS. V pripade, ze pre 2 rozlicne ITEMS HASH FUNCTION vracia TEN ISTY HASH CODE, ITEMS su ukladane do LIST v TOM ISTOM BUCKET.
   G. TEMPLATE PARAMETER 'THash' reprezentuje HASH FUNCTION, ktora sa pouziva na vypocet HASH VALUES. DEFAULT VALUE je STRUCTURE [hash<TKey>].
   !!! H. TEMPLATE PARAMETER 'TKeyEqual' reprezentuje EQUATABLE FUNCTION, ktora sa pouziva na urcenie ci 2 KEYS su rovnake. Pouziva sa na vyhladanie ITEM v BUCKET. DEFAULT VALUE je STRUCTURE [equal_to<TKey].
   I. UNORDERED MULTISET umoznuje v TEMPLATE PARAMETER 'TAllocator' definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii UNORDERED MULTISET.
   !!!!! J. UNORDERED MULTISET ma vysoku PERFORMANCE pri pristupe k ITEMS. Priemerna zlozitost pri pristupe k ITEMS je O(1). Najhorsia zlozitost (ak HASH TABLE pouziva nedokonalu HASH FUNCTION) je O(N).
   K. UNORDERED MULTISET ma vysoku PERFORMANCE pri pridavani ITEMS.
   L. UNORDERED MULTISET ma vysoku PERFORMANCE pri odstranovani ITEMS.
   !!! M. Hodnota ITEM je CONSTANT a NESMIE sa MENIT. Ak je potrebne hodnotu ITEM zmenit, je nutne ITEM odstranit z UNORDERED MULTISET a pridat ho znova s modifikovanou hodnotou KEY.
   !!!!! N. Pri pridavani ITEMS do UNORDERED MULTISET pomocou METHOD unordered_multiset<TKey,THash,TKeyEqual,TAllocator>.insert() moze dojst k prekroceniu hranice urcujucej maximalny pocet ITEMS v BUCKET, ktoru je mozne definovat programovo. Ak je tato hranica prekrocena, UNORDERED MULTISET AUTOMATICKY vykona REHASHING. REHASHING je mozne vykonat aj explicitne volanim METHOD unordered_multiset<TKey,THash,TKeyEqual,TAllocator>.rehash(), alebo METHOD unordered_multiset<TKey,THash,TKeyEqual,TAllocator>.reserve(). Pri REHASING su vsetky ITERATOR INVALID.
   O. Pri odstranovani ITEMS z UNORDERED MULTISET pomocou METHOD unordered_multiset<TKey,THash,TKeyEqual,TAllocator>.erase() NIKDY NEDOCHADZA k REHASING.
   P. Ak UNORDERED MULTISET obsahuje viacero ITEMS s rovnakymi KEYS, pri iterovani ITEMS su tieto ITEMS ulozene za sebou pricom aj po REHASING ostava ich poradie zachovane.
   !!!!! Q. Pri vyhladavani ITEMS v UNORDERED MULTISET sa NAJPRV pouzije HASH VALUE vypocitana podla TEMPLATE PARAMETER 'THash' na urcenie v ktorom BUCKET sa ITEM nachadza a NASLEDNE sa pomocou TEMPLATE PARAMETER 'TKeyEqual' v danom BUCKET najde hladany ITEM.
45. CLASS [unordered_multiset<TKey,THash,TKeyEqual,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu UNORDERED MULTISET.
   2. DESTRUCTOR uvolnuje instanciu UNORDERED MULTISET ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [key_type] urcuje KEY TYPE ITEMS ulozenych v UNORDERED MULTISET.
   4. TYPE [value_type] urcuje VALUE TYPE ITEMS ulozenych v UNORDERED MULTISET. VALUE TYPE je IDENTICKY s KEY TYPE.
   5. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   6. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   7. TYPE [hasher] obsahuje TYPE pouzivany na vypocet HASH FUNCTION daneho KEY.
   8. TYPE [key_equal] obsahuje TYPE pouzivany na porovnanie hodnot KEYS.
   9. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   10. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v UNORDERED MULTISET.
   11. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v UNORDERED MULTISET.
   12. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v UNORDERED MULTISET.
   13. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v UNORDERED MULTISET.
   14. TYPE [iterator] urcuje TYPE pre ITERATOR daneho UNORDERED MULTISET.
   15. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej UNORDERED MULTISET.
   16. TYPE [local_iterator] urcuje TYPE pre ITERATOR daneho UNORDERED MULTISET pouzivany na prechod ITEMS v ramci jedneho BUCKET. ITERATOR NIE JE MOZNE pouzit na prechod medzi ITEMS v rozlicnych BUCKETS.
   17. TYPE [const_local_iterator] urcuje TYPE pre CONST ITERATOR danej UNORDERED MULTISET pouzivany na prechod ITEMS v ramci jedneho BUCKET. ITERATOR NIE JE MOZNE pouzit na prechod medzi ITEMS v rozlicnych BUCKETS.
   18. TYPE [node_type] urcuje TYPE pre UNORDERED MULTISET NODE reprezentujuci NODES ulozene v UNORDERED MULTISET.
   19. OPERATOR= priradzuje do UNORDERED MULTISET ITEMS inej UNORDERED MULTISET. UNORDERED MULTISET obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   20. OPERATOR== zistuje ci dve instancie UNORDERED MULTISET su lexikograficky rovne.
   21. OPERATOR!= zistuje ci dve instancie UNORDERED MULTISET su lexikograficky rozne.
   22. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej UNORDERED MULTISET.
   23. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM UNORDERED MULTISET. OVERLOADED verzia vracia ITERATOR na PRVY ITEM v danom BUCKET.
   24. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM UNORDERED MULTISET. OVERLOADED verzia vracia ITERATOR na PRVY ITEM v danom BUCKET.
   25. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM UNORDERED MULTISET. OVERLOADED verzia vracia ITERATOR na POSLEDNY ITEM v danom BUCKET.
   26. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM UNORDERED MULTISET. OVERLOADED verzia vracia ITERATOR hned za POSLEDNY ITEM v danom BUCKET.
   27. METHOD empty() vracia informaciu ci UNORDERED MULTISET je prazdna.
   28. METHOD size() vracia pocet ITEMS v UNORDERED MULTISET.
   29. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do UNORDERED MULTISET mozne ulozit.
   30. METHOD clear() odstranuje vsetky ITEMS z UNORDERED MULTISET.
   31. METHOD insert() pridava ITEM, alebo NODE do UNORDERED MULTISET. METHOD vracia ITERATOR na poziciu na ktoru bol ITEM vlozeny.
   32. METHOD emplace() pridava ITEM do UNORDERED MULTISET pomocou PLACEMENT NEW. PARAMETERS METHOD unordered_multiset<TKey,THash,TKeyEqual,TAllocator>.emplace() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED MULTISET. METHOD vracia ITERATOR na poziciu do ktorej bol ITEM vlozeny.
   33. METHOD emplace_hint() pridava ITEM do UNORDERED MULTISET pomocou PLACEMENT NEW, pricom 1. PARAMETER reprezenuje ITERATOR sluziaci ako HINT. HINT urcuje poziciu PRED ktorou sa v co najmensej vzdialenosti ma UNORDERED MULTISET pokusit ITEM ulozit. PARAMETERS METHOD unordered_multiset<TKey,THash,TKeyEqual,TAllocator>.emplace_hint() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED MULTISET. METHOD vracia ITERATOR na poziciu do ktorej bol ITEM vlozeny.
   34. METHOD erase() odstranuje 1-N ITEMS z UNORDERED MULTISET. Pri odstranovani 1 ITEM UNORDERED MULTISET definuje OVERLOADED verziu, kde sa zadava hodnota KEY. Ostatne OVERLOADED verzie vyzaduju zadanie 1, alebo 2 ITERATORS. Verzia s 2 ITERATORS umoznuju odstranenie viacerych ITEMS.
   35. METHOD swap() vymiena obsah dvoch instancii UNORDERED MULTISET vymenou ich vnutornych FIELDS.
   !!! 36. METHOD extract() odstranuje NODE z UNORDERED MULTISET. NODE je urceny pomocou ITERATOR, alebo KEY.
   !!! 37. METHOD merge() vybera NODES z UNORDERED MULTISET, alebo UNORDERED SET definovanej ako PARAMETER a uklada ich do UNORDERED MULTISET pre ktoru bola METHOD volana. ITEMS, ktore maju rovnaku hodnotu KEY v SOURCE a DESTINATION UNORDERED MULTISET nie su presunute do DESTINATION UNORDERED MULTISET. METHOD umoznuje efektivne kopirovanie NODES medzi dvoma instanciami UNORDERED MULTISET bez nutnosti vykonat kopiu ITEMS. OVERLOADED verzia umoznuje prenasat NODES z UNORDERED SET.
   38. METHOD count() vracia pocet ITEMS s danou hodnotou UNORDERED MULTISET.
   39. METHOD find() vracia ITERATOR na ITEM s danou hodnotou UNORDERED MULTISET.
   40. METHOD equal_range() vracia ITERATOR PAIR, kde 1. ITERATOR odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU KEY ako zadana hodnota KEY a DRUHY ITERATOR odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY. Ak UNORDERED MULTISET NEMA ITEM, ktory ma MENSIU HODNOTU KEY ako zadana hodnota KEY, 1. ITERATOR odkazuje na END ITERATOR. Ak UNORDERED MULTISET NEMA ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY, 2. ITERATOR odkazuje na END ITERATOR.
   41. METHOD bucket_count() vracia pocet BUCKETS v UNORDERED MULTISET.
   42. METHOD max_bucket_count() vracia maximalny pocet BUCKETS, ktore moze UNORDERED MULTISET obsahovat.
   43. METHOD bucket_size() vracia pocet ITEMS v danom BUCKET, ktory UNORDERED MULTISET obsahuje.
   44. METHOD bucket() vracia INDEX na BUCKET v ktorom sa ITEM s danym KEY nachadza.
   45. METHOD load_factor() vracia priemerny pocet ITEMS v BUCKETS danej UNORDERED MULTISET.
   46. METHOD max_load_factor() vracia MAXIMALNY pocet ITEMS, ktore mozu byt v BUCKET ulozene predtym ako dojde k REHASHING celej UNORDERED MULTISET. OVERLOADED verzia METHOD max_load_factor() umoznuje nastavit MAXIMALNY pocet ITEMS, ktore mozu byt v BUCKET ulozene predtym ako dojde k REHASHING celej UNORDERED MULTISET.
   47. METHOD rehash() vykona REHASH celej UNORDERED MULTISET, tak aby ITEMS boli rozdelene do poctu BUCKETS, ktory definuje PARAMETER METHOD rehash().
   48. METHOD reserve() nastavi pocet BUCKETS na taku hodnotu aby kazdy BUCKET mohol obsahovat aspon pocet ITEMS zadanom v PARAMETERI METHOD reserve(). METHOD reserve() zaroven vykona REHASH celej UNORDERED MULTISET.
   49. METHOD hash_function() vracia FUNCTION OBJECT pouzivany ako HASH FUNCTION na vypocet HASH CODE, ktory urcuje do ktoreho BUCKET bude ITEM ulozeny.
   50. METHOD METHOD key_eq() vracia FUNCTION OBJECT, ktory sa pouziva na porovnavanie rovnosti hodnot KEYS.
   51. FUNCTION swap() vymiena obsah dvoch instancii UNORDERED MULTISET vymenou ich vnutornych FIELDS.
46. CLASS [unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>] reprezentuje HASH TABLE BEZ moznosti OPAKOVANIA ITEMS s rovnakou hodnotou KEYS. Pre CLASS [unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>] platia nasledujuce fakty.
   A. UNORDERED MAP je definovana v LIBRARY <unordered_map>.
   !!! B. UNORDERED MAP je implementovana ako HASH TABLE, ktora uklada ITEMS do BUCKETS. BUCKETS su implementovane ako JEDNOSMERNE, alebo OBOJSMERNE LISTS.
   C. UNORDERED MAPS NEMOZU obsahovat VIACERO ITEMS s TYM ISTYM KEY.
   D. ITEMS v UNORDERED MAPS NIE su SORTED. Su ulozene v nedefinovanom poradi co je rozdiel oproti MAPS, kde su ITEMS SORTED.
   E. UNORDERED MAP ma ako ITEMS instancie CLASS [pair<const TKey,TValue].
   F. KEYS pouzivane v MAPS MUSIA byt COPYABLE, MOVABLE, EQUATABLE pomocou TEMPLATE PARAMETER 'TKeyEqual' a HASHABLE pomocou TEMPLATE PARAMETER 'THash'.
   G. VALUES pouzivane v MAPS MUSIA byt COPYABLE a MOVABLE.
   !!!!! H. ITEMS su ukladane do BUCKETS VYLUCNE podla HASH hodnoty ich KEYS. V pripade, ze pre 2 rozlicne ITEMS HASH FUNCTION vracia TEN ISTY HASH CODE, ITEMS su ukladane do LIST v TOM ISTOM BUCKET.
   I. TEMPLATE PARAMETER 'THash' reprezentuje HASH FUNCTION, ktora sa pouziva na vypocet HASH VALUES. DEFAULT VALUE je STRUCTURE [hash<TKey>].
   !!! J. TEMPLATE PARAMETER 'TKeyEqual' reprezentuje EQUATABLE FUNCTION, ktora sa pouziva na urcenie ci 2 KEYS su rovnake. Pouziva sa na vyhladanie ITEM v BUCKET. DEFAULT VALUE je STRUCTURE [equal_to<TKey].
   K. UNORDERED MAP umoznuje v TEMPLATE PARAMETER 'TAllocator' definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii UNORDERED MAP.
   !!!!! L. UNORDERED MAP ma vysoku PERFORMANCE pri pristupe k ITEMS pomocou ich KEYS. Priemerna zlozitost pri pristupe k ITEMS je O(1). Najhorsia zlozitost (ak HASH TABLE pouziva nedokonalu HASH FUNCTION) je O(N).
   M. UNORDERED MAP ma nizku PERFORMANCE pri pristupe k ITEMS pomocou ich VALUES.
   N. UNORDERED MAP ma vysoku PERFORMANCE pri pridavani ITEMS.
   O. UNORDERED MAP ma vysoku PERFORMANCE pri odstranovani ITEMS podla hodnoty ich KEYS.
   P. UNORDERED MAP ma nizku PERFORMANCE pri odstranovani ITEMS podla hodnoty ich VALUES.
   !!! Q. Hodnoty KEYS su CONSTANT a NESMU sa MENIT. Ak je potrebne hodnotu KEY zmenit, je nutne ITEM odstranit z UNORDERED MAP a pridat ho znova s modifikovanou hodnotou KEY.
   !!!!! R. Pri pridavani ITEMS do UNORDERED MAP pomocou METHOD unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>.insert() moze dojst k prekroceniu hranice urcujucej maximalny pocet ITEMS v BUCKET, ktoru je mozne definovat programovo. Ak je tato hranica prekrocena, UNORDERED MAP AUTOMATICKY vykona REHASHING. REHASHING je mozne vykonat aj explicitne volanim METHOD unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>.rehash(), alebo METHOD unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>.reserve(). Pri REHASING su vsetky ITERATOR INVALID.
   S. Pri odstranovani ITEMS z UNORDERED MAP pomocou METHOD unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>.erase() NIKDY NEDOCHADZA k REHASING.
   !!!!! T. Pri vyhladavani ITEMS v UNORDERED MAP sa NAJPRV pouzije HASH VALUE vypocitana podla TEMPLATE PARAMETER 'THash' na urcenie v ktorom BUCKET sa ITEM nachadza a NASLEDNE sa pomocou TEMPLATE PARAMETER 'TKeyEqual' v danom BUCKET najde hladany ITEM.
47. CLASS [unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu UNORDERED MAP.
   2. DESTRUCTOR uvolnuje instanciu UNORDERED MAP ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [key_type] urcuje KEY TYPE ITEMS ulozenych v UNORDERED MAP.
   4. TYPE [mapped_type] urcuje VALUE TYPE ITEMS ulozenych v UNORDERED MAP.
   5. TYPE [value_type] urcuje VALUE TYPE ITEMS ulozenych v UNORDERED MAP. Ma hodnotu CLASS [pair<const TKey,TValue>].
   6. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   7. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   8. TYPE [hasher] obsahuje TYPE pouzivany na vypocet HASH FUNCTION daneho KEY.
   9. TYPE [key_equal] obsahuje TYPE pouzivany na porovnanie hodnot KEYS.
   10. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   11. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v UNORDERED MAP.
   12. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v UNORDERED MAP.
   13. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v UNORDERED MAP.
   14. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v UNORDERED MAP.
   15. TYPE [iterator] urcuje TYPE pre ITERATOR daneho UNORDERED MAP.
   16. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej UNORDERED MAP.
   17. TYPE [local_iterator] urcuje TYPE pre ITERATOR daneho UNORDERED MAP pouzivany na prechod ITEMS v ramci jedneho BUCKET. ITERATOR NIE JE MOZNE pouzit na prechod medzi ITEMS v rozlicnych BUCKETS.
   18. TYPE [const_local_iterator] urcuje TYPE pre CONST ITERATOR danej UNORDERED MAP pouzivany na prechod ITEMS v ramci jedneho BUCKET. ITERATOR NIE JE MOZNE pouzit na prechod medzi ITEMS v rozlicnych BUCKETS.
   19. TYPE [node_type] urcuje TYPE pre UNORDERED MAP NODE reprezentujuci NODES ulozene v UNORDERED MAP.
   20. TYPE [insert_return_type] urcuje TYPE pouzivany na reprezentaciu vysledku vkladania ITEM do UNORDERED MAP. Obsahuje informaciu ci ITEM bol do UNORDERED MAP vlozeny, poziciu na ktoru bol vlozeny a instanciu CLASS [node_type] obsahuju NODE do ktoreho bol ITEM vlozeny.
   21. OPERATOR= priradzuje do UNORDERED MAP ITEMS inej UNORDERED MAP. UNORDERED MAP obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   22. OPERATOR== zistuje ci dve instancie UNORDERED MAP su lexikograficky rovne.
   23. OPERATOR!= zistuje ci dve instancie UNORDERED MAP su lexikograficky rozne.
   !!!!! 24. OPERATOR[] vracia REFERENCE na ITEM danej UNORDERED MAP podla hodnoty jeho KEY. V pripade, ze KEY s danou hodnotou sa v UNORDERED MAP NENACHADZA, ITEM sa do UNORDERED MAP ulozi.
   !!! 25. METHOD at() vracia REFERENCE na ITEM danej UNORDERED MAP podla hodnoty jeho KEY. Ak ITEM s danym KEY sa v UNORDERED MAP nenachadza, METHOD unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>.at() generuje EXCEPTION [out_of_range].
   26. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej UNORDERED MAP.
   27. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM UNORDERED MAP. OVERLOADED verzia vracia ITERATOR na PRVY ITEM v danom BUCKET.
   28. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM UNORDERED MAP. OVERLOADED verzia vracia ITERATOR na PRVY ITEM v danom BUCKET.
   29. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM UNORDERED MAP. OVERLOADED verzia vracia ITERATOR na POSLEDNY ITEM v danom BUCKET.
   30. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM UNORDERED MAP. OVERLOADED verzia vracia ITERATOR hned za POSLEDNY ITEM v danom BUCKET.
   31. METHOD empty() vracia informaciu ci UNORDERED MAP je prazdna.
   32. METHOD size() vracia pocet ITEMS v UNORDERED MAP.
   33. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do UNORDERED MAP mozne ulozit.
   34. METHOD clear() odstranuje vsetky ITEMS z UNORDERED MAP.
   35. METHOD insert() pridava ITEM, alebo NODE do UNORDERED MAP. METHOD vracia informaciu o tom ci ITEM bol pridany do UNORDERED MAP a poziciu na ktoru bol ITEM vlozeny.
   36. METHOD insert_or_assign() pridava ITEM, alebo NODE do UNORDERED MAP, ak KEY v UNORDERED MAP neexistuje. Ak KEY v UNORDERED MAP existuje, zmeni jeho VALUE.
   37. METHOD emplace() pridava ITEM do UNORDERED MAP pomocou PLACEMENT NEW. PARAMETERS METHOD unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>.emplace() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED MAP. METHOD vracia informaciu o tom ci ITEM bol pridany do UNORDERED MAP a poziciu na ktoru bol ITEM vlozeny.
   38. METHOD emplace_hint() pridava ITEM do UNORDERED MAP pomocou PLACEMENT NEW, pricom 1. PARAMETER reprezenuje ITERATOR sluziaci ako HINT. HINT urcuje poziciu PRED ktorou sa v co najmensej vzdialenosti ma UNORDERED MAP pokusit ITEM ulozit. PARAMETERS METHOD unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>.emplace_hint() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED MAP. METHOD vracia ITERATOR na poziciu na ktoru bol ITEM vlozeny.
   39. METHOD try_emplace() pridava ITEM do UNORDERED MAP pomocou PLACEMENT NEW ak ITEMS s danym KEY v UNORDERED MAP NEEXISTUJE. Ak EXISTUJE, METHOD NIC NEROBI. PARAMETERS METHOD unordered_map<TKey,TValue,THash,TKeyEqual,TAllocator>.try_emplace() od 2. PARAMETER (v OVERLOADED VERZIA s HINT od 3. PARAMETER) su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED MAP.
   40. METHOD erase() odstranuje 1-N ITEMS z UNORDERED MAP. Pri odstranovani 1 ITEM UNORDERED MAP definuje OVERLOADED verziu, kde sa zadava hodnota KEY. Ostatne OVERLOADED verzie vyzaduju zadanie 1, alebo 2 ITERATORS. Verzia s 2 ITERATORS umoznuju odstranenie viacerych ITEMS.
   41. METHOD swap() vymiena obsah dvoch instancii UNORDERED MAP vymenou ich vnutornych FIELDS.
   !!! 42. METHOD extract() odstranuje NODE z UNORDERED MAP. NODE je urceny pomocou ITERATOR, alebo KEY.
   !!! 43. METHOD merge() vybera NODES z UNORDERED MAP, alebo UNORDERED MULTIMAP definovanej ako PARAMETER a uklada ich do UNORDERED MAP pre ktoru bola METHOD volana. ITEMS, ktore maju rovnaku hodnotu KEY v SOURCE a DESTINATION UNORDERED MAP nie su presunute do DESTINATION UNORDERED MAP. METHOD umoznuje efektivne kopirovanie NODES medzi dvoma instanciami UNORDERED MAP bez nutnosti vykonat kopiu ITEMS. OVERLOADED verzia umoznuje prenasat NODES z UNORDERED MULTIMAP.
   44. METHOD count() vracia pocet ITEMS s danou hodnotou UNORDERED MAP.
   45. METHOD find() vracia ITERATOR na ITEM s danou hodnotou UNORDERED MAP.
   46. METHOD equal_range() vracia ITERATOR PAIR, kde 1. ITERATOR odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU KEY ako zadana hodnota KEY a DRUHY ITERATOR odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY. Ak UNORDERED MAP NEMA ITEM, ktory ma MENSIU HODNOTU KEY ako zadana hodnota KEY, 1. ITERATOR odkazuje na END ITERATOR. Ak UNORDERED MAP NEMA ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY, 2. ITERATOR odkazuje na END ITERATOR.
   47. METHOD bucket_count() vracia pocet BUCKETS v UNORDERED MAP.
   48. METHOD max_bucket_count() vracia maximalny pocet BUCKETS, ktore moze UNORDERED MAP obsahovat.
   49. METHOD bucket_size() vracia pocet ITEMS v danom BUCKET, ktory UNORDERED MAP obsahuje.
   50. METHOD bucket() vracia INDEX na BUCKET v ktorom sa ITEM s danym KEY nachadza.
   51. METHOD load_factor() vracia priemerny pocet ITEMS v BUCKETS danej UNORDERED MAP.
   52. METHOD max_load_factor() vracia MAXIMALNY pocet ITEMS, ktore mozu byt v BUCKET ulozene predtym ako dojde k REHASHING celej UNORDERED MAP. OVERLOADED verzia METHOD max_load_factor() umoznuje nastavit MAXIMALNY pocet ITEMS, ktore mozu byt v BUCKET ulozene predtym ako dojde k REHASHING celej UNORDERED MAP.
   53. METHOD rehash() vykona REHASH celej UNORDERED MAP, tak aby ITEMS boli rozdelene do poctu BUCKETS, ktory definuje PARAMETER METHOD rehash().
   54. METHOD reserve() nastavi pocet BUCKETS na taku hodnotu aby kazdy BUCKET mohol obsahovat aspon pocet ITEMS zadanom v PARAMETERI METHOD reserve(). METHOD reserve() zaroven vykona REHASH celej UNORDERED MAP.
   55. METHOD hash_function() vracia FUNCTION OBJECT pouzivany ako HASH FUNCTION na vypocet HASH CODE, ktory urcuje do ktoreho BUCKET bude ITEM ulozeny.
   56. METHOD key_eq() vracia FUNCTION OBJECT, ktory sa pouziva na porovnavanie rovnosti hodnot KEYS.
   57. FUNCTION swap() vymiena obsah dvoch instancii UNORDERED MAP vymenou ich vnutornych FIELDS.
48. CLASS [unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>] reprezentuje HASH TABLE s moznostou OPAKOVANIA ITEMS s rovnakou hodnotou KEYS. Pre CLASS [unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>] platia nasledujuce fakty.
   A. UNORDERED MULTIMAP je definovana v LIBRARY <unordered_map>.
   !!! B. UNORDERED MULTIMAP je implementovana ako HASH TABLE, ktora uklada ITEMS do BUCKETS. BUCKETS su implementovane ako JEDNOSMERNE, alebo OBOJSMERNE LISTS.
   !!! C. UNORDERED MULTIMAPS MOZU obsahovat VIACERO ITEMS s TYM ISTYM KEY.
   D. ITEMS v UNORDERED MULTIMAPS NIE su SORTED. Su ulozene v nedefinovanom poradi co je rozdiel oproti MULTIMAPS, kde su ITEMS SORTED.
   E. UNORDERED MULTIMAP ma ako ITEMS instancie CLASS [pair<const TKey,TValue].
   F. KEYS pouzivane v MULTIMAPS MUSIA byt COPYABLE, MOVABLE, EQUATABLE pomocou TEMPLATE PARAMETER 'TKeyEqual' a HASHABLE pomocou TEMPLATE PARAMETER 'THash'.
   G. VALUES pouzivane v MULTIMAPS MUSIA byt COPYABLE a MOVABLE.
   !!!!! H. ITEMS su ukladane do BUCKETS VYLUCNE podla HASH hodnoty ich KEYS. V pripade, ze pre 2 rozlicne ITEMS HASH FUNCTION vracia TEN ISTY HASH CODE, ITEMS su ukladane do LIST v TOM ISTOM BUCKET.
   I. TEMPLATE PARAMETER 'THash' reprezentuje HASH FUNCTION, ktora sa pouziva na vypocet HASH VALUES. DEFAULT VALUE je STRUCTURE [hash<TKey>].
   !!! J. TEMPLATE PARAMETER 'TKeyEqual' reprezentuje EQUATABLE FUNCTION, ktora sa pouziva na urcenie ci 2 KEYS su rovnake. Pouziva sa na vyhladanie ITEM v BUCKET. DEFAULT VALUE je STRUCTURE [equal_to<TKey].
   K. UNORDERED MULTIMAP umoznuje v TEMPLATE PARAMETER 'TAllocator' definovat CUSTOM ALLOCATOR umoznujuci CUSTOM MEMORY MANAGEMENT pri alokacii UNORDERED MULTIMAP.
   !!!!! L. UNORDERED MULTIMAP ma vysoku PERFORMANCE pri pristupe k ITEMS pomocou ich KEYS. Priemerna zlozitost pri pristupe k ITEMS je O(1). Najhorsia zlozitost (ak HASH TABLE pouziva nedokonalu HASH FUNCTION) je O(N).
   M. UNORDERED MULTIMAP ma nizku PERFORMANCE pri pristupe k ITEMS pomocou ich VALUES.
   N. UNORDERED MULTIMAP ma vysoku PERFORMANCE pri pridavani ITEMS.
   O. UNORDERED MULTIMAP ma vysoku PERFORMANCE pri odstranovani ITEMS podla hodnoty ich KEYS.
   P. UNORDERED MULTIMAP ma nizku PERFORMANCE pri odstranovani ITEMS podla hodnoty ich VALUES.
   !!! Q. Hodnoty KEYS su CONSTANT a NESMU sa MENIT. Ak je potrebne hodnotu KEY zmenit, je nutne ITEM odstranit z UNORDERED MULTIMAP a pridat ho znova s modifikovanou hodnotou KEY.
   !!!!! R. Pri pridavani ITEMS do UNORDERED MULTIMAP pomocou METHOD unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>.insert() moze dojst k prekroceniu hranice urcujucej maximalny pocet ITEMS v BUCKET, ktoru je mozne definovat programovo. Ak je tato hranica prekrocena, UNORDERED MULTIMAP AUTOMATICKY vykona REHASHING. REHASHING je mozne vykonat aj explicitne volanim METHOD unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>.rehash(), alebo METHOD unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>.reserve(). Pri REHASING su vsetky ITERATOR INVALID.
   S. Pri odstranovani ITEMS z UNORDERED MULTIMAP pomocou METHOD unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>.erase() NIKDY NEDOCHADZA k REHASING.
   T. Ak UNORDERED MULTIMAP obsahuje viacero ITEMS s rovnakymi KEYS, pri iterovani ITEMS su tieto ITEMS ulozene za sebou pricom aj po REHASING ostava ich poradie zachovane.
   !!!!! U. Pri vyhladavani ITEMS v UNORDERED MULTIMAP sa NAJPRV pouzije HASH VALUE vypocitana podla TEMPLATE PARAMETER 'THash' na urcenie v ktorom BUCKET sa ITEM nachadza a NASLEDNE sa pomocou TEMPLATE PARAMETER 'TKeyEqual' v danom BUCKET najde hladany ITEM.
49. CLASS [unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>] ma nasledujuce MEMBERS.
   1. CONSTRUCTOR vytvara instanciu UNORDERED MULTIMAP.
   2. DESTRUCTOR uvolnuje instanciu UNORDERED MULTIMAP ako aj jednotlive ITEMS pre ktore je zavolany ich DESTRUCTOR.
   3. TYPE [key_type] urcuje KEY TYPE ITEMS ulozenych v UNORDERED MULTIMAP.
   4. TYPE [mapped_type] urcuje VALUE TYPE ITEMS ulozenych v UNORDERED MULTIMAP.
   5. TYPE [value_type] urcuje VALUE TYPE ITEMS ulozenych v UNORDERED MULTIMAP. Ma hodnotu CLASS [pair<const TKey,TValue>].
   6. TYPE [size_type] je UNSIGNED TYPE reprezentujuci hodnoty urcujuce velkost a pocet.
   7. TYPE [difference_type] je SIGNED TYPE reprezentujuci hodnoty urcujuce rozdiel.
   8. TYPE [hasher] obsahuje TYPE pouzivany na vypocet HASH FUNCTION daneho KEY.
   9. TYPE [key_equal] obsahuje TYPE pouzivany na porovnanie hodnot KEYS.
   10. TYPE [allocator_type] urcuje TYPE, ktory sa pouziva ako ALLOCATOR.
   11. TYPE [reference] urcuje REFERENCE TYPE pre ITEMS ulozene v UNORDERED MULTIMAP.
   12. TYPE [const_reference] urcuje CONST REFERENCE TYPE pre ITEMS ulozene v UNORDERED MULTIMAP.
   13. TYPE [pointer] urcuje POINTER TYPE pre ITEMS ulozene v UNORDERED MULTIMAP.
   14. TYPE [const_pointer] urcuje CONST POINTER TYPE pre ITEMS ulozene v UNORDERED MULTIMAP.
   15. TYPE [iterator] urcuje TYPE pre ITERATOR daneho UNORDERED MULTIMAP.
   16. TYPE [const_iterator] urcuje TYPE pre CONST ITERATOR danej UNORDERED MULTIMAP.
   17. TYPE [local_iterator] urcuje TYPE pre ITERATOR daneho UNORDERED MULTIMAP pouzivany na prechod ITEMS v ramci jedneho BUCKET. ITERATOR NIE JE MOZNE pouzit na prechod medzi ITEMS v rozlicnych BUCKETS.
   18. TYPE [const_local_iterator] urcuje TYPE pre CONST ITERATOR danej UNORDERED MULTIMAP pouzivany na prechod ITEMS v ramci jedneho BUCKET. ITERATOR NIE JE MOZNE pouzit na prechod medzi ITEMS v rozlicnych BUCKETS.
   19. TYPE [node_type] urcuje TYPE pre UNORDERED MULTIMAP NODE reprezentujuci NODES ulozene v UNORDERED MULTIMAP.
   20. OPERATOR= priradzuje do UNORDERED MULTIMAP ITEMS inej UNORDERED MULTIMAP. UNORDERED MULTIMAP obsahuje COPY OPERATOR= aj MOVE OPERATOR= ako aj verziu pre INITIALIZER LIST.
   21. OPERATOR== zistuje ci dve instancie UNORDERED MULTIMAP su lexikograficky rovne.
   22. OPERATOR!= zistuje ci dve instancie UNORDERED MULTIMAP su lexikograficky rozne.
   23. METHOD get_allocator() vracia instanciu ALLOCATOR, ktora sa pouziva pri alokovani ITEMS danej UNORDERED MULTIMAP.
   24. METHOD begin() vracia ITERATOR ukazujuci na PRVY ITEM UNORDERED MULTIMAP. OVERLOADED verzia vracia ITERATOR na PRVY ITEM v danom BUCKET.
   25. METHOD cbegin() vracia CONST ITERATOR ukazujuci na PRVY ITEM UNORDERED MULTIMAP. OVERLOADED verzia vracia ITERATOR na PRVY ITEM v danom BUCKET.
   26. METHOD end() vracia ITERATOR ukazujuci hned za POSLEDNY ITEM UNORDERED MULTIMAP. OVERLOADED verzia vracia ITERATOR na POSLEDNY ITEM v danom BUCKET.
   27. METHOD cend() vracia CONST ITERATOR ukazujuci hned za POSLEDNY ITEM UNORDERED MULTIMAP. OVERLOADED verzia vracia ITERATOR hned za POSLEDNY ITEM v danom BUCKET.
   28. METHOD empty() vracia informaciu ci UNORDERED MULTIMAP je prazdna.
   29. METHOD size() vracia pocet ITEMS v UNORDERED MULTIMAP.
   30. METHOD max_size() vracia maximalny pocet ITEMS, ktore je do UNORDERED MULTIMAP mozne ulozit.
   31. METHOD clear() odstranuje vsetky ITEMS z UNORDERED MULTIMAP.
   32. METHOD insert() pridava ITEM, alebo NODE do UNORDERED MULTIMAP. METHOD vracia ITERATOR na poziciu na ktoru bol ITEM vlozeny.
   33. METHOD emplace() pridava ITEM do UNORDERED MULTIMAP pomocou PLACEMENT NEW. PARAMETERS METHOD unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>.emplace() su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED MULTIMAP. METHOD vracia ITERATOR na poziciu na ktoru bol ITEM vlozeny.
   34. METHOD emplace_hint() pridava ITEM do UNORDERED MULTIMAP pomocou PLACEMENT NEW, pricom 1. PARAMETER reprezenuje ITERATOR sluziaci ako HINT. HINT urcuje poziciu PRED ktorou sa v co najmensej vzdialenosti ma UNORDERED MULTIMAP pokusit ITEM ulozit. PARAMETERS METHOD unordered_multimap<TKey,TValue,THash,TKeyEqual,TAllocator>.emplace_hint() od 2. PARAMETER su FORWARDED do CONSTRUCTOR daneho ITEM volaneho pri pridavani ITEM do UNORDERED MULTIMAP. METHOD vracia ITERATOR na poziciu na ktoru bol ITEM vlozeny.
   35. METHOD erase() odstranuje 1-N ITEMS z UNORDERED MULTIMAP. Pri odstranovani 1 ITEM UNORDERED MULTIMAP definuje OVERLOADED verziu, kde sa zadava hodnota KEY. Ostatne OVERLOADED verzie vyzaduju zadanie 1, alebo 2 ITERATORS. Verzia s 2 ITERATORS umoznuju odstranenie viacerych ITEMS.
   36. METHOD swap() vymiena obsah dvoch instancii UNORDERED MULTIMAP vymenou ich vnutornych FIELDS.
   !!! 37. METHOD extract() odstranuje NODE z UNORDERED MULTIMAP. NODE je urceny pomocou ITERATOR, alebo KEY.
   !!! 38. METHOD merge() vybera NODES z UNORDERED MULTIMAP, alebo UNORDERED MAP definovanej ako PARAMETER a uklada ich do UNORDERED MULTIMAP pre ktoru bola METHOD volana. ITEMS, ktore maju rovnaku hodnotu KEY v SOURCE a DESTINATION UNORDERED MULTIMAP nie su presunute do DESTINATION UNORDERED MULTIMAP. METHOD umoznuje efektivne kopirovanie NODES medzi dvoma instanciami UNORDERED MULTIMAP bez nutnosti vykonat kopiu ITEMS. OVERLOADED verzia umoznuje prenasat NODES z UNORDERED MAP.
   39. METHOD count() vracia pocet ITEMS s danou hodnotou UNORDERED MULTIMAP.
   40. METHOD find() vracia ITERATOR na ITEM s danou hodnotou UNORDERED MULTIMAP.
   41. METHOD equal_range() vracia ITERATOR PAIR, kde 1. ITERATOR odkazuje na PRVY ITEM, ktory NEMA MENSIU HODNOTU KEY ako zadana hodnota KEY a DRUHY ITERATOR odkazuje na PRVY ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY. Ak UNORDERED MULTIMAP NEMA ITEM, ktory ma MENSIU HODNOTU KEY ako zadana hodnota KEY, 1. ITERATOR odkazuje na END ITERATOR. Ak UNORDERED MULTIMAP NEMA ITEM, ktory ma VACSIU HODNOTU KEY ako zadana hodnota KEY, 2. ITERATOR odkazuje na END ITERATOR.
   42. METHOD bucket_count() vracia pocet BUCKETS v UNORDERED MULTIMAP.
   43. METHOD max_bucket_count() vracia maximalny pocet BUCKETS, ktore moze UNORDERED MULTIMAP obsahovat.
   44. METHOD bucket_size() vracia pocet ITEMS v danom BUCKET, ktory UNORDERED MULTIMAP obsahuje.
   45. METHOD bucket() vracia INDEX na BUCKET v ktorom sa ITEM s danym KEY nachadza.
   46. METHOD load_factor() vracia priemerny pocet ITEMS v BUCKETS danej UNORDERED MULTIMAP.
   47. METHOD max_load_factor() vracia MAXIMALNY pocet ITEMS, ktore mozu byt v BUCKET ulozene predtym ako dojde k REHASHING celej UNORDERED MULTIMAP. OVERLOADED verzia METHOD max_load_factor() umoznuje nastavit MAXIMALNY pocet ITEMS, ktore mozu byt v BUCKET ulozene predtym ako dojde k REHASHING celej UNORDERED MULTIMAP.
   48. METHOD rehash() vykona REHASH celej UNORDERED MULTIMAP, tak aby ITEMS boli rozdelene do poctu BUCKETS, ktory definuje PARAMETER METHOD rehash().
   49. METHOD reserve() nastavi pocet BUCKETS na taku hodnotu aby kazdy BUCKET mohol obsahovat aspon pocet ITEMS zadanom v PARAMETERI METHOD reserve(). METHOD reserve() zaroven vykona REHASH celej UNORDERED MULTIMAP.
   50. METHOD hash_function() vracia FUNCTION OBJECT pouzivany ako HASH FUNCTION na vypocet HASH CODE, ktory urcuje do ktoreho BUCKET bude ITEM ulozeny.
   51. METHOD key_eq() vracia FUNCTION OBJECT, ktory sa pouziva na porovnavanie rovnosti hodnot KEYS.
   52. FUNCTION swap() vymiena obsah dvoch instancii UNORDERED MULTIMAP vymenou ich vnutornych FIELDS.
50. C++ ALGORITHMS su definovane v nasledujucich LIBRARIES.
   A. LIBRARY <algorithm> definuje vacsinu ALGORITHMS.
   B. LIBRARY <numeric> definuje matematicke ALGORITHMS.
   C. LIBRARY <memory> definuje ALGORITHMS pracujuce s RAW MEMORY a OBJECTS.
51. C++ ALGORITHMS boli navrhnute podla nasledujucich principov.
   A. C++ ALGORITHMS pracuju nad COLLECTIONS, ktore su definovane bud pomocou ITERATOR PAIR, alebo pomocou BEGIN ITERATOR. ITERATOR PAIR sa pouziva nad hlavnou COLLECTION, ktoru ALGORITHM prechadza. Ak ALGORITHM vyzaduje pracu s dalsou COLLECTION, ta je spravidla definovana iba pomocou BEGIN ITERATOR a pocet ITEMS v tejto COLLECTION musi byt minimalne taky ako je pocet ITEMS v hlavnej COLLECTION definovanej ITERATOR PAIR.
   B. C++ ALGORITHMS definuju COLLECTION ako POLOOTVORENU, kde BEGIN ITERATOR ukazuje na prvy ITEM v COLLECTION a END ITERATOR ukazuje 1 POSITION za koniec COLLECTION.
   C. C++ ALGORITHMS prepisuju VALUES ITEMS nad ktorymi pracuju namiesto toho, aby tieto ITEMS vkladali ci odstranovali.
   D. C++ ALGORITHMS odstranuju ITEMS z COLLECTION tak, ze ich presuvaju na koniec COLLECTION, pricom vracaju ako RETURN VALUE novy END ITERATOR, ktory ukazuje na prvy odstraneny ITEM.
   E. C++ ALGORITHMS, ktore vyzaduju vykonanie COMPARISION ci TEST nad ITEMS umoznuju definovat CUSTOM COMPARERS ci CUSTOM PREDICATES, ktore su formou FUNCTION OBJECTS zasielane do C++ ALGORITHMS.
52. C++ definuje nasledujuce ALGORITHMS.
   1. FUNCTION all_of() vracia TRUE ak VSETKY ITEMS v RANGE definovanym ITERATOR PAIR vratili pre PREDICATE zaslany ako PARAMETER TRUE. Inak vracia FALSE.
   2. FUNCTION any_of() vracia TRUE ak ASPON 1 ITEM v RANGE definovanym ITERATOR PAIR vratil pre PREDICATE zaslany ako PARAMETER TRUE. Inak vracia FALSE.
   3. FUNCTION none_of() vracia TRUE ak ZIADEN ITEM v RANGE definovanym ITERATOR PAIR vratil pre PREDICATE zaslany ako PARAMETER TRUE. Inak vracia FALSE.
   4. FUNCTION for_each() pre kazdy ITEM v RANGE definovanym ITERATOR PAIR vola FUNCTION OBJECT zadanym ako PARAMETER. Vracia FUNCTION OBJECT, ktory bol zaslany ako PARAMETER.
   5. FUNCTION for_each_n() pre kazdy ITEM v RANGE definovanym BEGIN ITERATOR a poctom ITEMS vola FUNCTION OBJECT zadanym ako PARAMETER. Vracia END ITERATOR zadanej RANGE.
   6. FUNCTION count() pre RANGE definovanym ITERATOR PAIR vracia pocet ITEMS, ktorych VALUE je rovna VALUE zadanou ako PARAMETER.
   7. FUNCTION count_if() pre RANGE definovanym ITERATOR PAIR vracia pocet ITEMS, pre ktore PREDICATE zaslany ako PARAMETER vrati TRUE.
   8. FUNCTION mismatch() vracia PAIR obsahujuci prvu dvojicu ITEMS, ktore v RANGE 1 definovanym ITERATOR PAIR a RANGE 2 definovanym BEGIN ITERATOR maju ODLISNE VALUES. Ak sa ITERATOR PAIR NENASIEL, vracia sa ITERATOR PAIR obsahujuci END ITERATORS oboch RANGES.OVERLOADED VERSION umoznuje definovat RANGE 2 pomocou ITERATOR PAIR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   9. FUNCTION equal() vracia BOOLEAN VALUE urcujucu ci RANGE 1 definovanym ITERATOR PAIR ma rovnake ITEMS ako RANGE 2 definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat RANGE 2 pomocou ITERATOR PAIR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   10. FUNCTION find() v RANGE definovanym ITERATOR PAIR prvy ITEM, ktory ma rovnaku VALUE ako VALUE, ktora bola zadana ako PARAMETER. Vracia ITERATOR na najdeny ITEM, alebo END ITERATOR povodnej RANGE, ak sa ITEM nepodarilo najst.
   11. FUNCTION find_if() v RANGE definovanym ITERATOR PAIR prvy ITEM pre ktory PREDICATE zaslany ako PARAMETER vrati TRUE. Vracia ITERATOR na najdeny ITEM, alebo END ITERATOR povodnej RANGE, ak sa ITEM nepodarilo najst.
   12. FUNCTION find_if_not() v RANGE definovanym ITERATOR PAIR prvy ITEM pre ktory PREDICATE zaslany ako PARAMETER vrati FALSE. Vracia ITERATOR na najdeny ITEM, alebo END ITERATOR povodnej RANGE, ak sa ITEM nepodarilo najst.
   13. FUNCTION find_end() v RANGE 1 definovanym ITERATOR PAIR hlada posledny vyskyt RANGE 2 definovanym ITERATOR PAIR. Vracia BEGIN ITERATOR na najdenu RANGE, alebo END ITERATOR na RANGE 1, ak sa hladana RANGE nenasla. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   14. FUNCTION find_first_of() v RANGE 1 definovanym ITERATOR PAIR lubovolny ITEM z RANGE 2 definovanym ITERATOR PAIR. Vracia ITERATOR na najdeny ITEM, alebo END ITERATOR RANGE 1 ak sa hladany ITEM nenasiel. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   15. FUNCTION adjacent_find() v RANGE definovanym ITERATOR PAIR hlada prvy vyskyt dvojice za sebou nasledujucich ITEMS s rovnakou VALUE. Vracia ITERATOR na najdenu postupnost, alebo END ITERATOR povodnej RANGE, ak sa hladana postupnost nenasla. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   16. FUNCTION search() v RANGE 1 definovanym ITERATOR PAIR hlada RANGE 2 definovanym ITERATOR PAIR. Vracia BEGIN ITERATOR na najdenu RANGE, alebo END ITERATOR na RANGE 1, ak sa hladana RANGE nenasla. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER. OVERLOADED VERSION umoznuje definovat aj FUNCTION OBJECT, ktory sa na vyhladavanie RANGE pouzije.
   17. FUNCTION search_n() v RANGE definovanym ITERATOR PAIR hlada postupnost 'N' ITEMS, kde 'N' je zadany ako PARAMETER, ktore maju VALUE rovnakou ako VALUE zadanou ako PARAMETER. Vracia BEGIN ITERATOR na zaciatok najdenej postupnosti, alebo END ITERATOR na koniec povodnej RANGE, ak sa v RANGE hladana postupnost nenachadza. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   18. FUNCTION copy() z RANGE definovanym ITERATOR PAIR kopiruje pomocou COPY SEMANTICS do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS. Vracia END ITERATOR odkazujuci 1 POSITION za posledny kopirovany ITEM.
   19. FUNCTION copy_if() z RANGE definovanym ITERATOR PAIR kopiruje pomocou COPY SEMANTICS do OUTPUT RANGE definovanym BEGIN ITERATOR tie ITEMS pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE. Vracia END ITERATOR odkazujuci 1 POSITION za posledny kopirovany ITEM.
   20. FUNCTION copy_n() z RANGE definovanym BEGIN PAIR a poctom ITEMS kopiruje ITEMS pomocou COPY SEMANTICS do OUTPUT RANGE definovanym BEGIN ITERATOR. Vracia END ITERATOR odkazujuci 1 POSITION za posledny kopirovany ITEM.
   21. FUNCTION copy_backward() z RANGE definovanym ITERATOR PAIR kopiruje ITEMS pomocou COPY SEMANTICS do OUTPUT RANGE definovanym END ITERATOR tak, ze ITEMS v OUTPUT RANGE budu v opacnom poradi v akom su v INPUT RANGE. Vracia ITERATOR na posledny kopirovany ITEM.
   22. FUNCTION move() z RANGE definovanym ITERATOR PAIR presuva ITEMS pomocou MOVE SEMANTICS do OUTPUT RANGE definovanym BEGIN ITERATOR. Vracia END ITERATOR odkazujuci 1 POSITION za posledny presunuty ITEM.
   23. FUNCTION move_backward() z RANGE definovanym ITERATOR PAIR presuva ITEMS pomocou MOVE SEMANTICS do OUTPUT RANGE definovanym END ITERATOR tak, ze ITEMS v OUTPUT RANGE budu v opacnom poradi v akom su v INPUT RANGE. Vracia ITERATOR na posledny presunuty ITEM.
   24. FUNCTION fill() do RANGE definovanym ITERATOR PAIR vlozi ITEMS, ktorych VALUES su kopiami VALUE zadanej ako PARAMETER.
   25. FUNCTION fill_n() do RANGE definovanym BEGIN ITERATOR a poctom ITEMS vlozi ITEMS, ktorych VALUES su kopiami VALUE zadanej ako PARAMETER. Vracia END ITERATOR naplnenej RANGE.
   26. FUNCTION transform() nad vsetkymi ITEMS INPUT RANGE 1 definovanym ITERATOR PAIR a INPUT RANGE 2 definovanym BEGIN ITERATOR vykona BINARY OPERATION zadanu ako PARAMETER a vyslednu hodnotu ITEM zapise do OUTPUT RANGE definovanym BEGIN ITERATOR. Vracia END ITERATOR OUTPUT RANGE. OVERLOADED VERSION umoznuje vykonat UNARY OPERATION nad jednym INPUT RANGE.
   27. FUNCTION generate() do RANGE definovanym ITERATOR PAIR vlozi pocet ITEMS generovane pomocou FUNCTION OBJECT zadanym ako PARAMETER.
   28. FUNCTION generate_n() do RANGE definovanym BEGIN ITERATOR a poctom ITEMS vlozi ITEMS, ktorych VALUES su generovane pomocou FUNCTION OBJECT zadanym ako PARAMETER. Vracia END ITERATOR generovanej RANGE.
   29. FUNCTION remove() v INPUT RANGE definovanym ITERATOR PAIR presuva vsetky ITEMS s VALUE zadanou ako PARAMETER na koniec RANGE. Vracia ITERATOR na prvy premiestneny ktory tvori logicky END ITERATOR novovzniknutej RANGE <RANGE_BEGIN,RETURN_ITERATOR).
   30. FUNCTION remove_if() v RANGE definovanym ITERATOR PAIR presuva vsetky ITEMS pre ktore PREDICATE zaslany ako PARAMETER vratil TRUE na koniec RANGE. Vracia ITERATOR na prvy premiestneny ktory tvori logicky END ITERATOR novovzniknutej RANGE <RANGE_BEGIN,RETURN_ITERATOR).
   31. FUNCTION remove_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS, pricom vsak ITEMS OKREM TYCH, ktorych VALUE je rovna VALUE zadanou ako PARAMETER.
   32. FUNCTION remove_copy_if() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS OKREM TYCH pre ktore PREDICATE zaslany ako PARAMETER vrati TRUE.
   33. FUNCTION replace() v INPUT RANGE definovanym ITERATOR PAIR nahradza vsetky ITEMS s VALUE 1 zadanou ako PARAMETER za VALUE 2 zadanu ako PARAMETER.
   34. FUNCTION replace_if() v RANGE definovanym ITERATOR PAIR nahradza vsetky ITEMS pre ktore PREDICATE zaslany ako PARAMETER vratil TRUE za VALUE zaslanu ako PARAMETER.
   35. FUNCTION replace_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS, pricom vsak ITEMS s VALUE 1 zadanou ako PARAMETER nahradza za VALUE 2 zadanu ako PARAMETER.
   36. FUNCTION replace_copy_if() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR vsetky ITEMS, pricom ITEMS pre ktore PREDICATE zaslany ako PARAMETER vratil TRUE su nahradene VALUE, ktora bola zaslana ako PARAMETER.
   37. FUNCTION swap() vymiena dvojicu VALUES zadanych ako PARAMETERS. OVERLOADED VERSION umoznuje VALUES dvojice ARRAYS.
   38. FUNCTION swap_ranges() vymiena VALUES v RANGE 1 definovanym ITERATOR PAIR s VALUES v RANGE 2 definovanym BEGIN ITERATOR.
   39. FUNCTION iter_swap() vymiena VALUES dvojice ITEMS definovanych pomocou ITERATORS.
   40. FUNCTION reverse() v INPUT RANGE definovanym ITERATOR PAIR premiestnuje ITEMS, pricom poradie ITEMS je reverzne voci povodnemu poradiu.
   41. FUNCTION reverse_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje ITEMS do OUTPUT RANGE definovanym BEGIN ITERATOR, pricom poradie ITEMS v OUTPUT RANGE je reverzne voci poradiu ITEMS v INPUT RANGE.
   42. FUNCTION rotate() v INPUT RANGE definovanym ITERATOR PAIR premiestnuje ITEMS, pricom poradie ITEMS je cyklicky rotovane tak, aby ITEM na ktory referuje ITERATOR zaslany ako PARAMETER bol na 1. POSITION a ITEM na POSITION (ITERATOR-1) bol na POSLEDNEJ POSITION v RANGE.
   43. FUNCTION rotate_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje ITEMS do OUTPUT RANGE definovanym BEGIN ITERATOR, pricom poradie ITEMS v OUTPUT RANGE je cyklicky rotovane tak, aby ITEM na ktory referuje ITERATOR zaslany ako PARAMETER bol na 1. POSITION OUTPUT RANGE a ITEM na POSITION (ITERATOR-1) bol na POSLEDNEJ POSITION OUTPUT RANGE.
   44. FUNCTION shuffle() v RANGE definovanym ITERATOR PAIR nahodne zamiesa ITEMS pomocou RANDOM GENERATOR zadanym ako PARAMETER.
   45. FUNCTION sample() z INPUT RANGE definovanym ITERATOR PAIR vybera NAHODNYM VYBEROM 'N' ITEMS, kde 'N' je zadany ako PARAMETER a tieto uklada do OUTPUT RANGE definovanym BEGIN ITERATOR. RANDOM GENERATOR je zaslany ako PARAMETER.
   46. FUNCTION unique() v RANGE definovanym ITERATOR PAIR premiestnuje ITEMS tak, aby ITEMS s rovnakou VALUE, ktore nasleduju za sebou boli presunute na koniec RANGE. Zaroven vracia ITERATOR na prvy premiestneny ITEM. Vysledkom je LOGICKY RANGE <RANGE_BEGIN,RETURN_ITERATOR), ktory NEOBSAHUJE za sebou nasledujuce ITEMS s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   47. FUNCTION unique_copy() z INPUT RANGE definovanym ITERATOR PAIR kopiruje do OUTPUT RANGE definovanym BEGIN ITERATOR ITEMS tak, ze sa v OUTPUT RANGE sa NENACHAZAJU ITEMS s ROVNAKOU VALUE za SEBOU. Ak sa v INPUT RANGE taketo ITEMS nachadzaju, do OUTPUT RANGE je vlozeny iba 1. ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   48. FUNCTION is_partitioned() vracia TRUE, ak v RANGE definovanym ITERATOR PAIR plati, ze ITEMS pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE sa nachadzaju PRED ITEMS, pre ktore PREDICATE vracia FALSE. Inak vracia FALSE.
   49. FUNCTION partition() v RANGE definovanym ITERATOR PAIR vykonava SORTING ITEMS, aby vsetky ITEMS, pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE budu v RANGE PRED ITEMS, pre ktore PREDICATE vratil FALSE. Poradie ITEMS s ROVNAKOU VALUE NEMUSI byt ZACHOVANE.
   50. FUNCTION partition_copy() ITEM v RANGE definovanym ITERATOR PAIR kopiruje do dvojice RANGE definovanych BEGIN ITERATORS, pricom do 1. RANGE kopiruje ITEMS pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE a do 2. RANGE kopiruje ITEMS pre ktore PREDICATE vracia FALSE.
   51. FUNCTION stable_partition() v RANGE definovanym ITERATOR PAIR vykonava SORTING ITEMS, aby vsetky ITEMS, pre ktore PREDICATE zaslany ako PARAMETER vracia TRUE budu v RANGE PRED ITEMS, pre ktore PREDICATE vratil FALSE. Poradie ITEMS s ROVNAKOU VALUE je ZACHOVANE.
   52. FUNCTION partition_point() pre RANGE definovanym ITERATOR PAIR vracia ITERATOR na ITEM, ktory NESPLNA PREDICATE zadany ako PARAMETER.
   53. FUNCTION is_sorted() v RANGE definovanym ITERATOR PAIR zistuje ci su vsetky ITEMS v RANGE SORTED. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   54. FUNCTION is_sorted_until() v RANGE definovanym ITERATOR PAIR zistuje kolko ITEMS v RANGE su SORTED. Vracia ITERATOR na ITEM, ktory je v RANGE uz NIE JE SORTED. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   55. FUNCTION sort() v RANGE definovanym ITERATOR PAIR vykonava SORT. Poradie ITEMS s ROVNAKOU VALUE NEMUSI byt ZACHOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   56. FUNCTION partial_sort() v RANGE definovanym ITERATOR PAIR pre ITERATOR urcujuci POSITION v RANGE vykonava PARTIAL SORT. POSITION v RANGE urcuje miesto, ktore ITEMS budu SORTED, pricom plati, ze ITEMS v RANGE <RANGE_BEGIN,POSITION) su SORTED a ZAROVEN maju MENSIU VALUE, ako ktorykolvek ITEM v RANGE (POSITION,RANGE_END). ITEMS v RANGE (POSITION,RANGE_END) NIE su SORTED. Poradie ITEMS s ROVNAKOU VALUE NEMUSI byt ZACHOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   57. FUNCTION partial_sort_copy() v INPUT RANGE definovanym ITERATOR PAIR vykonava PARTIAL SORT. Vysledok je zapisany do OUTPUT RANGE definovanym ITERATOR PAIR. Pocet ITEMS, ktore su SORTED je dany ako MIN((INPUT_RANGE_END-INPUT_RANGE_BEGIN),(OUTPUT_RANGE_END-OUTPUT_RANGE_BEGIN)). Poradie ITEMS s ROVNAKOU VALUE NEMUSI byt ZACHOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   58. FUNCTION stable_sort() v RANGE definovanym ITERATOR PAIR vykonava SORTING vsetkych ITEMS. Poradie ITEMS s ROVNAKOU VALUE OSTAVA ZACHOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   59. FUNCTION nth_element() v RANGE definovanym ITERATOR PAIR pre ITERATOR urcujuci POSITION v RANGE zadanu ako PARAMETER vykona PARTIAL SORT, ktory zabezpeci, ze VSETKY ITEMS pred POSITION na ktoru ukazuje ITERATOR maju MENSIU, alebo ROVNU hodnotu ako ITEMS za POSITION na ktoru ukazuje ITERATOR. Zaroven POSITION na ktoru ukazuje ITERATOR bude obsahovat hodnotu toho ITEM, ktory by sa tam nachadzal, ak by cela COLLECTION bola SORTED. FUNCTION sa lisi od SORT FUNCTIONS v tom, ze NEGARANTUJE, ze VSETKY ITEMS budu SORTED. Garantuje iba to, ze COLLECTION je N-tym ITEM rozdelena na 2 casti, kde ITEMS pred N-tym ITEM su MENSIE, alebo ROVNE, ako ITEMS za N-tym ITEM. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   60. FUNCTION lower_bound() pre SORTED RANGE definovanym ITERATOR PAIR vracia ITERATOR urcujuci ITEM, ktory ma v SORTED RANGE VACSIU, alebo ROVNU VALUE, ako VALUE zadanu ako PARAMETER. V pripade, ze sa taky ITEM v SORTED RANGE NENACHADZA, FUNCTION vracia ITERATOR na POSLEDNY ITEM. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   61. FUNCTION upper_bound() pre SORTED RANGE definovanym ITERATOR PAIR vracia ITERATOR urcujuci ITEM, ktory ma v SORTED RANGE VACSIU VALUE, ako VALUE zadanu ako PARAMETER. V pripade, ze sa taky ITEM v SORTED RANGE NENACHADZA, FUNCTION vracia ITERATOR na POSLEDNY ITEM. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   62. FUNCTION binary_search() vracia BOOLEAN VALUE urcujucu sa ITEM v SORTED RANGE definovanym ITERATOR PAIR nachadza. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   63. FUNCTION equal_range() pre SORTED RANGE definovanym ITERATOR PAIR vracia ITERATOR PAIR urcujuci ITEMS, ktore maju v SORTED RANGE IDENTICKU VALUE, ako VALUE zadanu ako PARAMETER. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   64. FUNCTION merge() vykonava MERGE dvojice v SORTED RANGES definovanych pomocou ITERATOR PAIR. Poradie ITEMS s rovnakou VALUE je ZACHOVANE, pricom ITEMS z 1. SORTED RANGE predchadzaju ITEMS z 2. SORTED RANGE. Vysledny SORTED RANGE je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   65. FUNCTION inplace_merge() vykonava MERGE dvojice v MEMORY PO SEBE IDUCICH SORTED RANGES definovanych pomocou ITERATOR PAIR. Poradie ITEMS s rovnakou VALUE je ZACHOVANE, pricom ITEMS z 1. SORTED RANGE prechadzaju ITESM z 2. SORTED RANGE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   66. FUNCTION includes() vracia BOOLEAN VALUE urcujucu ci kazdy ITEM v SORTED RANGE 2 sa nachadza v SORTED RANGE 1. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   67. FUNCTION set_difference() vykonava DIFFERENCE prvej SORTED RANGE od druhej SORTED RANGE. Obe SORTED RANGES su definovane pomocou ITERATOR PAIR. Pri DIFFERENCE so do vyslednej RANGE zapisovane ITEMS, ktore sa nachadzaju 1. SORTED RANGE, a zaroven sa NENACHADZAJU v 2. SORTED RANGE. Vysledny SORTED SET je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   68. FUNCTION set_intersection() vykonava INTERSECTION dvojice SORTED RANGES definovanych pomocou ITERATOR PAIR. Vysledny SORTED SET je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   69. FUNCTION set_symmetric_difference() vykonava SYMMETRIC DIFFERENCE dvojice SORTED RANGES definovanych pomocou ITERATOR PAIR. Pri SYMETRIC DIFFERENCE so do vyslednej RANGE zapisovane ITEMS, ktore sa nachadzaju IBA v JEDNEJ z dvojice RANGES. Vysledny SORTED SET je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   70. FUNCTION set_union() vykonava UNION dvojice SORTED RANGES definovanych pomocou ITERATOR PAIR. Vysledny SORTED SET je zapisovany do RANGE definovanym BEGIN ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   71. FUNCTION is_heap() vracia BOOLEAN VALUE urcujucu ci ITERATOR PAIR vytvara MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   72. FUNCTION is_heap_until() vracia ITERATOR na posledny ITEM v ITERATOR PAIR, ktory este vytvara MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   73. FUNCTION make_heap() vytvori z ITEM RANGE definovanym pomocou ITERATOR PAIR MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   74. FUNCTION push_heap() vlozi ITEM na koniec ITEM RANGE definovanym pomocou ITERATOR PAIR, ktory tvori MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   75. FUNCTION pop_heap() presunie ITEM s NAJVYSSOU VALUE na koniec ITEM RANGE definovanym pomocou ITERATOR PAIR, ktory tvori MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   76. FUNCTION sort_heap() vykona SORTING nad ITEM RANGE definovanym pomocou ITERATOR PAIR, ktory tvori MAX HEAP. Po vykonani SORTING uz ITEM RANGE nema vlastnosti MAX HEAP. MAX HEAP je COLLECTION kde pre kazdy ITEM s INDEXOM 'I' v intervale <1,N-1>, kde 'N' je pocet ITEMS v COLLECTION plati, ze [COLLECTION(FLOOR((I-2)/2))>=COLLECTION(I)]. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   77. FUNCTION max() vracia VALUE obsahujuci MAXIMUM ITEM z ITEM RANGE definovanym pomocou INITIALIZER LIST. OVERLOADED VERSION umoznuje pouzit VALUE PAIR namiesto INITIALIZER LIST. Ak RANGE obsahuje VIACERO ITEMS s MAXIMALNOU VALUE, vrati sa VALUE PRVEHO ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   78. FUNCTION max_element() vracia ITERATOR obsahujuci poziciu na MAXIMUM ITEM z ITEM RANGE definovanym pomocou ITERATOR PAIR. Ak RANGE obsahuje VIACERO ITEMS s MAXIMALNOU VALUE, vrati sa ITERATOR na PRVY ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   79. FUNCTION min() vracia VALUE obsahujuci MINIMUM ITEM z ITEM RANGE definovanym pomocou INITIALIZER LIST. Ak RANGE obsahuje VIACERO ITEMS s MINIMALNOU VALUE, vrati sa VALUE PRVEHO ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje pouzit VALUE PAIR namiesto INITIALIZER LIST. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   80. FUNCTION min_element() vracia ITERATOR obsahujuci poziciu na MINIMUM ITEM z ITEM RANGE definovanym pomocou ITERATOR PAIR. Ak RANGE obsahuje VIACERO ITEMS s MINIMALNOU VALUE, vrati sa VALUE PRVEHO ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   81. FUNCTION minmax() vracia VALUE PAIR obsahujuci MINIMUM ITEM a MAXIMUM ITEM z ITEM RANGE definovanym pomocou INITIALIZER LIST. OVERLOADED VERSION umoznuje pouzit VALUE PAIR namiesto INITIALIZER LIST. Ak RANGE obsahuje VIACERO ITEMS s MINIMALNOU VALUE, vrati sa VALUE PRVEHO ITEM s rovnakou VALUE. Ak RANGE obsahuje VIACERO ITEMS s MAXIMALNOU VALUE, vrati sa VALUE POSLEDNEHO ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   82. FUNCTION minmax_element() vracia ITERATOR PAIR obsahujuci pozicie na MINIMUM ITEM a MAXIMUM ITEM z ITEM RANGE definovanym pomocou ITERATOR PAIR. Ak RANGE obsahuje VIACERO ITEMS s MINIMALNOU VALUE, vrati sa ITERATOR na PRVY ITEM s rovnakou VALUE. Ak RANGE obsahuje VIACERO ITEMS s MAXIMALNOU VALUE, vrati sa ITERATOR na POSLEDNY ITEM s rovnakou VALUE. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   83. FUNCTION clamp() vracia VALUE, ktora je v INTERVALE <MIN,MAX> stanovenom PARAMETRAMI 'MIN' a 'MAX'. Ak plati, ze [VALUE<MIN], FUNCTION vracia VALUE 'MIN'. Ak plati, ze [VALUE>MAX], FUNCTION vracia VALUE 'MAX'. Ak plati, ze [MIN>= VALUE && VALUE<=MAX], tak FUNCTION vracia VALUE 'VALUE'.
   84. FUNCTION lexicographical_compare() vracia BOOLEAN VALUE urcujucu ci ITERATOR RANGE 1 je LEXIKOGRAFICKY MENSI ako ITERATOR RANGE 2. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   85. FUNCTION is_permutation() vracia BOOLEAN VALUE urcujucu ci existuje PERMUTATION z ITERATOR RANGE 1 do ITERATOR RANGE 2. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   86. FUNCTION next_permutation() modifikuje ITEMS v ITERATOR RANGE tak, aby obsahovali NASLELDUJUCE PERMUTATION z mnoziny vsetkych PERMUTATIONS, ktore su zotriedene LEXIKOGRAFICKY. FUNCTION vracia TRUE, ak takato PERMUTATION existuje, ale FALSE, ak neexistuje. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   87. FUNCTION prev_permutation() modifikuje ITEMS v ITERATOR RANGE tak, aby obsahovali PREDCHADZAJUCU PERMUTATION z mnoziny vsetkych PERMUTATIONS, ktore su zotriedene LEXIKOGRAFICKY. FUNCTION vracia TRUE, ak takato PERMUTATION existuje, ale FALSE, ak neexistuje. OVERLOADED VERSION umoznuje definovat CUSTOM COMPARER.
   88. FUNCTION iota() uklada do ITEMS v ITERATOR RANGE inkrementujucu sa hodnotu od VALUE, ktore je zadana ako PARAMETER.
   89. FUNCTION accumulate() sumuje vsetky hodnoty ITEMS v ITERATOR RANGE aplikaciou BINARY OPERATOR medzi hodnotami ITEMS. Vysledkom aplikacie BINARY OPERATOR je SCALAR VALUE. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM je prenasana ako PARAMETER. OVERLOADED VERSION umoznuje definovanie CUSTOM OPERATORS.
   90. FUNCTION inner_product() aplikuje medzi zodpovedajucimi ITEMS v 2 ITERATOR RANGES BINARY OPERATOR 2. Nasledne nad vysledkami aplikuje BINARY OPERATOR 1, ktory vykona SUM tychto vysledkov. Vysledkom aplikacie BINARY OPERATOR 1 je SCALAR VALUE. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR 1 pri kalkulacii 1. ITEM je prenasana ako PARAMETER. OVERLOADED VERSION umoznuje definovanie CUSTOM OPERATORS.
   91. FUNCTION adjacent_difference() vypocitava ROZDIEL medzi kazdou DVOJICOU NASLEDUJUCICH ITEMS. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM BINARY OPERATOR.
   92. FUNCTION partial_sum() aplikuje medzi hodnotami ITEMS pre KAZDY RANGE <1,I+1) BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I+1) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. OVERLOADED VERSION umoznuje definovat CUSTOM BINARY OPERATOR.
   93. FUNCTION reduce() aplikuje BINARY OPERATOR, ktory vykona SUM jednotlivych ITEMS. Vysledkom aplikacie BINARY OPERATOR je SCALAR VALUE. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE. OVERLOADED VERSION umoznuje definovat START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM. OVERLOADED VERSION umoznuje definovat CUTOM BINARY OPERATOR.
   94. FUNCTION exclusive_scan() aplikuje medzi hodnotami ITEMS pre KAZDY RANGE <1,I) BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM je prenasana ako PARAMETER. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE. OVERLOADED VERSION umoznuje definovat CUSTOM BINARY OPERATOR.
   95. FUNCTION inclusive_scan() aplikuje medzi hodnotami ITEMS pre KAZDY RANGE <1,I+1) BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I+1) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. OVERLOADED VERSION umoznuje definovat START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM ako aj CUSTOM BINARY OPERATOR. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE.
   96. FUNCTION transform_reduce() aplikuje medzi zodpovedajucimi ITEMS v 2 ITERATOR RANGES BINARY OPERATOR 2. Nasledne nad vysledkami aplikuje BINARY OPERATOR 1, ktory vykona SUM tychto vysledkov. Vysledkom aplikacie BINARY OPERATOR 1 je SCALAR VALUE. PORADIE aplikacie BINARY OPERATOR 1 a BINARY OPERATOR 2 je NEDEFINOVANE. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR 1 pri kalkulacii 1. ITEM je prenasana ako PARAMETER. OVERLOADED VERSION umoznuje namiesto BINARY OPERATOR 2 pouzit UNARY OPERATION. OVERLOADED VERSION umoznuje aj definovanie CUSTOM OPERATORS.
   97. FUNCTION transform_exclusive_scan() transformuje KAZDY ITEM v ITERATOR RANGE pomocou UNARY OPERATOR. Nasledne medzi tranformovanymi hodnotami ITEMS pre KAZDY RANGE <1,I) aplikuje BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE. START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM je prenasana ako PARAMETER.
   98. FUNCTION transform_inclusive_scan() transformuje KAZDY ITEM v ITERATOR RANGE pomocou UNARY OPERATOR. Nasledne medzi tranformovanymi hodnotami ITEMS pre KAZDY RANGE <1,I+1) aplikuje BINARY OPERATOR. Vysledkom je PARTIAL SUM hodnot v RANGE <1,I+1) pre kazdy ITERATOR 'I' v ITERATOR RANGE. Vysledky operacie sa ukadaju do RANGE definovanym pomocou OUTPUT ITERATOR. PORADIE aplikacie BINARY OPERATOR je NEDEFINOVANE. OVERLOADED VERSION umoznuje definovat START VALUE, ktora sa pouzije ako vstup do BINARY OPERATOR pri kalkulacii 1. ITEM.
   99. FUNCTION uninitialized_copy() kopiruje ITEMS pomocou COPY SEMANTICS ITEMS z MEMORY RANGE do RAW MEMORY RANGE. MEMORY RANGE je definovany ITERATOR PAIR. RAW MEMORY RANGE je definovana pomocou BEGIN ITERATOR.
   100. FUNCTION uninitialized_copy_n() kopiruje ITEMS pomocou COPY SEMANTICS z MEMORY RANGE do RAW MEMORY RANGE. MEMORY RANGE je definovany BEGIN ITERATOR a poctom ITEMS, ktore maju byt kopirovane. RAW MEMORY RANGE je definovana pomocou BEGIN ITERATOR.
   101. FUNCTION uninitialized_fill() kopiruje ITEM pomocou COPY SEMANTICS do RAW MEMORY RANGE. RAW MEMORY RANGE je definovany ITERATOR PAIR.
   102. FUNCTION uninitialized_fill_n() kopiruje ITEM pomocou COPY SEMANTICS do RAW MEMORY RANGE. RAW MEMORY RANGE je definovany BEGIN ITERATOR a poctom kolkokrat ma byt ITEM skopirovany.
   103. FUNCTION uninitialized_move() presuva ITEMS pomocou MOVE SEMANTICS ITEMS z MEMORY RANGE do RAW MEMORY RANGE. MEMORY RANGE je definovany ITERATOR PAIR. RAW MEMORY RANGE je definovana pomocou BEGIN ITERATOR.
   104. FUNCTION uninitialized_move_n() presuva ITEMS pomocou MOVE SEMANTICS z MEMORY RANGE do RAW MEMORY RANGE. MEMORY RANGE je definovany BEGIN ITERATOR a poctom ITEMS, ktore maju byt presunute. RAW MEMORY RANGE je definovana pomocou BEGIN ITERATOR.
   105. FUNCTION uninitialized_default_construct() vola CONSTRUCTORS TYPE [ITERATOR::value_type] pre RAW MEMORY RANGE definovany ITERATOR PAIR. OBJECTS su vytvarane pomocou DEFAULT INITIALIZATION, kedy sa NEVOLA ZIADEN CONSTRUCTOR.
   106. FUNCTION uninitialized_default_construct_n() vola CONSTRUCTORS TYPE [ITERATOR::value_type] pre RAW MEMORY RANGE definovany BEGIN ITERATOR a poctom OBJECTS, ktore maju byt vytvorene. OBJECTS su vytvarane pomocou DEFAULT INITIALIZATION, kedy sa NEVOLA ZIADEN CONSTRUCTOR.
   107. FUNCTION uninitialized_value_construct() vola CONSTRUCTORS TYPE [ITERATOR::value_type] pre RAW MEMORY RANGE definovany ITERATOR PAIR. OBJECTS su vytvarane pomocou VALUE INITIALIZATION, kedy sa VOLA DEFAULT CONSTRUCTOR.
   108. FUNCTION uninitialized_value_construct_n() vola CONSTRUCTORS TYPE [ITERATOR::value_type] pre RAW MEMORY RANGE definovany BEGIN ITERATOR a poctom OBJECTS, ktore maju byt vytvorene. OBJECTS su vytvarane pomocou VALUE INITIALIZATION, kedy sa VOLA DEFAULT CONSTRUCTOR.
   109. FUNCTION destroy_at() vola DESTRUCTOR pre POINTER na OBJECT, ktory je preneseny ako PARAMETER.
   110. FUNCTION destroy() vola DESTRUCTORS pre OBJECT RANGE definovany ITERATOR PAIR.
   111. FUNCTION destroy_n() vola DESTRUCTORS pre OBJECT RANGE definovany BEGIN ITERATOR a poctom OBJECTS, ktore maju byt odstranene.
53. Kazda STL COLLECTION si definuje vlastne ITERATORS. Niektore specializovane ITERATORS su definovane v LIBRARY <iteratror>.
54. V C++ je akykolvek konstrukt, ktory sa chova ako ITERATOR povazovany za ITERATOR. To znamena, ze aj POINTERS su povazovane za ITERATORS, pretoze maju vsetky vlastnosti ITERATORS. ITERATORS su vsak casto implementovane ako CLASSES, ktore maju chovanie ITERATORS.
55. C++ rozdeluje ITERATORS podla ich vlastnosti do nasledujucich CATEGORIES.
   A. INPUT ITERATORS. Umoznuju citanie dat z COLLECTIONS.
   B. OUTPUT ITERATORS. Umoznuju zapis dat do COLLECTIONS.
   C. FORWARD ITERATORS. Umoznuju citanie dat z COLLECTIONS. Umoznuju iba dopredny posun po ITEMS v COLLECTION.
   D. BIDIRECTIONAL ITERATORS. Umoznuju citanie dat z COLLECTIONS. Umoznuju obojsmerny posun po ITEMS v COLLECTION.
   E. RANDOM-ACCESS ITERATORS. Umoznuju citanie dat z COLLECTIONS. Umoznuju okamzity pristup k lubovolnym ITEMS v COLLECTION.
!!! 56. ITERATORS mozu patrit naraz do viacero CATEGORIES.
57. COLLECTIONS implementuju nasledujuce typy ITERATORS.
   A. ISTREAMS implementuju INPUT ITERATOR.
   B. OSTREAMS implementuju OUTPUT ITERATOR.
   C. INSERTERS implementuju OUTPUT ITERATOR.
   D. FORWARD LISTS implementuju FORWARD ITERATORS.
   E. UNORDERED SETS implementuju FORWARD ITERATORS.
   F. UNORDERED MULTISETS implementuju FORWARD ITERATORS.
   G. UNORDERED MAPS implementuju FORWARD ITERATORS.
   H. UNORDERED MULTIMAPS implementuju FORWARD ITERATORS.
   I. LISTS implementuju BIDIRECTIONAL ITERATORS.
   J. SETS implementuju BIDIRECTIONAL ITERATORS.
   K. MULTISETS implementuju BIDIRECTIONAL ITERATORS.
   L. MAPS implementuju BIDIRECTIONAL ITERATORS.
   M. MULTIMAPS implementuju BIDIRECTIONAL ITERATORS.
   N. ARRAYS implementuju RANDOM-ACCESS ITERATORS.
   O. VECTORS implementuju RANDOM-ACCESS ITERATORS.
   P. DEQUEUES implementuju RANDOM-ACCESS ITERATORS.
   Q. STRINGS implementuju RANDOM-ACCESS ITERATORS.
   R. C-ARRAYS implementuju RANDOM-ACCESS ITERATORS.
58. Pre OUTPUT ITERATORS platia nasledujuce fakty.
   A. OUTPUT ITERATORS umoznuju iba zapis VALUES do COLLECTIONS.
   B. OUTPUT ITERATORS umoznuju iba DOPREDNY POSUN po ITEMS v COLLECTIONS.
   !!! C. OUTPUT ITERATORS NEGARANTUJU, ze opakovany pokus o zapis vykona zapis do toho isteho ITEM. OUTPUT ITERATORS mozu po zapise do ITEM automaticky inkrementovat svoju poziciu. Typickym prikladom su OSTREAMS (napriklad CLASS [wcout]), ktore po pridani ITEM do OUTPUT zaroven inkrementuju svoju poziciu.
   D. OUTPUT ITERATORS nedefinuju COMPARISION OPERATORS, takze nie je mozne skontrolovat ci je COLLECTION plna.
   E. OUTPUT ITERATORS neumoznuju skontrolovat ci bol zapis do COLLECTION uspesny, alebo nie.
59. OUTPUT ITERATORS definuju nasledujuce OPERATIONS.
   A. COPY CONSTRUCTOR vytvara kopiu ITERATOR.
   B. OPERATOR* moze byt pouzity iba na LEFT-SIDE danej EXPRESSION na zapis VALUE jednotlivych ITEMS do COLLECTION.
   C. OPERATOR= priradzuje do ITEM NOVU VALUE.
   D. ++OPERATOR inkrementuje ITERATOR POSITION.
   E. OPERATOR++ inkrementuje ITERATOR POSITION.
60. Pre INPUT ITERATORS platia nasledujuce fakty.
   A. INPUT ITERATORS umoznuju iba citanie VALUES do COLLECTIONS.
   B. INPUT ITERATORS umoznuju iba DOPREDNY POSUN po ITEMS v COLLECTIONS.
   !!! C. INPUT ITERATORS NEGARANTUJU, ze ak 2 INPUT ITERATORS referuju na ROZNE ITEMS a zaroven nie su PAST-END ITERATORS, musi ich porovnanie skoncit NEROVNOSTOU.
   D. INPUT ITERATORS definuju COMPARISION OPERATORS.
   E. PAST-END ITERATOR referuje na 1 POSITION za KONCOM COLLECTION. Tento ITERATOR NIE JE MOZNE DEREFERENCOVAT a sluzi iba na porovnanie, ze iterovanie dosiahlo koniec COLLECTION.
61. INPUT ITERATORS definuju nasledujuce OPERATIONS.
   A. COPY CONSTRUCTOR vytvara kopiu ITERATOR.
   B. OPERATOR* moze byt pouzity iba na RIGHT-SIDE danej EXPRESSION na citanie VALUES jednotlivych ITEMS z COLLECTION.
   C. OPERATOR-> umoznuje pristup k MEMBERS daneho OBJECT a moze byt pouzity iba na RIGHT-SIDE danej EXPRESSION na citanie VALUE jednotlivych ITEMS z COLLECTION.
   D. ++OPERATOR inkrementuje ITERATOR POSITION.
   E. OPERATOR++ inkrementuje ITERATOR POSITION. C++ STANDARD nevyzaduje, aby ITERATOR musel vracat nejaku RETURN VALUE.
   F. OPERATOR== porovnava ci 2 ITERATORS su rovne.
   G. OPERATOR=! porovnava ci 2 ITERATORS su rozne.
62. Pre FORWARD ITERATORS platia nasledujuce fakty.
   A. FORWARD ITERATORS umoznuju iba citanie VALUES do COLLECTIONS.
   B. FORWARD ITERATORS, ktore umoznuju aj zapis VALUES do COLLECTIONS sa nazyvaju MUTABLE FORWARD ITERATORS.
   C. FORWARD ITERATORS umoznuju iba DOPREDNY POSUN po ITEMS v COLLECTIONS.
   !!! D. FORWARD ITERATORS GARANTUJU, ze ak 2 FORWARD ITERATORS referuju na ROVNAKE ITEMS, musi ich porovnanie skoncit ROVNOSTOU a ak referuju na ROZNE ITEMS, musi ich porovnanie skoncit NEROVNOSTOU.
   E. FORWARD ITERATORS definuju COMPARISION OPERATORS.
   F. PAST-END ITERATOR referuje na 1 POSITION za KONCOM COLLECTION. Tento ITERATOR NIE JE MOZNE DEREFERENCOVAT a sluzi iba na porovnanie, ze iterovanie dosiahlo koniec COLLECTION.
63. FORWARD ITERATORS definuju nasledujuce OPERATIONS.
   A. DEFAULT CONSTRUCTOR vytvara instanciu ITERATOR.
   B. COPY CONSTRUCTOR vytvara kopiu ITERATOR.
   C. OPERATOR* moze byt pouzity iba na RIGHT-SIDE danej EXPRESSION na citanie VALUES jednotlivych ITEMS z COLLECTION. Zapis VALUES do ITEMS je mozne iba ak je FORWARD ITERATOR MUTABLE.
   D. OPERATOR-> umoznuje pristup k MEMBERS daneho OBJECT a moze byt pouzity iba na RIGHT-SIDE danej EXPRESSION na citanie VALUE jednotlivych ITEMS z COLLECTION. Zapis VALUES do ITEMS je mozne iba ak je FORWARD ITERATOR MUTABLE.
   E. OPERATOR= priradzuje jednu instanciu ITERATOR do druhej.
   F. ++OPERATOR inkrementuje ITERATOR POSITION.
   G. OPERATOR++ inkrementuje ITERATOR POSITION.
   H. OPERATOR== porovnava ci 2 ITERATORS su rovne.
   I. OPERATOR=! porovnava ci 2 ITERATORS su rozne.
64. Pre BIDIRECTIONAL ITERATORS platia nasledujuce fakty.
   A. BIDIRECTIONAL ITERATORS umoznuju iba citanie VALUES do COLLECTIONS.
   B. BIDIRECTIONAL ITERATORS, ktore umoznuju aj zapis VALUES do COLLECTIONS sa nazyvaju MUTABLE BIDIRECTIONAL ITERATORS.
   C. BIDIRECTIONAL ITERATORS umoznuju OBOJSMERNY POSUN po ITEMS v COLLECTIONS.
   !!! D. BIDIRECTIONAL ITERATORS GARANTUJU, ze ak 2 BIDIRECTIONAL ITERATORS referuju na ROVNAKE ITEMS, musi ich porovnanie skoncit ROVNOSTOU a ak referuju na ROZNE ITEMS, musi ich porovnanie skoncit NEROVNOSTOU.
   E. BIDIRECTIONAL ITERATORS definuju COMPARISION OPERATORS.
   F. PAST-END ITERATOR referuje na 1 POSITION za KONCOM COLLECTION. Tento ITERATOR NIE JE MOZNE DEREFERENCOVAT a sluzi iba na porovnanie, ze iterovanie dosiahlo koniec COLLECTION.
65. BIDIRECTIONAL ITERATORS definuju nasledujuce OPERATIONS.
   A. DEFAULT CONSTRUCTOR vytvara instanciu ITERATOR.
   B. COPY CONSTRUCTOR vytvara kopiu ITERATOR.
   C. OPERATOR* moze byt pouzity iba na RIGHT-SIDE danej EXPRESSION na citanie VALUES jednotlivych ITEMS z COLLECTION. Zapis VALUES do ITEMS je mozne iba ak je BIDIRECTIONAL ITERATOR MUTABLE.
   D. OPERATOR-> umoznuje pristup k MEMBERS daneho OBJECT a moze byt pouzity iba na RIGHT-SIDE danej EXPRESSION na citanie VALUE jednotlivych ITEMS z COLLECTION. Zapis VALUES do ITEMS je mozne iba ak je BIDIRECTIONAL ITERATOR MUTABLE.
   E. OPERATOR= priradzuje jednu instanciu ITERATOR do druhej.
   F. ++OPERATOR inkrementuje ITERATOR POSITION.
   G. OPERATOR++ inkrementuje ITERATOR POSITION.
   H. --OPERATOR dekrementuje ITERATOR POSITION.
   I. OPERATOR-- dekrementuje ITERATOR POSITION.
   J. OPERATOR== porovnava ci 2 ITERATORS su rovne.
   K. OPERATOR=! porovnava ci 2 ITERATORS su rozne.
66. Pre RANDOM-ACCESS ITERATORS platia nasledujuce fakty.
   A. RANDOM-ACCESS ITERATORS umoznuju iba citanie VALUES do COLLECTIONS.
   B. RANDOM-ACCESS ITERATORS, ktore umoznuju aj zapis VALUES do COLLECTIONS sa nazyvaju MUTABLE RANDOM-ACCESS ITERATORS.
   C. RANDOM-ACCESS ITERATORS umoznuju okamzity pristup k lubovolnemu ITEM v COLLECTIONS.
   !!! D. RANDOM-ACCESS ITERATORS GARANTUJU, ze ak 2 RANDOM-ACCESS ITERATORS referuju na ROVNAKE ITEMS, musi ich porovnanie skoncit ROVNOSTOU a ak referuju na ROZNE ITEMS, musi ich porovnanie skoncit NEROVNOSTOU.
   E. RANDOM-ACCESS ITERATORS definuju COMPARISION OPERATORS, vratane OPERATOR<, OPERATOR<=, OPERATOR> a OPERATOR>=.
   F. PAST-END ITERATOR referuje na 1 POSITION za KONCOM COLLECTION. Tento ITERATOR NIE JE MOZNE DEREFERENCOVAT a sluzi iba na porovnanie, ze iterovanie dosiahlo koniec COLLECTION.
67. RANDOM-ACCESS ITERATORS definuju nasledujuce OPERATIONS.
   A. DEFAULT CONSTRUCTOR vytvara instanciu ITERATOR.
   B. COPY CONSTRUCTOR vytvara kopiu ITERATOR.
   C. OPERATOR* moze byt pouzity iba na RIGHT-SIDE danej EXPRESSION na citanie VALUES jednotlivych ITEMS z COLLECTION. Zapis VALUES do ITEMS je mozne iba ak je RANDOM-ACCESS ITERATOR MUTABLE.
   D. OPERATOR-> umoznuje pristup k MEMBERS daneho OBJECT a moze byt pouzity iba na RIGHT-SIDE danej EXPRESSION na citanie VALUE jednotlivych ITEMS z COLLECTION. Zapis VALUES do ITEMS je mozne iba ak je RANDOM-ACCESS ITERATOR MUTABLE.
   E. OPERATOR[] umoznuje citat VALUE lubovolneho ITEM v COLLECTION. Zapis VALUES do ITEMS je mozne iba ak je RANDOM-ACCESS ITERATOR MUTABLE.
   F. OPERATOR= priradzuje jednu instanciu ITERATOR do druhej.
   G. OPERATOR+= posuva ITERATOR POSITION o 'N' POSITIONS DOPREDU.
   H. OPERATOR-= posuva ITERATOR POSITION o 'N' POSITIONS DOZADU.
   I. OPERATOR+(ITERATOR,INTEGER) vracia ITERATOR posunuty o 'N' POSITIONS DOPREDU.
   J. OPERATOR+(INTEGER,ITERATOR) vracia ITERATOR posunuty o 'N' POSITIONS DOPREDU.
   L. OPERATOR-(ITERATOR,INTEGER) vracia ITERATOR posunuty o 'N' POSITIONS DOZADU.
   M. OPERATOR-(ITERATOR,ITERATOR) vracia vzdialenost medzi 2 ITEREATORS.
   N. ++OPERATOR inkrementuje ITERATOR POSITION.
   O. OPERATOR++ inkrementuje ITERATOR POSITION.
   P. --OPERATOR dekrementuje ITERATOR POSITION.
   Q. OPERATOR-- dekrementuje ITERATOR POSITION.
   R. OPERATOR== porovnava ci 2 ITERATORS su rovne.
   S. OPERATOR=! porovnava ci 2 ITERATORS su rozne.
   T. OPERATOR< vracia informaciu ci je prvy ITERATOR MENSI ako druhy ITERATOR.
   U. OPERATOR<= vracia informaciu ci je prvy ITERATOR MENSI, alebo ROVNY ako druhy ITERATOR.
   V. OPERATOR> vracia informaciu ci je prvy ITERATOR VACSI ako druhy ITERATOR.
   W. OPERATOR>= vracia informaciu ci je prvy ITERATOR VACSI, alebo ROVNY ako druhy ITERATOR.
!!!!! 68. Ak su ITERATORS implementovane ako POINTERS NEVYHODOU je, ze taketo ITERATORS ak su vytvorene ako TEMPORARY VALUES NIE JE mozne MODIFIKOVAT. To znamena, ze na taketo ITERATORS NIE JE mozne pouzit napriklad ani OPERATOR++. Riesenim je nepouzit TEMPORARY VALUES, ale vytvorit ITERATORS ako VARIABLES a pouzit tie. Alternativou je nahradit OPERATOR++ za FUNCTION std::next().
69. STREAM ITERATORS su ITERATORS ADAPTERS, ktore iteruju nad STREAMS. C++ STANDARD LIBRARY podporuje nasledujuce typy STREAM ITERATORS.
   A. INPUT STREAM ITERATORS pracuju nad INPUT STREAMS a pri iterovani citaju data z INPUT STREAMS.
   B. OUTPUT STREAM ITERATORS pracuju nad OUTPUT STREAMS a pri iterovani zapisuju data do OUTPUT STREAMS.
   C. STREAM BUFFER ITERATORS pracuju nad STREAM BUFFERS a pri iterovani citaju a zapisuju data do STREAM BUFFERS.
70. Pre OUTPUT STREAM ITERATORS platia nasledujuce fakty.
   A. Pri iterovani cez ITEMS su data namiesto do COLLECTIONS zapisovane do OUTPUT STREAMS.
   B. OUTPUT STREAM ITERATORS su implementovane ako instancie CLASS [ostream_iterator<TType,TChar,TTraits>]. TEMPLATE PARAMETER 'TType' CLASS [ostream_iterator<TType,TChar,TTraits>] urcuje TYPE dat, ktore sa do OUTPUT STREAM budu zapisovat.
   C. OUTPUT STREAM do ktoreho ma OUTPUT STREAM ITERATOR zapisovat je zadany v CONSTRUCTOR OUTPUT STREAM ITERATOR.
   !!! D. Klucovou operaciou OUTPUT STREAM ITERATORS je OPERATOR=, ktory vykonava zapis do OUTPUT STREAM volanim OPERATOR<< daneho STREAM.
71. CLASS [ostream_iterator<TType,TChar,TTraits>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara novu instanciu OUTPUT STREAM ITERATOR. Ako PARAMETER sa zadava OUTPUT STREAM nad ktorym ma OUTPUT STREAM ITERATOR pracovat. OVERLOADED VERSION obsahuje aj 2. PARAMETER definujuci STRING, ktory sa pouzije ako SEPARATOR oddelujucimi ITEMS pri zapise do OUTPUT STREAM.
   B. DESTRUCTOR uvolnuje vsetky RESOURCES asociovane s OUTPUT STREAM ITERATOR.
   C. TYPE [char_type] urcuje CHARACTER TYPE, ktory sa definuje ake typy CHARACTERS sa pouziju pri zapise ITEMS do OUTPUT STREAMS.
   D. TYPE [traits_type] urcuje TYPE TRAITS, ktore OUTPUT STREAM ITERATOR pouziva.
   E. TYPE [ostream_type] urcuje TYPE OUTPUT STREAM, ktory OUTPUT STREAM ITERATOR pouziva.
   F. TYPE [value_type] obsahuje TYPE [void].
   G. TYPE [difference_type] obsahuje TYPE [void].
   H. TYPE [pointer] obsahuje TYPE [void].
   I. TYPE [reference] obsahuje TYPE [void].
   J. TYPE [iterator_category] urcuje TYPE ITERATOR CATEGORY daneho ITERATOR.
   !!!!! K. OPERATOR= vklada NOVY ITEM do OUTPUT STREAM volanim jej OPERATOR<< a pripade aj volanim OPERATOR<< na pridanie SEPARATOR, ak bol definovany.
   L. OPERATOR* je EMPTY OPERATION.
   M. OPERATOR++ je EMPTY OPERATION.
   N. ++OPERATOR je EMPTY OPERATION.
72. Pre INPUT STREAM ITERATORS platia nasledujuce fakty.
   A. Pri iterovani cez ITEMS su data namiesto z COLLECTIONS citane z INPUT STREAMS.
   B. INPUT STREAM ITERATORS su implementovane ako instancie CLASS [istream_iterator<TType,TChar,TTraits,TDistance>]. TEMPLATE PARAMETER 'TType' CLASS [istream_iterator<TType,TChar,TTraits,TDistance>] urcuje TYPE dat, ktore sa z INPUT STREAM budu citat.
   C. INPUT STREAM z ktoreho ma INPUT STREAM ITERATOR citat je zadany v CONSTRUCTOR INPUT STREAM ITERATOR.
   !!! D. Klucovou operaciou INPUT STREAM ITERATORS je OPERATOR*, ktory vykonava citanie z INPUT STREAM volanim OPERATOR>> daneho STREAM.
   !!!!! E. Na indikaciu konca INPUT STREAM, alebo chyby pri citani INPUT STREAM sa pouziva EMPTY INPUT STREAM ITERATOR, ktory sa vytvara pomocou DEFAULT CONSTRUCTOR. Po KAZDOM citanie dat zo STREAM je NUTNE pomocou OPERATOR==, alebo OPERATOR!= zistit ci INPUT STREAM ITERATOR nie je identicky s EMPTY INPUT STREAM ITERATOR. Ak ano, potom to znamena, ze bud pri citanie doslo k ERROR, alebo sa dosiahol koniec INPUT STREAM.
   !!! F. OPERATOR== a OPERATOR!= urcuju ci su dve INPUT STREAM ITERATORS rovne. Rovne su vtedy ked z OBOCH INPUT STREAM ITERATORS je mozne citat data, alebo ak z OBOCH  INPUT STREAM ITERATORS data citat nie je mozne, pre ERROR, alebo dosiahnutie konca INPUT STREAM.
73. CLASS [istream_iterator<TType,TChar,TTraits,TDistance>] ma nasledujuce MEMBERS.
   A. DEFAULT CONSTRUCTOR vytvara EMPTY INPUT STREAM ITERATOR, ktory sluzi ako indikator vzniku ERROR, alebo dosiahnutia konca INPUT STREAM.
   B. CONSTRUCTOR vytvara novu instanciu INPUT STREAM ITERATOR. Ako PARAMETER sa zadava INPUT STREAM nad ktorym ma INPUT STREAM ITERATOR pracovat.
   C. DESTRUCTOR uvolnuje vsetky RESOURCES asociovane s INPUT STREAM ITERATOR.
   D. TYPE [char_type] urcuje CHARACTER TYPE, ktory sa definuje ake typy CHARACTERS sa pouziju pri citani ITEMS z INPUT STREAMS.
   E. TYPE [traits_type] urcuje TYPE TRAITS, ktore INPUT STREAM ITERATOR pouziva.
   F. TYPE [istream_type] urcuje TYPE INPUT STREAM, ktory INPUT STREAM ITERATOR pouziva.
   G. TYPE [value_type] urcuje TYPE, ktory sa cita z INPUT STREM. Je rovny s TEMPLATE PARAMETER 'TType'.
   H. TYPE [difference_type] urcuje TYPE, ktory sa pouziva na vyjadrenie vzdialenosti medzi 2 POSITIONS INPUT STREAM ITERATOR. Je rovny s TEMPLATE PARAMETER 'TDistance'.
   I. TYPE [pointer] obsahuje CONST POINTER na TYPE, ktory sa cita z INPUT STREAM. Obsahuje TYPE [const TType*].
   J. TYPE [reference] obsahuje CONST REFERENCE na TYPE, ktory sa cita z INPUT STREAM. Obsahuje TYPE [const TType&].
   K. TYPE [iterator_category] urcuje TYPE ITERATOR CATEGORY daneho ITERATOR.
   !!!!! L. OPERATOR* vracia CONST REFERENCE na ITEM nacitany z INPUT STREAM. OPERATOR* v pripade, ze nacitany ITEM je uz ulozeny v INTERNAL VARIABLE vracia tento, a ak nie je, pouziva na citanie OPERATOR>>, ktory vola nad INPUT STREAM.
   !!!!! M. OPERATOR-> vracia CONST POINTER na MEMBER ITEM nacitaneho z INPUT STREAM. OPERATOR-> v pripade, ze nacitany ITEM je uz ulozeny v INTERNAL VARIABLE vracia tento, a ak nie je, pouziva na citanie OPERATOR>>, ktory vola nad INPUT STREAM.
   !!! N. OPERATOR++ cita ITEM z INPUT STREAM volanim OPERATOR>> a uklada ho do svojej internej premennej.
   O. ++OPERATOR cita ITEM z INPUT STREAM volanim OPERATOR>> a uklada ho do svojej internej premennej.
   P. OPERATOR== vracia informaciu ci 2 INPUT STREAM ITERATORS su rovne. INPUT STREAM ITERATORS su rovne ak z oboch je mozne citat ITEMS, alebo obe su rovne EMPTY INPUT STREAM ITERATOR.
   Q. OPERATOR!= vracia informaciu ci 2 INPUT STREAM ITERATORS su rozne. INPUT STREAM ITERATORS su rozne ak z jedneho INPUT STREAM ITERATOR je mozne citat ITEMS, zatial co druhy je EMPTY INPUT STREAM ITERATOR.
!!!!! 74. PREDICATES su FUNCTION OBJECTS, ktore ako RETURN VALUE vracaju hodnotu BOOL. PREDICATES NIKDY NESMU mat INTERNY STATE. Je to preto, lebo ALGORITHMS, kde sa najcastejsie pouzivaju NEGARANTUJU, ze si nevytvaraju kopie FUNCTION OBJECTS. Ak si ich vytvoria, potom si kopie vytvaraju vlastne kopie ich STATES a ALGORITHM tak NEMUSI FUNGOVAT SPRAVNE.
//-----------------------------------------------------------------------------