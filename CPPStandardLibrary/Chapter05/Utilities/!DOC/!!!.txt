//-------------------------------------------------------------------------------------------------------
1. Solution demonstruje pouzitie niektorych podpornych CLASSES z C++ STANDARD LIBRARY.
2. STRUCTURE [pair<T1,T2>] reprezentuje PAIR. Ma nasledujuce MEMBERS.
   A. FIELD [first] obsahuje 1. VALUE.
   B. FIELD [second] obsahuje 2. VALUE.
   C. FIELD [first_type] obsahuje TYPE 1. VALUE.
   D. FIELD [second_type] obsahuje TYPE 2. VALUE.
   E. CONSTRUCTOR umoznuje aj standardne CONVERSIONS.
   F. OPERATOR= umoznuje priradenie jedneho PAIR do druheho. Ma aj MOVE SEMANTICS a umoznuje standardne CONVERSIONS.
   G. OPERATOR== porovnava ci su 2 PAIRS rovne.
   H. OPERATOR!= porovnava ci su 2 PAIRS rozne.
   I. OPERATOR< porovnava ci su 1. PAIR je mensi ako 2. PAIR. Porovnavaju sa FIELDS [first] a ak su rovnake, tak aj FIELDS [second].
   J. OPERATOR<= porovnava ci su 1. PAIR je mensi, alebo rovny ako 2. PAIR. Porovnavaju sa FIELDS [first] a ak su rovnake, tak aj FIELDS [second].
   K. OPERATOR> porovnava ci su 1. PAIR je vacsi ako 2. PAIR. Porovnavaju sa FIELDS [first] a ak su rovnake, tak aj FIELDS [second].
   L. OPERATOR>= porovnava ci su 1. PAIR je vacsi, alebo rovny ako 2. PAIR. Porovnavaju sa FIELDS [first] a ak su rovnake, tak aj FIELDS [second].
   M. METHOD swap() vymiena hodnoty oboch FIELDS medzi 2 PAIRS.
3. FUNCTION get<INDEX>() pre PAIR vracia hodnotu FIELD s indexom 'INDEX'.
4. CLASS [tuple_size<pair<T1,T2>>] vracia pocet ITEMS v PAIR, ktory je vzdy rovny hodnode 2.
5. CLASS [tuple_element<INDEX,pair<T1,T2>>] vracia TYPE FIELD s indexom 'INDEX'.
!!! 6. STRUCTURE [pair<T1,T2>] ma specialny CONSTRUCTOR, ktory ako 1. PARAMETER prijima TYPE [piecewise_construct] a ako dalsie 2 PARAMETERS prijima dvojicu CLASS [tuple<T...>]. CONSTRUCTOR pre OBE TUPLES ROZBALI ich na FIELDS a pre tieto vola VARIADIC CONSTRUCTORS pre TYPE PARAMETER 'T1' a TYPE PARAMETER 'T2'.
7. FUNCTION make_pair() umoznuje vytvorit PAIR bez toho aby sa EXPLICITNE definovali jeho TYPES. TYPES ci COMPILER odvodi z PARAMETERS FUNCTION make_pair().
!!! 8. FUNCTION make_pair() spolu s FUNCTIONS ref() ci cref() umoznuju urcit ci COMPILER ma pre TYPE PARAMETER daneho PAIR generovat REFERENCES na VALUES namiesto VALUES.
!!!!! 9. STRUCTURE [pair<T1,T2>] moze v TYPE PARAMETERS 'T1' a 'T2' obsahovat aj REFERENCES.
10. VARIADIC TEMPLATE CLASS [tuple<T...>] reprezentuje TUPLE. Ma nasledujuce MEMBERS.
   A. CONSTRUCTOR umoznuje aj standardne CONVERSIONS. CLASS ma aj EXPLICIT CONSTRUCTOR, ktory moze preberat lubovolny pocet VALUES. Tento CONSTRUCTOR je mozne vyuzit pri vytvarani TUPLES cez INITIALIZER LISTS.
   B. OPERATOR= umoznuje priradenie jedneho TUPLE do druheho. Ma aj MOVE SEMANTICS a umoznuje standardne CONVERSIONS.
   C. OPERATOR== porovnava ci su 2 TUPLES rovne.
   D. OPERATOR!= porovnava ci su 2 TUPLES rozne.
   E. OPERATOR< porovnava ci su 1. TUPLE je mensi ako 2. TUPLE. FIELDS sa porovnavaju v poradi zlava doprava.
   F. OPERATOR<= porovnava ci su 1. TUPLE je mensi, alebo rovny ako 2. TUPLE. FIELDS sa porovnavaju v poradi zlava doprava.
   G. OPERATOR> porovnava ci su 1. TUPLE je vacsi ako 2. TUPLE. FIELDS sa porovnavaju v poradi zlava doprava.
   H. OPERATOR>= porovnava ci su 1. TUPLE je vacsi, alebo rovny ako 2. TUPLE. FIELDS sa porovnavaju v poradi zlava doprava.
   I. METHOD swap() vymiena hodnoty vsetkych FIELDS medzi 2 TUPLES.
11. FUNCTION get<INDEX>() pre TUPLE vracia hodnotu FIELD s indexom 'INDEX'.
12. CLASS [tuple_size<tuple<T...>>] vracia pocet ITEMS v TUPLE.
13. CLASS [tuple_element<INDEX,tuple<T...>>] vracia TYPE FIELD s indexom 'INDEX'.
14. FUNCTION make_tuple() umoznuje vytvorit TUPLE bez toho aby sa EXPLICITNE definovali jeho TYPES. TYPES ci COMPILER odvodi z PARAMETERS FUNCTION make_tuple().
!!! 15. FUNCTION make_tuple() spolu s FUNCTIONS ref() ci cref() umoznuju urcit ci COMPILER ma pre TYPE PARAMETERS daneho TUPLE generovat REFERENCES na VALUES namiesto VALUES.
!!!!! 16. CLASS [tuple<T...>] moze v TYPE PARAMETERS mat aj REFERENCES.
!!! 17. FUNCTION tie() vytvara instanciu CLASS [tuple<T...>], kde zo VSETKYCH TYPE PARAMETERS spravi REFERENCES. Vdaka tomu je mozne modifikovat povodne hodnoty na ktore sa TUPLE FIELDS referuju.
18. FUNCTION tuple_cat() vytvara instanciu TUPLE z VIACERYCH TUPLES, ktore su zadane ako PARAMETERS, pricom vytvoreny TUPLE ma vsetky FIELDS zo vsetkych TUPLES zadanych ako PARAMETERS.
19. Instanciu CLASS [pair<T1,T2>] je mozne priradit do instancie CLASS [tuple<T...>], ktora ma 2 FIELDS.
20. C++ podporuje 2 typy SMART POINTERS.
   A. SHARED SMART POINTERS realizuju funkcionalitu REFERENCE COUNTING a umoznuju, aby POINTER, ktory obsahuju bol pouzity viackrat v rozlicnych CONTEXTS. OBJECT, ktory SHARED SMART POINTER obsahuje je ODSTRANENY z MEMORY, ak je POSLEDNA INSTANCIA SHARED SMART POINTER uvolnena. SHARED SMART POINTER je reprezentovany CLASS [shared_ptr<T>].
   B. UNIQUE SMART POINTERS obaluju POINTER, ktory sa pouziva iba v 1 CONTEXT. Po uvolneni instancie UNIQUE SMART POINTER je uvolneny aj OBJECT na ktory sa UNIQUE SMART POINTER referuje. UNIQUE SMART POINTER je reprezentovany CLASS [unique_ptr<T>].
!!! 21. CLASS [auto_ptr<T>] je v C++ 11 DEPRECATED a teda by sa NEMALA POUZIVAT.
22. Pre SHARED SMART POINTERS platia nasledujuce fakty.
   A. SHARED SMART POINTER je reprezentovany CLASS [shared_ptr<T>].
   !!!!! B. CLASS [shared_ptr<T>] NEVLASTNI exkluzivne dany OBJECT, ale umoznuje, aby OBJECT na ktory POINTER referuje bol SHARED medzi VIACERYMI INSTANCIAMI CLASS [shared_ptr<T>] a bol odstraneny, az ked sa uvolni z MEMORY POSLEDNA INSTANCIA CLASS [shared_ptr<T>], ktora referuje na dany OBJECT.
   !!! C. CLASS [shared_ptr<T>] teda reprezentuje semantiku REFERENCE COUNTING ako COM OBJECTS, pricom ak COUNTER klesne na 0, tak je OBJECT na ktory instancie CLASS [shared_ptr<T>] referovali uvolneny z MEMORY.
   D. CLASS [shared_ptr<T>] umoznuje definovat CUSTOM DELETE FUNCTION, ktora sa zavola pri uvolnovani OBJECT na ktory instancie CLASS [shared_ptr<T>] referovali z MEMORY.
   !!! E. Standardne CLASS [shared_ptr<T>] predpoklada, ze OBJECT bol alokovany pomocou OPERATOR NEW a bez definovania CUSTOM DELETE FUNCTION sa pre OBJECT vola OPERATOR DELETE.
   !!!!! F. Ak CLASS [shared_ptr<T>] obsahuje ARRAY alokovany pomocou OPERATOR NEW[], tak je NEVYHNUTNE definovat CUSTOM DELETE FUNCTION, ktora namiesto standardneho OPERATOR DELETE pouzije OPERATOR DELETE[].
23. CLASS [shared_ptr<T>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [shared_ptr<T>], inkrementuje REFERENCE COUNTER a priradzuje do nej POINTER na OBJECT. CONSTRUCTOR umoznuje zadat aj CUSTOM DELETE FUNCTION, ktora sa bude volat NAMIESTO OPERATOR DELETE, ked REFERENCE COUNTER klesne na hondotu 0.
   B. DESTRUCTOR dekrementuje REFERENCE COUNTER a uvolnuje instanciu CLASS [shared_ptr<T>]. Ak hodnota REFERENCE COUNTER klesne na 0, tak DESTRUCTOR vola bud standardny OPERATOR DELETE, alebo ak je zadefinovana na CUSTOM DELETE FUNCTION, ktora ma za ulohu odstranit OBJECT z MEMORY.
   C. OPERATOR= umoznuje priradit instanciu jednej CLASS [shared_ptr<T>] do inej. OPERATOR= NEUMOZNUJE priradit PRIAMO POINTER na OBJECT do instancie CLASS [shared_ptr<T>]. Na to je potrebne pouzit METHOD shared_ptr<T>.reset().
   D. OPERATOR* vykonava POINTER DEREFERENCING. Chova sa ako OPERATOR* pre STANDARDNE POINTERS.
   E. OPERATOR-> vykonava POINTER DEREFERENCING. Chova sa ako OPERATOR-> pre STANDARDNE POINTERS.
   E. OPERATOR== porovnava ci 2 instancie CLASS [shared_ptr<T>] referuju na ten isty OBJECT.
   F. OPERATOR!= porovnava ci 2 instancie CLASS [shared_ptr<T>] referuju na ten rozny OBJECT.
   G. OPERATOR< porovnava ci 1. instancia CLASS [shared_ptr<T>] je MENSIA ako druha instancia CLASS [shared_ptr<T>].
   H. OPERATOR<= porovnava ci 1. instancia CLASS [shared_ptr<T>] je MENSIA, alebo ROVNA ako druha instancia CLASS [shared_ptr<T>].
   I. OPERATOR> porovnava ci 1. instancia CLASS [shared_ptr<T>] je VACSIA ako druha instancia CLASS [shared_ptr<T>].
   J. OPERATOR>= porovnava ci 1. instancia CLASS [shared_ptr<T>] je VACSIA, alebo ROVNA ako druha instancia CLASS [shared_ptr<T>].
   K. OPERATOR<< zapise hodnotu POINTER do OUTPUT STREAM.
   L. OPERATOR BOOL vracia hodnotu TRUE, ak instancia CLASS [shared_ptr<T>] referuje na OBJECT, alebo FALSE, ak instancia CLASS [shared_ptr<T>] nereferuje na ziadny OBJECT.
   M. METHOD shared_ptr<T>.reset() umoznuje zrusit referovanie instancie CLASS [shared_ptr<T>] na OBJECT.
   N. METHOD shared_ptr<T>.swap() umoznuje vzajomne si vymenit POINTERS na OBJECTS na ktore referuju 2 instancie CLASS [shared_ptr<T>].
   !!! O. METHOD shared_ptr<T>.get() vracia POINTER OBJECT, ktory obsahuje instancia CLASS [shared_ptr<T>].
   !!! P. METHOD shared_ptr<T>.use_count() vracia aktualnu hodnotu REFERENCE COUNTER.
   Q. METHOD shared_ptr<T>.unique() vracia TRUE, ak REFERENCE COUNTER obsahuje hodnotu 1, inak vracia FALSE.
   R. METHOD shared_ptr<T>.owner_before() vracia informacia ci jedna instancia CLASS [shared_ptr<T>] sa nachadza pred inou v IMPLEMENTATION DEFINED ORDER.
24. FUNCTION get_deleter() vracia CUSTOM DELETE FUNCTION, ktora bola priradena danej instancii CLASS [shared_ptr<T>].
!!! 25. FUNCTION make_shared() vytvara instanciu CLASS [shared_ptr<T>]. FUNCTION je EFEKTIVNEJSIM sposobom vytvarania SHARED SMART POINTERS, pretoze ALOKACIA MEMORY sa vykonava IBA RAZ, kde MEMORY alokovana na HEAP obsahuje okrem samotnej instancie OBJECT aj REFERENCE COUNTER, ktory pocitat pocet instancii CLASS [shared_ptr<T>].
26. FUNCTION allocate_shared() je analogiou FUNCTION make_shared(), ktora vsak ako 1. PARAMETER prijima ALLOCATOR OBJECT.
27. C++ obsahuje nasledujuce konverzne TEMPLATE FUNCTIONS, ktore umoznuju aplikovat konverzne OPERATORS na instancie CLASS [shared_ptr<T>].
   A. FUNCTION dynamic_pointer_cast<T1,T2>() aplikuje OPERATOR [dynamic_cast<T>()] na instanciu CLASS [shared_ptr<T2>], pricom vracia instanciu CLASS [shared_ptr<T1>].
   B. FUNCTION static_pointer_cast<T1,T2>() aplikuje OPERATOR [static_cast<T>()] na instanciu CLASS [shared_ptr<T2>], pricom vracia instanciu CLASS [shared_ptr<T1>].
   C. FUNCTION const_pointer_cast<T1,T2>() aplikuje OPERATOR [const_cast<T>()] na instanciu CLASS [shared_ptr<T2>], pricom vracia instanciu CLASS [shared_ptr<T1>].
!!!!! 28. Pri alokacii ARRAYS pomocou CLASS [shared_ptr<T>] je NEVYHNUTNE definovat CUSTOM DELETE FUNCTION v ktorej je NUTNE zavolat OPERATOR DELETE[].
!!! 29. CLASS [shared_ptr<T>] NIE JE mozne pouzit, ak TYPE PARAMETER 'T' je ARRAY. Pre takyto CODE hodi COMPILER ERROR.
!!!!! 30. CUSTOM DELETE FUNCTION NESMIE hodit EXCEPTION, inak je chovanie CLASS [shared_ptr<T>] UNDEFINED.
!!!!! 31. Nevyhodou CLASS [shared_ptr<T>] je v tom, ze v pripade CYCLIC REFERENCES NEDOJDE k uvolnenie OBJECTS, pretoze 2 instancie CLASS [shared_ptr<T>] si vzajomne budu drzat COUNTER na hodnote 1 a tym padom ich DESTRUCTOR NEUVOLNI. Riesenim je pouzitie CLASS [weak_ptr<T>].
32. CLASS [weak_ptr<T>] reprezentuje SMART POINTER, ktory je previazany s CLASS [shared_ptr<T>]. Ma nasledujuce vlastnosti.
   A. Instancia CLASS [weak_ptr<T>] NEVLASTNI OBJECT na ktory referuje. To znaci, ze DESTRUCTOR NIKDY NEUVOLNUJE referovany OBJECT.
   B. Instanciu CLASS [weak_ptr<T>] je mozne vytvorit IBA z instancie CLASS [shared_ptr<T>].
   !!!!! C. CLASS [weak_ptr<T>] NEMA pretazeny OPERATOR* a OPERATOR->. Preto ak sa ma OBJECT na ktory instancia CLASS [weak_ptr<T>] zapuzdruje pouzit je NUTNE vykonat jeho konverziu na instanciu CLASS [shared_ptr<T>] bud jej explicitnym vytvorenim, alebo volanim METHOD weak_ptr<T>.lock(), ktora vracia instanciu CLASS [shared_ptr<T>]. METHOD weak_ptr<T>.lock() vrati PRAZDNU instanciu CLASS [shared_ptr<T>], ak OBJECT uz bol uvolneny. CONSTRUCTOR CLASS [shared_ptr<T>] vrati EXCEPTION [bad_weak_ptr], ak OBJECT uz bol uvolneny.
33. CLASS [weak_ptr<T>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [weak_ptr<T>] z instancie CLASS [weak_ptr<T>].
   B. DESTRUCTOR uvolnuje instanciu CLASS [weak_ptr<T>], pricom vsak NIKDY NEUVOLNUJE referovany OBJECT.
   C. OPERATOR= umoznuje priradit instanciu jednej CLASS [weak_ptr<T>] do inej. OPERATOR= UMOZNUJE priradit aj instanciu CLASS [shared_ptr<T>] do instancie CLASS [weak_ptr<T>].
   D. METHOD weak_ptr<T>.reset() umoznuje zrusit referovanie instancie CLASS [weak_ptr<T>] na OBJECT.
   E. METHOD weak_ptr<T>.swap() umoznuje vzajomne si vymenit POINTERS na OBJECTS na ktore referuju 2 instancie CLASS [weak_ptr<T>].
   !!! F. METHOD weak_ptr<T>.use_count() vracia aktualnu hodnotu REFERENCE COUNTER instancie CLASS [shared_ptr<T>] z ktorej bola instancia CLASS [weak_ptr<T>] vytvorena.
   G. METHOD weak_ptr<T>.owner_before() vracia informacia ci jedna instancia CLASS [weak_ptr<T>] sa nachadza pred inou v IMPLEMENTATION DEFINED ORDER.
   !!! H. METHOD weak_ptr<T>.expire() vracia informaciu ci instancia CLASS [shared_ptr<T>] z ktorej bola instancia CLASS [weak_ptr<T>] vytvorena ma platny OBJECT, alebo je prazdna.
   !!!!! I. METHOD weak_ptr<T>.lock() vracia instanciu CLASS [shared_ptr<T>], ktora zapuzdruje TEN ISTY OBJECT ako zapudzdovala instancia CLASS [shared_ptr<T>] z ktorej bola instancia CLASS [weak_ptr<T>] vytvorena. Pomocou tejto METHOD je mozne pristupit k OBJECT, ktory instancia CLASS [weak_ptr<T>] zapuzdruje.
!!!!! 34. CLASS NESMIE obsahovat FIELDS typu [shared_ptr<T>], ktora referuje na POINTER THIS, pretoze v momente ak by REFERENCE COUNTER sa znizil na 0, zavolal by sa DESTRUCTOR pre CURRENT OBJECT a nasledne pokracovanie CODE v niektorej z METHOD daneho OBJECT by viedlo k MEMORY ACCESS ERROR.
!!!!! 35. CONSTRUCTOR CLASS [shared_ptr<T>], ktory prijima ako PARAMETER POINTER moze byt volany pri splneni tychto podmienok.
   !!! A. POINTER MUSI byt ALOKOVANY pomocou OPERATOR NEW. Ak nie je, potom je NEVYHNUTNE definovat CUSTOM DELETE FUNCTION, ktora dany POINTER uvolni inym sposobom.
   B. Ak POINTER reprezentuje C++ ARRAY, potom je NEVYHNUTNE definovat CUSTOM DELETE FUNCTION, ktora zavola OPERATOR DELETE[].
   !!!!! C. POINTER na ten isty POINTER NESMIE byt priradeny VIAC AKO JEDNEJ INSTANCII CLASS [shared_ptr<T>]. Ak k tomu dojde, kedze OBE INSTANCIE maju VLASTNE REFERENCE COUNTER, ktore NIE SU PREVIAZANE, vo svojich DESTRUCTORS sa pokusia volat OPERATOR DELETE[] cim dojde k MEMORY ACCESS ERROR. Ak POINTER ma byt obsiahnuty vo VIACERYCH instanciach CLASS [shared_ptr<T>], potom 2. instanciu je potrebne vytvorit volanim jej CONSTRUCTOR do ktoreho sa vlozi 1. instancia CLASS [shared_ptr<T>]. V tomto pripade budu mat OBE INSTANCIE SHARED REFERENCE COUNTER a DESTRUCTOR CLASS [shared_ptr<T>] zavola OPERATOR DELETE az ked tento SHARED REFERENCE COUNTER klesne na 0.
   !!!!! D. POINTER NESMIE reprezentovat THIS POINTER. Ak by sa tak stalo, instancia CLASS [shared_ptr<T>] ma NEZAVISLY REFERENCE COUNTER, ktory ak poklesne na 0, DESTRUCTOR tejto intancie zavola OPERATOR DELETE na THIS POINTER co sposobi MEMORY ACCESS ERROR. Jednym z mnoznych rieseni je zdedenie CUSTOM CLASS z CLASS [enable_shared_from_this<T>] a pouzitie FUNCTION shared_from_this().
!!! 36. Ak do CLASS [shared_ptr<T>] je nutne ulozit THIS POINTER, je mozne vyuzit nasledujuci postup.
   A. CUSTOM CLASS ktora chce do instancie CLASS [shared_ptr<T>] ulozit THIS POINTER MUSI byt DERIVED z CLASS [enable_shared_from_this<T>].
   B. Ak CUSTOM CLASS chce vytvorit instanciu CLASS [shared_ptr<T>] pre THIS POINTER MUSI volat METHOD enable_shared_from_this<T>.shared_from_this(). METHOD vracia instanciu CLASS [shared_ptr<T>] vytvorenu z THIS POINTER.
   !!!!! C. Velkou NEVYHODOU METHOD enable_shared_from_this<T>.shared_from_this() je, ze NEMOZE byt volana z CONSTRUCTOR CUSTOM CLASS. Pokus o taketo volanie hodi EXCEPTION [bad_weak_ptr].
   !!!!! D. NEVYHODOU METHOD enable_shared_from_this<T>.shared_from_this() je, ze pri vytvarani instancie CUSTOM CLASS je NEVYHNUTNE ju priradit do instancie CLASS [shared_ptr<T>], inak dojde k EXCEPTION [bad_weak_ptr].
37. CLASS [shared_ptr<T>] definuje CONSTRUCTOR s 2 PARAMETERS, kde prvy je TYPE [shared_ptr<T>] a druhy je TYPE POINTER, ktory sa nazyva ALIASING CONSTRUCTOR. Sluzi na to ak OBJECT obsahuje ako svoj FIELD iny OBJECT. V tomto pripade je zivotnost OBOCH OBJECTS ZVIAZANA (ak sa uvolni PARENT OBJECT automaticky sa uvolnuje aj CHILD OBJECT), a prave na vyjadenie tejto zavislosti sluzi ALIASING CONSTRUCTOR. Samozrejme, ako 2. PARAMETER MUSI byt zaslany POINTER na FIELD OBJECT, ktoreho POINTER je obaleny v 1. PARAMETER, inak sa POINTER v 2. PARAMETER VOBEC NEUVOLNI.
!!! 38. CLASS [shared_ptr<T>] NIE JE THREAD SAFE, ale C++ poskytuje nasledujuce FUNCTIONS pre THREAD SAFE pracu s POINTER, ktory instancia CLASS [shared_ptr<T>] obaluje.
   A. FUNCTION atomic_is_lock_free() vracia TRUE, ak atomicke opracie nad CLASS [shared_ptr<T>] su LOCK FREE.
   B. FUNCTION atomic_load() vracia novu instanciu CLASS [shared_ptr<T>] z instancie CLASS [shared_ptr<T>] THREAD SAFE sposobom.
   C. FUNCTION atomic_store() nastavuje instanciu CLASS [shared_ptr<T>] na POINTER ulozeny v instancii CLASS [shared_ptr<T>] na novy POINTER THREAD SAFE sposobom.
   D. FUNCTION atomic_exchange() vymiena POINTERS ulozene v dvoch instanciach CLASS [shared_ptr<T>] THREAD SAFE sposobom.
!!!!! 39. Aj ked CLASS [shared_ptr<T>] NIE JE THREAD SAFE, tak operacie nad ROZNYMI INSTANCIAMI CLASS [shared_ptr<T>], ktore referuju na TEN ISTY OBJECT z ROZNYCH THREADS SU THREAD SAFE. THREAD UNSAFE je IBA pristup k TEJ ISTE instancii CLASS [shared_ptr<T>] z ROZLICNYCH THREADS.
40. Pre UNIQUE SMART POINTERS platia nasledujuce fakty.
   A. UNIQUE SMART POINTER je reprezentovany CLASS [unique_ptr<T>].
   !!!!! B. CLASS [unique_ptr<T>] EXKLUZIVNE VLASTNI dany OBJECT, co znamena, ze vo svojom DESTRUCTOR OBJECT UVOLNUJE z MEMORY.
   C. CLASS [unique_ptr<T>] umoznuje definovat CUSTOM DELETE FUNCTION, ktora sa zavola pri uvolnovani OBJECT na ktory instancia CLASS [unique_ptr<T>] referovala z MEMORY.
   !!! D. Standardne CLASS [unique_ptr<T>] predpoklada, ze OBJECT bol alokovany pomocou OPERATOR NEW a bez definovania CUSTOM DELETE FUNCTION sa pre OBJECT vola OPERATOR DELETE.
   !!!!! E. CLASS [unique_ptr<T>] ma definovanu TEMPLATE SPECIALIZATION pre ARRAYS, ktora namiesto standardneho OPERATOR DELETE pouziva na uvolnovanie OBJECT, ktory instancia CLASS [unique_ptr<T>] obaluje OPERATOR DELETE[].
41. CLASS [unique_ptr<T>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [unique_ptr<T>] pricom do svojho FIELD ulozi POINTER na OBJECT vlozeny ako PARAMETER.
   B. DESTRUCTOR UVOLNUJE OBJECT na ktory referoval POINTER ulozeny ako FIELD v instancii CLASS [unique_ptr<T>]. Standardne DESTRUCTOR vola OPERATOR DELETE, ale v pripade, ze v CONSTRUCTOR bola zadana aj CUSTOM DELETE FUNCTION, zavola sa tato namiesto OPERATOR DELETE.
   !!! C. OPERATOR= umoznuje priradit instanciu jednej CLASS [unique_ptr<T>] do inej. OPERATOR= funguje IBA pre RVALUES. Priradzovanie LVALUES NIE JE PODPOROVANE a COMPILER pri pokuse priradit LVALUE hodi ERROR. OPERATOR= NEUMOZNUJE priradit PRIAMO POINTER na OBJECT do instancie CLASS [unique_ptr<T>]. Na to je potrebne pouzit METHOD unique_ptr<T>.reset().
   D. OPERATOR* vykonava POINTER DEREFERENCING. Chova sa ako OPERATOR* pre STANDARDNE POINTERS.
   E. OPERATOR-> vykonava POINTER DEREFERENCING. Chova sa ako OPERATOR-> pre STANDARDNE POINTERS.
   E. OPERATOR== porovnava ci 2 instancie CLASS [unique_ptr<T>] referuju na ten isty OBJECT.
   F. OPERATOR!= porovnava ci 2 instancie CLASS [unique_ptr<T>] referuju na ten rozny OBJECT.
   G. OPERATOR< porovnava ci 1. instancia CLASS [unique_ptr<T>] je MENSIA ako druha instancia CLASS [unique_ptr<T>].
   H. OPERATOR<= porovnava ci 1. instancia CLASS [unique_ptr<T>] je MENSIA, alebo ROVNA ako druha instancia CLASS [unique_ptr<T>].
   I. OPERATOR> porovnava ci 1. instancia CLASS [unique_ptr<T>] je VACSIA ako druha instancia CLASS [unique_ptr<T>].
   J. OPERATOR>= porovnava ci 1. instancia CLASS [unique_ptr<T>] je VACSIA, alebo ROVNA ako druha instancia CLASS [unique_ptr<T>].
   K. OPERATOR BOOL vracia hodnotu TRUE, ak instancia CLASS [unique_ptr<T>] referuje na OBJECT, alebo FALSE, ak instancia CLASS [unique_ptr<T>] nereferuje na ziadny OBJECT.
   !!! L. OPERATOR[] je definovany iba pre ARRAY verzie CLASS [unique_ptr<T>] a umoznuje indexovany pristup k ARRAY na ktore referuje instancia CLASS [unique_ptr<T>].
   !!!!! M. METHOD unique_ptr<T>.reset() UVOLNUJE umoznuje OBJECT na ktory referovala instancia CLASS [unique_ptr<T>]. METHOD vola pre dany OBJECT bud OPERATOR DELETE, alebo ak je definovana, tak CUSTOM DELETE FUNCTION.
   !!! N. METHOD unique_ptr<T>.release() rusi REFEROVANIE instancie CLASS [unique_ptr<T>] na OBJECT. OBJECT sa NA ROZDIEL od FUNCTION unique_ptr<T>.reset() NEUVOLNUJE a je ho NUTNE UVOLNIT EXPLICITNE. FUNCTION ako RETURN VALUE vracia POINTER na OBJECT na ktory instancia CLASS [unique_ptr<T>] referovala.
   O. METHOD unique_ptr<T>.swap() umoznuje vzajomne si vymenit POINTERS na OBJECTS na ktore referuju 2 instancie CLASS [unique_ptr<T>].
   P. METHOD unique_ptr<T>.get_deleter() vracia CUSTOM DELETE FUNCTION, ktora bola priradena danej instancii CLASS [unique_ptr<T>].
   !!!!! Q. METHOD unique_ptr<T>.get() vracia POINTER na OBJECT na ktory instancia CLASS [unique_ptr<T>] referuje.
!!! 42. FUNCTION make_unique() vytvara instanciu CLASS [unique_ptr<T>].
!!!!! 43. CLASS [unique_ptr<T>] podporuje IBA MOVE CONSTRUCTOR a OPERATOR= pre MOVE SEMANTICS. COPY CONSTRUCTOR, ani OPERATOR= pre COPY SEMANTICS NIE JE PODPOROVANA, aby sa zabranilo situaciam, kedy by viac ako 1 instancia CLASS [unique_ptr<T>] referovala na TEN ISTY OBJECT, co by viedlo k VIACNASOBNEMU volaniu DESTRUCTOR pre tento OBJECT a tym padom aj k MEMORY ACCESS ERROR.
!!!!! 44. NEEXISTENCIA OPERATOR= pre COPY SEMANTICS, ako aj NEEXISTENCIA COPY CONSTRUCTOR znamena, ze instanciu CLASS [unique_ptr<T>] NIE JE MOZNE PRENASAT ako PARAMETERS FUNCTIONS inak ako pouzitim MOVE SEMANTICS, ktora sposobi, ze povodna instancia CLASS [unique_ptr<T>] nastavi svoju hodnotu na NULL a referovany OBJECT uvolni az instancia CLASS [unique_ptr<T>] pouzita ako ARGUMENT volanej FUNCTION. DESTRUCTOR daneho OBJECT sa potom zavola na konci volanej FUNCTION.
!!!!! 45. KLUCOVOU VYHODOU CLASS [unique_ptr<T>] je, ze umoznuje BEZPECNYM SPOSOBOM, aby FUNCTIONS vracali alokovany OBJECT, ktory same alokovali. Ako RETURN VALUE sa pouzije [unique_ptr<T>], ktory sposobi, ze OBJECT ALOKOVANY vo VOLANEJ FUNCTION bude VZDY UVOLNENY.
!!! 46. CLASS [unique_ptr<T>] je mozne vyuzit v CLASSES namiesto POINTERS, ak tieto CLASSES alokuju vo svojich CONSTRUCTORS OBJECTS, ktore je nutne v DESTRUCTORS uvolnit. Vdaka pouzitiu CLASS [unique_ptr<T>] su tieto OBJECTS uvolnovane AUTOMATICKY.
!!!!! 47. OBROVSKOU VYHODOU pouzitia CLASS [unique_ptr<T>] ako CLASS FIELDS je, ze ak v CONSTRUCTOR pri inicializacii tychto CLASS FIELDS typu [unique_ptr<T>] dojde k hodeniu EXCEPTION, potom C++ AUTOMATICKY zavola DESTRUCTORS pre TIE FIELDS, ktore boli do chvile hodenia EXCEPTION USPESNE VYTVORENE. Tym je mozne predist neprijemnym MEMORY LEAKS.
!!! 48. C++ poskytuje TEMPLATE SPECIALIZATION CLASS [unique_ptr<T>] pre ARRAYS. Pre tuto SPECIALIZATION platia nasledujuce fakty.
   A. Pri deklaracii instancie CLASS [unique_ptr<T>] je nutne pouzit []. To znaci, ze je potrebne definovat instanciu pomocou CODE [unique_ptr<T[]>].
   B. SPECIALIZATION pouziva OPERATOR DELETE[] namiesto OPERATOR DELETE.
   !!! C. SPECIALIZATION NEDEFINUJE OPERATOR* a OPERATOR->.
   D. SPECIALIZATION definuje OPERATOR[] pomocou ktoreho je mozne pristupovat k ITEMS daneho ARRAY. Tento OPERATOR vsak NEKONTROLUJE prekrocenie medzi ARRAY. Ak k nemu dojde, chovanie je UNDEFINED.
49. V pripade, ze uvolnenie OBJECT, ktory je obaleny instanciou CLASS [unique_ptr<T>] potrebuje pri svojom uvolneni vykonat nejaku dodatocnu CUSTOM CINNOST, ktoru nie je vhodne umiestnit do DESTRUCTOR daneho OBJECT, je mozne definovat CUSTOM DELETE FUNCTION. Pre CUSTOM DELETE FUNCTION platia nasledujuce pravidla.
   A. TYPE CUSTOM DELETE FUNCTION sa MUSI EXPLICITNE definovat ako 2. TYPE PARAMETER CLASS [unique_ptr<T>].
   !!!!! B. Kedze volanie CUSTOM DELETE FUNCTION NAHRADZUJE volanie standardnych OPERATOR DELETE a OPERATOR DELETE[] MUSI CUSTOM DELETE FUNCTION jeden z tychto OPERATORS ZVOLAT, aby doslo k uvolneniu OBJECT, ktory obaluje instancia CLASS [unique_ptr<T>].
   !!! C. CUSTOM DELETE FUNCTION NESMIE hodit EXCEPTION, inak je cinnost CLASS [unique_ptr<T>] UNDEFINED.
   D. CUSTOM DELETE FUNCTION MUSI mat ako PARAMETER POINTER, ktory instancia CLASS [unique_ptr<T>] obaluje.
   !!! E. Ako CUSTOM DELETE FUNCTION je VYHODNEJSIE pouzivat FUNCTOR, alebo LAMBDA EXPRESSION namiesto klasickych FUNCTIONS, pretoze tie dokaze C++ lepsie optimalizovat.
50. CLASS [auto_ptr<T>] je v C++ 11 DEPRECATED. Dovodom je, ze CLASS nemala (podobne ako C++) MOVE SEMANTICS co pri kopirovani instancie CLASS [auto_ptr<T>] do inej VARIABLE typu [auto_ptr<T>] viedlo k VIACNASOBNEMU pokusu o UVOLNENIE OBJECT a tym padom aj k MEMORY ACCESS ERROR.
51. CLASS [unique_ptr<T>] na ROZDIEL od CLASS [shared_ptr<T>] NEMA ZIADEN MEMORY OVERHEAD a jeho velkost v MEMORY je rovnaka ako velkost POINTER.
52. TEMPLATE CLASS [numeric_limits<T>] obsahuje MEMBERS, ktory popisuju rozlicne vlastnosti NUMERIC TYPES. TEMPLATE CLASS [numeric_limits<T>] je SPECIALIZED pre vsetky BUILT-IN NUMERIC TYPES definovane v C++. Pre CUSTOM NUMERIC TYPES je mozne definovat CUSTOM SPECIALIZATION.
53. CLASS [numeric_limits<T>] ma nasledujuce MEMBERS.
   !!! 1. FIELD numeric_limits<T>.is_specialized vracia TRUE, ak pre TYPE 'T' existuje TEMPLATE SPECIALIZATION CLASS [numeric_limits<T>].
   2. FIELD numeric_limits<T>.is_signed vracia TRUE, ak TYPE 'T' je SIGNED TYPE.
   3. FIELD numeric_limits<T>.is_integer vracia TRUE, ak TYPE 'T' je INTEGER TYPE.
   4. FIELD numeric_limits<T>.is_exact vracia TRUE, ak TYPE 'T' pouziva exaktnu reprezentaciu.
   5. FIELD numeric_limits<T>.has_infinity vracia TRUE, ak FLOAT TYPE 'T' dokaze reprezentovat nekonecno. Ma zmysel iba pre FLOAT TYPES.
   6. FIELD numeric_limits<T>.has_quiet_NaN vracia TRUE, ak FLOAT TYPE 'T' dokaze reprezentovat QUIET NAN hodnotu. Ma zmysel iba pre FLOAT TYPES.
   7. FIELD numeric_limits<T>.has_signaling_NaN vracia TRUE, ak FLOAT TYPE 'T' dokaze reprezentovat SIGNALING NAN hodnotu. Ma zmysel iba pre FLOAT TYPES.
   8. FIELD numeric_limits<T>.has_denorm vracia ENUM hodnotu urcujucu ci FLOAT TYPE 'T' podporuje normalizaciu. Ma zmysel iba pre FLOAT TYPES.
   9. FIELD numeric_limits<T>.has_denorm_loss vracia TRUE, ak FLOAT TYPE 'T' detekuje stratu presnosti. Ma zmysel iba pre FLOAT TYPES.
   10. FIELD numeric_limits<T>.round_style vracia ENUM hodnotu urcujucu sposob zaokruhlovania FLOAT TYPE 'T'. Ma zmysel iba pre FLOAT TYPES.
   11. FIELD numeric_limits<T>.is_iec559 vracia TRUE ak TYPE 'T' reprezentuje FLOAT TYPE.
   12. FIELD numeric_limits<T>.is_bounded vracia TRUE, ak pomocou TYPE 'T' je mozne vyjadrit konecny pocet hodnot.
   13. FIELD numeric_limits<T>.is_modulo vracia informaciu ci TYPE 'T' pri OVERFLOW pouziva operaciu MODULO na zarovnanie cisla do intervalu pre TYPE 'T'.
   14. FIELD numeric_limits<T>.digits vracia maximalny pocet cislic, ktore je pre TYPE 'T' pouzit, aby nedoslo k zmene hodnoty.
   15. FIELD numeric_limits<T>.digits10 vracia maximalny pocet cislic, ktore je pri zaklade 10 pre TYPE 'T' pouzit, aby nedoslo k zmene hodnoty. Napriklad pre BYTE je tato hodnota 2, pretoze iba 2 ciferne hodnoty hodnoty <0,99> je mozne danym TYPE vyjadrit bez zmeny hodnoty. Hodnoty s 3 cislami, ako naprikolad 999 nie je mozne v BYTE vyjadrit, bez zmeny hodnoty, pretoze dojde k preteceniu.
   !!! 16. FIELD numeric_limits<T>.max_digits10 vracia maximalny pocet cislic, ktore su pri desiatkovej ciselnej sustave potrebne na ulozenie lubovolnej hodnoty pre TYPE 'T'. Hodnota sa vyuziva pri SERIALIZATION/DESERIALIZATION. Ma zmysel iba pre FLOAT TYPES.
   17. FIELD numeric_limits<T>.radix vracia ciselnu sustavu v ktorej je vyjadreny TYPE 'T'.
   18. FIELD numeric_limits<T>.min_exponent vracia najmensi zaporny exponent pri zaklade, ktory TYPE 'T' pouziva, ktory este dava validnu FLOAT VALUE. Ma zmysel iba pre FLOAT TYPES.
   19. FIELD numeric_limits<T>.min_exponent10 vracia najmensi zaporny exponent pri zaklade 10 pre TYPE 'T', ktory este dava validnu FLOAT VALUE. Ma zmysel iba pre FLOAT TYPES.
   20. FIELD numeric_limits<T>.max_exponent vracia najvacsi exponent pri zaklade, ktory TYPE 'T' pouziva, ktory este dava validnu FLOAT VALUE. Ma zmysel iba pre FLOAT TYPES.
   21. FIELD numeric_limits<T>.max_exponent10 vracia najvacsi exponent pri zaklade 10, ktory pre TYPE 'T' este dava validnu FLOAT VALUE. Ma zmysel iba pre FLOAT TYPES.
   22. FIELD numeric_limits<T>.traps vracia TRUE pre vsetky TYPES 'T' ak TYPES maju aspon jednu hodnotu, ktora pri vykonavani EXPRESSION moze sposobit TRAP (HW EXCEPTION na CPU).
   23. FIELD numeric_limits<T>.tinyness_before vracia TRUE pre vsetky FLOAT TYPES 'T' ak TYPES vykonavaju na konci vypoctu EXPRESSION kontrolu na UNDERFLOW, predtym nez vykonaju ROUNDING.
   24. METHOD numeric_limits<T>.min() vracia najmensi mozny prirastok hodnoty, ktoru je mozne vyjadrit TYPOM 'T'. Pre FLOAT TYPES je to VZDY KLADNA HODNOTA, pretoze udava MINIMALNY PRIRASTOK a nie ABSOLUTNU MINIMALNU HODNOTU.
   25. METHOD numeric_limits<T>.lowest() vracia ABSOLUTNU MINIMALNU hodnotu TYPU 'T'.
   26. METHOD numeric_limits<T>.max() vracia ABSOLUTNU MAXIMALNU hodnotu TYPU 'T'.
   27. METHOD numeric_limits<T>.epsilon() vracia EPSILON vyjadreny ako rozdiel medzi hodnotou 1.0 a najblizsou vyssou hodnotou, ktoru je mozne vyjadrit TYPOM 'T'. Ma zmysel iba pre FLOAT TYPES.
   28. METHOD numeric_limits<T>.round_error() vracia najvacsiu moznu chybu zaokruhlenia pre TYPE 'T'. Ma zmysel iba pre FLOAT TYPES.
   29. METHOD numeric_limits<T>.infinity() vracia nekonecnu hodnotu pre TYPE 'T'. Ma zmysel iba pre FLOAT TYPES.
   30. METHOD numeric_limits<T>.quiet_NaN() vracia QUIET NAN hodnotu pre TYPE 'T'. Ma zmysel iba pre FLOAT TYPES.
   31. METHOD numeric_limits<T>.signaling_NaN() vracia SIGNALING NAN hodnotu pre TYPE 'T'. Ma zmysel iba pre FLOAT TYPES.
   32. METHOD numeric_limits<T>.denorm_min() vracia minimalnu kladnu denormalizovanu hodnotu pre TYPE 'T'. Ma zmysel iba pre FLOAT TYPES.
!!! 54. METHODS CLASS [numeric_limits<T>] su deklarovane ako CONSTEXPR, co znaci, ze ich RETURN VALUE je mozne pouzit napriklad aj pri deklaracii velkosti ARRAYS.
55. C++ pre jednotlive NUMBER TYPES definuje MINIMALNU DLZKU v BYTES, ktora je garantovana, ze ju dany TYPE bude mat. C++ pre BUILT-IN TYPES definuje nasledujuce dlzky v BYTES.
   A. TYPE [char] ma 1 BYTE.
   B. TYPE [short int] ma 2 BYTES.
   C. TYPE [int] ma 2 BYTES.
   D. TYPE [long int] ma 4 BYTES.
   E. TYPE [long long int] ma 8 BYTES.
   F. TYPE [float] ma 4 BYTES.
   G. TYPE [double] ma 8 BYTES.
   H. TYPE [long double] ma 8 BYTES.
56. TYPE TRAITS je skupina TEMPLATES (spravidla TEMPLATE CLASSES s pretazenym OPERATOR()) umoznujuca testovat TYPES na existenciu rozlicnych TYPE PROPERTIES. Pomocou TYPE TRAITS je napriklad mozne zistit ci TYPE ma definovane nasledujuce PROPERTIES.
   A. Ci je TYPE INTEGER TYPE.
   B. Ci je TYPE FLOAT TYPE.
   C. Ci ma TYPE DEFAULT CONSTRUCTOR.
   D. Ci ma TYPE definovany FIELD 'XXX'.
   E. Ci ma TYPE definovanu METHOD YYY().
   F. Ci ma TYPE definovany OPERATOR+.
   G. Ci je TYPE 'X' BASE TYPE k TYPE 'Y'.
   H. Ci je TYPE POINTER TYPE.
   I. Modifikovat TYPE pridanim CONST.
   J. Modifikovat TYPE na POINTER TYPE.
   K. Modifikovat POINTER TYPE na TYPE.
   L. Zmenit SIGNED INTEGER TYPE na UNSIGNED INTEGER TYPE.
   M. Zistit pocet DIMESTIONS ak je TYPE ARRAY.
57. C++ definuje mnozstvo TYPE TRAITS v HEADER <type_traits>, pricom s vyuzitim METAPROGRAMMING je mozne definovat CUSTOM TYPE TRAITS.
58. C++ definuje nasledujuce typy TYPE TRAITS.
   1. TYPE TRAIT [is_void<T>] urcuje ci TYPE 'T' je VOID TYPE.
   2. TYPE TRAIT [is_integral<T>] urcuje ci TYPE 'T' je INTEGER TYPE. Sem patri aj TYPE [char] ci TYPE [bool].
   3. TYPE TRAIT [is_floating_point<T>] urcuje ci TYPE 'T' je FLOATING POINT TYPE.
   4. TYPE TRAIT [is_arithmetic<T>] urcuje ci TYPE 'T' je ARITHMETIC TYPE. Sem patri INTEGER a FLOATIN POINT TYPES, ako aj TYPE [char] ci TYPE [bool].
   5. TYPE TRAIT [is_signed<T>] urcuje ci TYPE 'T' je SIGNED ARITHMETIC TYPE.
   6. TYPE TRAIT [is_unsigned<T>] urcuje ci TYPE 'T' je UNSIGNED ARITHMETIC TYPE.
   7. TYPE TRAIT [is_const<T>] urcuje ci TYPE 'T' ma modifikator CONST.
   8. TYPE TRAIT [is_volatile<T>] urcuje ci TYPE 'T' ma modifikator VOLATILE.
   9. TYPE TRAIT [is_array<T>] urcuje ci TYPE 'T' je ARRAY TYPE.
   10. TYPE TRAIT [is_enum<T>] urcuje ci TYPE 'T' je ENUM TYPE.
   11. TYPE TRAIT [is_union<T>] urcuje ci TYPE 'T' je UNION TYPE.
   12. TYPE TRAIT [is_class<T>] urcuje ci TYPE 'T' je CLASS TYPE, alebo STRUCTURE TYPE.
   13. TYPE TRAIT [is_function<T>] urcuje ci TYPE 'T' je FUNCTION TYPE.
   14. TYPE TRAIT [is_reference<T>] urcuje ci TYPE 'T' je REFERENCE TYPE. Akceptuje LVALUE REFERENCE TYPE aj RVALUE REFERENCE TYPE.
   15. TYPE TRAIT [is_lvalue_reference<T>] urcuje ci TYPE 'T' je LVALUE REFERENCE TYPE.
   16. TYPE TRAIT [is_rvalue_reference<T>] urcuje ci TYPE 'T' je RVALUE REFERENCE TYPE.
   17. TYPE TRAIT [is_pointer<T>] urcuje ci TYPE 'T' je POINTER TYPE. Akceptuje aj FUNTION POINTER TYPE, ale NIE POINTER TYPES na NON-STATIC MEMBERS.
   18. TYPE TRAIT [is_member_pointer<T>] urcuje ci TYPE 'T' je POINTER TYPE na NON-STATIC MEMBER. Akceptuje aj POINTER TYPES na NON-STATIC FIELDS a POINTER TYPES na NON-STATIC METHODS.
   19. TYPE TRAIT [is_member_object_pointer<T>] urcuje ci TYPE 'T' je POINTER TYPE na NON-STATIC FIELD.
   20. TYPE TRAIT [is_member_function_pointer<T>] urcuje ci TYPE 'T' je POINTER TYPE na NON-STATIC METHOD.
   21. TYPE TRAIT [is_fundamental<T>] urcuje ci TYPE 'T' je FUNDAMENTAL TYPE. FUNDAMENTAL TYPS su vsetky INTEGER TYPES vratane TYPE [char] a TYPE [bool], FLOATING POINT TYPES, TYPE [void] a TYPE [nullptr_t].
   22. TYPE TRAIT [is_scalar<T>] urcuje ci TYPE 'T' je SCALAR TYPE. SCALAR TYPS su vsetky INTEGER TYPES vratane TYPE [char] a TYPE [bool], FLOATING POINT TYPES, ENUM TYPES, POINTER TYPES, MEMBER POINTER TYPES,  TYPE [void] a TYPE [nullptr_t].
   23. TYPE TRAIT [is_object<T>] urcuje ci TYPE 'T' je LUBOVOLNY TYPE okrem REFERENCE TYPES, FUNCTION TYPES a TYPE [void].
   24. TYPE TRAIT [is_compound<T>] urcuje ci TYPE 'T' je niektory z TYPES ARRAY TYPE, ENUM TYPE, UNION TYPE, CLASS TYPE, FUNCTION TYPE, REFERENCE TYPE, alebo POINTER TYPE.
   25. TYPE TRAIT [is_trivial<T>] urcuje ci TYPE 'T' TRIVIAL TYPE. TRIVIAL TYPES su SCALAR TYPES, alebo ARRAY SCALAR TYPES.
   26. TYPE TRAIT [is_trivially_copyable<T>] urcuje ci TYPE 'T' je COPYABLE SCALAR TYPE, alebo ARRAY COPYABLE SCALAR TYPE.
   27. TYPE TRAIT [is_standard_layout<T>] urcuje ci TYPE 'T' je STANDARD LAYOUT SCALAR TYPE, alebo ARRAY STANDARD LAYOUT SCALAR TYPE.
   28. TYPE TRAIT [is_pod<T>] urcuje ci TYPE 'T' je PLAIN OLD DATA TYPE. PLAIN OLD DATA TYPES su TYPES, ktore je mozne kompirovat pomocou FUNCTION memcopy().
   29. TYPE TRAIT [is_literal_type<T>] urcuje ci TYPE 'T' je LITERAL TYPE. LITERAL TYPES su SCALAR TYPES, REFERENCE TYPES, CLASS TYPES, alebo ARRAY SCALAR TYPES, ARRAY REFERENCE TYPES a ARRAY CLASS TYPES.
   30. TYPE TRAIT [is_empty<T>] urcuje ci TYPE 'T' je EMPTY. EMPTY TYPE je TYPE, ktory NEMA MEMBERS ani VIRTUAL MEMBER FUNCTIONS ani VIRTUAL BASE CLASSES.
   31. TYPE TRAIT [is_polymorphic<T>] urcuje ci TYPE 'T', ktory ma aspon 1 VIRTUAL METHOD, alebo DERIVED VIRTUAL METHOD.
   32. TYPE TRAIT [is_abstract<T>] urcuje ci TYPE 'T', ktory ma aspon 1 PURE VIRTUAL METHOD.
   33. TYPE TRAIT [has_virtual_destructor<T>] urcuje ci TYPE 'T' ma VIRTUAL DESTRUCTOR.
   34. TYPE TRAIT [is_default_constructible<T>] urcuje ci TYPE 'T' ma DEFAULT CONSTRUCTOR.
   35. TYPE TRAIT [is_copy_constructible<T>] urcuje ci TYPE 'T' ma COPY CONSTRUCTOR.
   36. TYPE TRAIT [is_move_constructible<T>] urcuje ci TYPE 'T' ma MOVE CONSTRUCTOR.
   37. TYPE TRAIT [is_copy_assignable<T>] urcuje ci TYPE 'T' ma OPERATOR= s COPY SEMANTICS.
   38. TYPE TRAIT [is_move_assignable<T>] urcuje ci TYPE 'T' ma OPERATOR= s MOVE SEMANTICS.
   39. TYPE TRAIT [is_destructible<T>] urcuje ci TYPE 'T' ma PUBLIC DESTRUCTOR, ktory NIE JE DELETED DESTRUCTOR.
   40. TYPE TRAIT [is_trivially_default_constructible<T>] urcuje ci TYPE 'T' ma TRIVIAL DEFAULT CONSTRUCTOR. TRIVIAL CONSTRUCTOR je CONSTRUCTOR, ktory ma IBA TRIVIALNE CONSTRUCTS. TRIVIAL CONSTRUCTOR NESMIE hodit EXCEPTION.
   41. TYPE TRAIT [is_trivially_copy_constructible<T>] urcuje ci TYPE 'T' ma TRIVIAL COPY CONSTRUCTOR. TRIVIAL CONSTRUCTOR je CONSTRUCTOR, ktory ma IBA TRIVIALNE CONSTRUCTS. TRIVIAL CONSTRUCTOR NESMIE hodit EXCEPTION.
   42. TYPE TRAIT [is_trivially_move_constructible<T>] urcuje ci TYPE 'T' ma TRIVIAL MOVE CONSTRUCTOR. TRIVIAL CONSTRUCTOR je CONSTRUCTOR, ktory ma IBA TRIVIALNE CONSTRUCTS. TRIVIAL CONSTRUCTOR NESMIE hodit EXCEPTION.
   43. TYPE TRAIT [is_trivially_copy_assignable<T>] urcuje ci TYPE 'T' ma TRIVIAL OPERATOR= s COPY SEMANTICS. TRIVIAL OPERATOR= je OPERATOR=, ktory ma IBA TRIVIALNE CONSTRUCTS. TRIVIAL OPERATOR= NESMIE hodit EXCEPTION.
   44. TYPE TRAIT [is_trivially_move_assignable<T>] urcuje ci TYPE 'T' ma TRIVIAL OPERATOR= s MOVE SEMANTICS. TRIVIAL OPERATOR= je OPERATOR=, ktory ma IBA TRIVIALNE CONSTRUCTS. TRIVIAL OPERATOR= NESMIE hodit EXCEPTION.
   45. TYPE TRAIT [is_trivially_destructible<T>] urcuje ci TYPE 'T' ma TRIVIAL DESTRUCTOR. TRIVIAL DESTRUCTOR je DESTRUCTOR, ktory ma IBA TRIVIALNE CONSTRUCTS. TRIVIAL DESTRUCTOR NESMIE hodit EXCEPTION.
   46. TYPE TRAIT [is_nothrow_default_constructible<T>] urcuje ci TYPE 'T' ma  DEFAULT CONSTRUCTOR, ktory NEHADZE EXCEPTIONS.
   47. TYPE TRAIT [is_nothrow_copy_constructible<T>] urcuje ci TYPE 'T' ma  COPY CONSTRUCTOR, ktory NEHADZE EXCEPTIONS.
   48. TYPE TRAIT [is_nothrow_move_constructible<T>] urcuje ci TYPE 'T' ma  MOVE CONSTRUCTOR, ktory NEHADZE EXCEPTIONS.
   49. TYPE TRAIT [is_nothrow_copy_assignable<T>] urcuje ci TYPE 'T' ma  OPERATOR= s COPY SEMANTICS, ktory NEHADZE EXCEPTIONS.
   50. TYPE TRAIT [is_nothrow_move_assignable<T>] urcuje ci TYPE 'T' ma  OPERATOR= s MOVE SEMANTICS, ktory NEHADZE EXCEPTIONS.
   51. TYPE TRAIT [is_nothrow_destructible<T>] urcuje ci TYPE 'T' ma  DESTRUCTOR, ktory NEHADZE EXCEPTIONS.
   52. TYPE TRAIT [is_same<T1,T2>] urcuje ci su TYPE 'T1' a TYPE 'T2' IDENTICKE. Za identicke sa povazuju aj ALIASES vytvorene pomocou TYPEDEF a USING. CONST a VOLATILE TYPES NIE SU povazovane za IDENTICKE TYPES z NON-CONST a NON-VOLATILE TYPES.
   53. TYPE TRAIT [is_base_of<B,D>] urcuje ci TYPE 'B' je BASE CLASS TYPE 'D'. Akceptuju aj sa TYPES, ktore su DERIVED cez PRIVATE a PROTECTED MODIFIERS.
   54. TYPE TRAIT [is_convertible<T1,T2>] urcuje ci TYPE 'T1' je konvertovatelny na TYPE 'T2'. Akceptuju aj sa konverzie na TYPES, ktore su DERIVED cez PRIVATE a PROTECTED MODIFIERS a takisto CUSTOM CONVERSIONS si CUSTOM NON-EXPLICIT CONSTRUCTORS.
   55. TYPE TRAIT [is_constructible<T,TTypes>] urcuje ci TYPE 'T' je mozne vytvorit volanim CONSTRUCTOR, ktory ma PARAMETERS 'TTypes'.
   56. TYPE TRAIT [is_trivially_constructible<T,TTypes>] urcuje ci TYPE 'T' je mozne TRIVIALNE (BEZ vykonania CONVERSIONS) vytvorit volanim CONSTRUCTOR, ktory ma PARAMETERS 'TTypes'.
   57. TYPE TRAIT [is_nothrow_constructible<T,TTypes>] urcuje ci TYPE 'T' je mozne vytvorit volanim CONSTRUCTOR, ktory ma PARAMETERS 'TTypes', pricom tento CONSTRUCTOR NEHADZE EXCEPTIONS.
   58. TYPE TRAIT [is_assignable<T1,T2>] urcuje ci do TYPE 'T1' je mozne priradit TYPE 'T2'. Akceptuju aj CUSTOM CONVERSIONS si CUSTOM NON-EXPLICIT CONSTRUCTORS.
   59. TYPE TRAIT [is_trivially_assignable<T1,T2>] urcuje ci do TYPE 'T1' je mozne TRIVIALNE (BEZ vykonania CONVERSIONS) priradit TYPE 'T2'.
   60. TYPE TRAIT [is_nothrow_assignable<T1,T2>] urcuje ci do TYPE 'T1' je mozne priradit TYPE 'T2' bez toho, aby doslo k hodeniu EXCEPTION. Akceptuju aj CUSTOM CONVERSIONS si CUSTOM NON-EXPLICIT CONSTRUCTORS.
   61. TYPE TRAIT [uses_allocator<T,TAlloc>] urcuje ci TYPE 'TAlloc' je mozne konverovat na TYPE 'T::allocator_type'.
   62. TYPE TRAIT [remove_const<T>] odstranuje z TYPE 'T' CONST MODIFIER.
   63. TYPE TRAIT [remove_volatile<T>] odstranuje z TYPE 'T' VOLATILE MODIFIER.
   64. TYPE TRAIT [remove_cv<T>] odstranuje z TYPE 'T' CONST a VOLATILE MODIFIERS.
   65. TYPE TRAIT [add_const<T>] pridava do TYPE 'T' CONST MODIFIER.
   66. TYPE TRAIT [add_volatile<T>] pridava do TYPE 'T' VOLATILE MODIFIER.
   67. TYPE TRAIT [add_cv<T>] pridava do TYPE 'T' CONST a VOLATILE MODIFIERS.
   68. TYPE TRAIT [make_signed<T>] zmeni TYPE 'T' na SIGNED TYPE.
   69. TYPE TRAIT [make_unsigned<T>] zmeni TYPE 'T' na UNSIGNED TYPE.
   70. TYPE TRAIT [remove_reference<T>] odstranuje z REFERENCE TYPE 'T' REFERENCE MODIFIER.
   71. TYPE TRAIT [add_lvalue_reference<T>] pridava do TYPE 'T' RVALUE REFERENCE MODIFIER.
   72. TYPE TRAIT [add_rvalue_reference<T>] pridava do TYPE 'T' LVALUE REFERENCE MODIFIER.
   73. TYPE TRAIT [remove_pointer<T>] odstranuje z TYPE 'T' POINTER MODIFIER.
   74. TYPE TRAIT [add_pointer<T>] pridava do TYPE 'T' POINTER MODIFIER.
   75. TYPE TRAIT [rank<T>] vracia POCET DIMENSIONS ak je TYPE 'T' ARRAY. Ak TYPE 'T' nie je ARRAY, vracia hodnotu 0.
   76. TYPE TRAIT [extent<T,Index>] vracia POCET ITEMS v DIMENSION 'Index' ak je TYPE 'T' ARRAY. Ak TYPE 'T' nie je ARRAY, alebo nema DIMENSION 'Index' vracia hodnotu 0.
   77. TYPE TRAIT [remove_extent<T>] odstrani 1. DIMENSION z TYPE 'T' je TYPE 'T' ARRAY. Ak TYPE 'T' nie je ARRAY, vracia TYPE 'T'.
   78. TYPE TRAIT [remove_all_extents<T>] odstrani VSETKY DIMENSIONS z TYPE 'T' je TYPE 'T' ARRAY. Ak TYPE 'T' nie je ARRAY, vracia TYPE 'T'.
   79. TYPE TRAIT [underlying_type<T>] vracia PRIMITIVE TYPE, ktorym je vyjadreny ENUM TYPE 'T'.
   80. TYPE TRAIT [decay<T>] ak je TYPE 'T' LVALUE, zmeni ho na RVALUE, ak je TYPE 'T' REFERENCE zmeni ho na BY-VALUE TYPE, ak je TYPE 'T' ARRAY, zmeni ho na POINTER, ak je TYPE 'T' FUNCTION, zmeni ho na POINTER na FUNCTION a ak ma TYPE 'T' CONST, alebo VOLATILE MODIFIER, tak vracia TYPE BEZ tychto MODIFIERS.
   !!! 81. TYPE TRAIT [enable_if<B,T>] vracia v ALIAS 'type' TYPE 'T' ak podmienka 'B' je rovna TRUE, alebo ak podmienka 'B' je rovna FALSE, ALIAS 'type' NEDEFINUJE. Pouziva sa pri aplikacii SFINAE mechanizmu.
   82. TYPE TRAIT [conditional<B,T1,T2>] vracia v ALIAS 'type' TYPE 'T1' ak podmienka 'B' je rovna TRUE, alebo ak podmienka 'B' je rovna FALSE, vracia v ALIAS 'type' TYPE 'T2'.
   83. TYPE TRAIT [common_type<TTypes...>] vracia zo vsetkych TYPES 'TTypes' ten TYPE na ktory je KAZDY DALSI TYPE mozne KONVERTOVAT. Do uvahy sa beru aj CUSTOM CONVERSIONS. Ak takyto TYPE NEEXISTUJE, COMPILER generuje ERROR. TYPE TRAITS dokaze najst spolocny TYPE aj pre CUSTOM TYPES ak su v dedicskej hierarchii.
   84. TYPE TRAIT [result_of<TFunctionObject(TArgTypes...)>] vracia RETURN TYPE FUNCTION OBJECT 'TFunctionObject', ktora ma PARAMETERS 'TArgTypes'.
   85. TYPE TRAIT [alignment_of<T>] vracia ALIGNMENT TYPE 'T'. Je to EKVIVALENT OPERATOR [alignof(T)].
   86. TYPE TRAIT [aligned_storage<Length,Alignment>] vracia TYPE o MINIMALNEJ DLZKE 'Length' BYTES s ALIGNMENT delitelnym hodnotou 'Alignment'.
   87. TYPE TRAIT [aligned_union<Length,TTypes>] vracia UNION TYPE o MINIMALNEJ DLZKE 'Length' z ktoreho je mozne skonstruovat UNION TYPE obsahujucim TYPES 'Types'.
   !!!!! 88. TYPE TRAIT [declval<T>] konvertuje TYPE 'T' na jeho RVALUE REFERENCE TYPE. RETURN TYPE z TYPE TRAIT sa NESMIE POUZIVAT v CODE, ktory je EVALUATED. TYPE TRAIT je mozne pouzit napriklad s KEYWORD decltype(), alebo v KEYWORD noexcept().
!!! 59. CLASS [reference_wrapper<T>] reprezetnuje OBJECT, ktory vytvara WRAPPER okolo C++ REFERENCES. Tato CLASS umoznuje prenasat do TEMPLATE FUNCTION a TEMPLATE CLASSES REFERENCES tym, ze ich obali do instancie CLASS [reference_wrapper<T>]. CLASS [reference_wrapper<T>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [reference_wrapper<T>] pricom do nej uklada zadanu REFERENCE.
   B. OPERATOR= priradzuje REFERENCES z jednej instancie CLASS [reference_wrapper<T>] do inej.
   C. [OPERATOR T&] vracia REFERENCE, ktoru instancia CLASS [reference_wrapper<T>] zapuzdruje.
   D. OPERATOR() vola FUNCTION, ak REFERENCE , ktoru instancia CLASS [reference_wrapper<T>] je CALLABLE OBJECT.
   E. METHOD reference_wrapper<T>.get() vracia REFERENCE, ktoru instancia CLASS [reference_wrapper<T>] zapuzdruje.
   F. TYPE [reference_wrapper<T>::type] vracia TYPE 'T'.
60. Instanciu CLASS [reference_wrapper<T>] vracaju ako RETURN VALUES FUNCTIONS ref() a cref().
!!!!! 61. VYHODOU CLASS [reference_wrapper<T>] je moznost ukladat REFERENCES do CONTAINERS ako napriklad [list<T>].
!!!!! 62. CLASS [reference_wrapper<T>] je interne realizovana tak, ze si uklada vo svojom FIELD POINTER na OBJECT zaslany v CONSTRUCTOR a na ten robi DEREFERENCING v pripade, ze je treba pristupit k OBJECT. Je to vlastne iba WRAPPER okolo POINTER, ktory simuluje cinnost REFERENCES.
63. CLASS [function<R(TArgs...)>] zapudzdruje CALLABLE OBJECT (FUNCTION, METHOD, LAMBDA FUNCTION, FUNCTOR) tak, aby bolo s nim mozne pracovat ako s klasickym OBJECT co umoznuje jeho prenos ako PARAMETER do FUNCTIONS ci ulozenie do COLLECTIONS. CLASS [function<R(TArgs...)>] ma nasledujuce MEMBERS.
   A. CONSTRUCTOR vytvara instanciu CLASS [function<R(TArgs...)>].
   B. DESTRUCTOR uvolnuje instanciu CLASS [function<R(TArgs...)>].
   C. TYPE function<R(TArgs...)>::result_type vracia TYPE RETURN VALUE zapudzdenej FUNCTION.
   D. OPERATOR= priradzuje jednu instanciu CLASS [function<R(TArgs...)>] do inej.
   E. OPERATOR BOOL vracia TRUE, ak instancia CLASS [function<R(TArgs...)>] ma priradeny CALLABLE OBJECT.
   F. OPERATOR() vola CALLABLE OBJECT, ktory instancia CLASS [function<R(TArgs...)>] zapuzdruje.
   G. OPERATOR== urcuje ci instancia CLASS [function<R(TArgs...)>] je rovna NULL.
   H. OPERATOR!= urcuje ci instancia CLASS [function<R(TArgs...)>] je rozna od NULL.
   I. METHOD function<R(TArgs...)>.assign() priradzuje jednu instanciu CLASS [function<R(TArgs...)>] do inej.
   J. METHOD function<R(TArgs...)>.swap() vymiena CALLABLE OBJECTS medzi dvoma instanciami CLASS [function<R(TArgs...)>].
   K. METHOD function<R(TArgs...)>.target() vracia POINTER na CALLABLE OBJECT, ktory instancia CLASS [function<R(TArgs...)>] zapuzdruje.
   L. METHOD function<R(TArgs...)>.target_type() vracia REFERENCE na instanciu CLASS [typeinfo] reprezetnujucu TYPE CALLABLE OBJECT, ktory instancia CLASS [function<R(TArgs...)>] zapuzdruje.
!!! 64. CLASS [function<R(TArgs...)>] je MOZNE pouzit aj na ZAPUZDRENIE METHODS. V pripade METHODS MUSI byt ako 1. PARAMETER v TYPE PARAMETER 'TArgs' CONST REFERENCE na TYPE v ktorom je METHOD definovana. Tento PARAMETER reprezentuje THIS POINTER.
65. LIBRARY <algorithm> poskytuje niekolko pomocnych TEMPLATE FUNCTIONS.
   A. FUNCTION min() vracia MINIMALNU VALUE. FUNCTION je OVERLOADED pre 2 PARAMETERS, alebo pre CLASS [initializer_list<T>]. FUNCTIONS prijimaju aj CUSTOM COMPARER, ktorym je mozne nahradit standardne pouzivany OPERATOR<.
   B. FUNCTION max() vracia MAXIMALNU VALUE. FUNCTION je OVERLOADED pre 2 PARAMETERS, alebo pre CLASS [initializer_list<T>]. FUNCTIONS prijimaju aj CUSTOM COMPARER, ktorym je mozne nahradit standardne pouzivany OPERATOR<.
   C. FUNCTION minmax() vracia MINIMALNU a MAXIMALNU VALUE v instancii CLASS [pair<T,T>]. kde 1. VALUE PAIR je MINIMALNA VALUE a 2. VALUE PAIR je MAXIMALNA VALUE. FUNCTION je OVERLOADED pre 2 PARAMETERS, alebo pre CLASS [initializer_list<T>]. FUNCTIONS prijmaju aj CUSTOM COMPARER, ktorym je mozne nahradit standardne pouzivany OPERATOR<.
66. FUNCTION swap() umoznuje vymenit hodnoty 2 VARIABLES pomocou MOVE SEMANTICS. Pre FUNCTION swap() platia nasledujuce pravidla.
   A. Vymena VARIABLES sa vykonava pomocou MOVE SEMANTICS, ak ju TYPE podporuje. Ak nie, pouzije sa COPY SEMANTICS.
   B. C++ poskytuje SPECIALIZATION pre ARRAYS.
   !!! C. Zasadnou VYHODNOU FUNCTION swap() je to, ze poskytuje standardizovany sposob realizacie SWAP funkcionality. CUSTOM TYPES mozu implementovat FUNCTION swap() a tym poskytnut tento standardizovanym mechanizmus.
67. NAMESPACE [std::rel_ops] obsahuje OVERLOADED OPERATORS, ktore umoznuju implementovat vsetky COMPARISION OPERATORS pre CUSTOM CLASSES, ktore implementuju CUSTOM OPERATORS OPERATOR< a OPERATOR==. NAMESPACE [std::rel_ops] obsahuje nasledujuce OPERATORS.
   A. OPERATOR!= urcuje ci VALUE1!=VALUE2.
   B. OPERATOR> urcuje ci VALUE1>VALUE2.
   C. OPERATOR<= urcuje ci VALUE1<=VALUE2.
   D. OPERATOR>= urcuje ci VALUE1>=VALUE2.
!!! 68. NEVYHODOU OPERATORS v NAMESPACE [std::rel_ops], ze pri pouziti USING NAMESPACE na GLOBAL SCOPE dojde k NAMESPACE POLLUTION. Vdaka tomu moze C++ CHYBNE aplikovat OPERATORS z NAMESPACE [std::rel_ops] aj na tieto CLASSES, kde to nebolo zamyslane a sposobit tak COMPILATION ERRORS.
69. CLASS [ratio<N,D>] umoznuje reprezenovat zlomky. CLASS [ratio<N,D>] ma nasledujuce MEMBERS.
   A. TYPE [ratio<N,D>::type] vracia TYPE danej CLASS.
   B. CONSTEXPR FIELD [ratio<N,D>::num] obsahuje hodnotu NASOBITELA zlomku.
   C. CONSTEXPR FIELD [ratio<N,D>::den] obsahuje hodnotu DELITELA zlomku.
!!!!! 70. Z CLASS [ratio<N,D>] NEMA ZMYSEL vytvarat INSTANCIE. Pouziva sa ako definicia TYPE, ktory vdaka svojim CONSTANTS definuje zlomok. Pre CLASS [ratio<N,D>] NIE SU DEFINOVANE ZIADNE OPERATIONS ani METHODS. Jediny vyznam je pouzitie samotneho TYPE.
!!! 71. CLASS [ratio<N,D>] v COMPILE TIME AUTOMATICKY vykonava vykratenie zlomku, takze jeho FIELDS uz obsahuju tieto vykratene hodnoty.
!!! 72. C++ definuje sadu TEMPLATES, ktore umoznuju vykonavat zakladne matematicke operacie a porovnania nad CLASS [ratio<N,D>]. Vysledkom tychto operacii je NOVY TYPE vyjadruci hodnotu noveho zlomoku, alebo vysledok porovnavacieho operatora. C++ definuje tieto TEMPLATES.
   A. TEMPLATE ratio_add<R1,R2> vykonava sucet CLASS [ratio<N1,D1>] a CLASS [ratio<N2,D2>].
   B. TEMPLATE ratio_subtract<R1,R2> vykonava sucet CLASS [ratio<N1,D1>] a CLASS [ratio<N2,D2>].
   C. TEMPLATE ratio_multiply<R1,R2> vykonava sucet CLASS [ratio<N1,D1>] a CLASS [ratio<N2,D2>].
   D. TEMPLATE ratio_divide<R1,R2> vykonava sucet CLASS [ratio<N1,D1>] a CLASS [ratio<N2,D2>].
   E. TEMPLATE ratio_equal<R1,R2> porovnava ci su CLASS [ratio<N1,D1>] a CLASS [ratio<N2,D2>] obsahuju zhodne hodnoty.
   F. TEMPLATE ratio_equal<R1,R2> porovnava ci CLASS [ratio<N1,D1>] a CLASS [ratio<N2,D2>] obsahuju rozdielne hodnoty.
   G. TEMPLATE ratio_less<R1,R2> porovnava ci CLASS [ratio<N1,D1>] obsahuje mensiu hodnotu ako CLASS [ratio<N2,D2>].
   H. TEMPLATE ratio_less_equal<R1,R2> porovnava ci CLASS [ratio<N1,D1>] obsahuje mensiu, alebo rovnu hodnotu ako CLASS [ratio<N2,D2>].
   I. TEMPLATE ratio_greater<R1,R2> porovnava ci CLASS [ratio<N1,D1>] obsahuje vacsiu hodnotu ako CLASS [ratio<N2,D2>].
   J. TEMPLATE ratio_greater_equal<R1,R2> porovnava ci CLASS [ratio<N1,D1>] obsahuje vacsiu, alebo rovnu hodnotu ako CLASS [ratio<N2,D2>].
73. CLASS [ratio<N,D>] obsahuje nasledujuce ALIASES, ktore umoznuju jednoducho vyjadrit casto pouzivane zlomky.
   A. ALIAS [yocto] reprezentuje CLASS [ratio<1,1000000000000000000000000>]. Je definovana iba ako to TYPE [intmax_t] umoznuje.
   B. ALIAS [zepto] reprezentuje CLASS [ratio<1,1000000000000000000000>]. Je definovana iba ako to TYPE [intmax_t] umoznuje.
   C. ALIAS [atto] reprezentuje CLASS [ratio<1,1000000000000000000>].
   D. ALIAS [femto] reprezentuje CLASS [ratio<1,1000000000000000>].
   E. ALIAS [pico] reprezentuje CLASS [ratio<1,1000000000000>].
   F. ALIAS [nano] reprezentuje CLASS [ratio<1,1000000000>].
   G. ALIAS [micro] reprezentuje CLASS [ratio<1,1000000>].
   H. ALIAS [milli] reprezentuje CLASS [ratio<1,1000>].
   I. ALIAS [centi] reprezentuje CLASS [ratio<1,100>].
   J. ALIAS [deci] reprezentuje CLASS [ratio<1,10>].
   K. ALIAS [deca] reprezentuje CLASS [ratio<10,1>].
   L. ALIAS [hecto] reprezentuje CLASS [ratio<100,1>].
   M. ALIAS [kilo] reprezentuje CLASS [ratio<1000,1>].
   N. ALIAS [mega] reprezentuje CLASS [ratio<1000000,1>].
   O. ALIAS [giga] reprezentuje CLASS [ratio<1000000000,1>].
   P. ALIAS [tera] reprezentuje CLASS [ratio<1000000000000,1>].
   Q. ALIAS [peta] reprezentuje CLASS [ratio<1000000000000000,1>].
   R. ALIAS [exa] reprezentuje CLASS [ratio<1000000000000000000,1>].
   S. ALIAS [zetta] reprezentuje CLASS [ratio<1000000000000000000000,1>. Je definovana iba ako to TYPE [intmax_t] umoznuje.
   T. ALIAS [yotta] reprezentuje CLASS [ratio<1000000000000000000000000,1>. Je definovana iba ako to TYPE [intmax_t] umoznuje.
74. C++ definuje 2 sposobi prace s casom.
   A. Standardne C FUNCTIONS pre pracu s casom.
   B. CHRONO LIBRARY definovanu vo FILE [chrono] a NAMEPSACE [std::chrono].
75. CHRONO LIBRARY definuje nasledujuce pojmy.
   A. DURATION. DURATION je casovu dobu vyjadrenu poctom TICKS, kde TICK je vyjadreny casovou jednotkou. TICK napriklad moze byt HODINA ci MILISEKUNDA. DURATION potom urcuje casovu dobu. Napriklad DEN ako DURATION je vyjadreny v jednotkach SUKUNDA obsahuje 86400 TICKS.
   B. EPOCH. EPOCH je pociatocny bod od ktoreho sa pocita cas. Typickym prikladom EPOCH je [00:00:00-1.1.1970.], alebo [00:00:00-1.1.1601.].
   C. TIMEPOINT. TIMEPOINT reprezentuje konkretny cas. Je to kombinacia EPOCH+DURATION. Napriklad cas [10:30:00-1.1.2001.] pri pouziti EPOCH [00:00:00-1.1.2001.] ma DURATION 630 sekundovych TICKS.
   D. CLOCK. CLOCK definuje hodnotu EPOCH a TICK. CHRONO LIBRARY umoznuje definovat rozlicne typy CLOCK (kombinacie definicii EPOCH a TICK).
!!! 76. DURATION v C++ reprezentuje TEMPLATE CLASS [duration<TType,TPeriod>]. TYPE PARAMETERS maju nasledujuci vyznam.
   A. TYPE PARAMETER [TType] urcuje NUMERIC TYPE v ktorom budu reprezentovane TICKS. Typickym prikladom su TYPES [int] a [double].
   !!!!! B. TYPE PARAMETER [TPeriod] urcuje velkost TICK v SEKUNDACH. Urcuje sa pomocou CLASS [ratio<N,D>]. Napriklad TYPE [ratio<10,1000>] urcuje, ze 1 TICK bude predstavovat 10 MILISEKUND.
77. CLASS [duration<TType,TPeriod>] ma nasledujuce MEMBERS.
   1. TYPE [duration<TType,TPeriod>::rep] obsahuje TYPE z TYPE PARAMETER [TType]. Urcuje TYPE v ktorom su TICKS reprezentovane.
   2. TYPE [duration<TType,TPeriod>::period] obsahuje TYPE z TYPE PARAMETER [TPeriod]. Urcuje jednotku v zlomku SEKUND, ktory vyjadruje hodnotu 1 TICK.
   3. CONSTRUCTOR inicializuje instanciu CLASS [duration<TType,TPeriod>]. CLASS definuje aj COPY CONSTRUCTOR.
   4. OPERATOR= implementuje operaciu priradenia instancie DURATION do inej instancie.
   5. OPERATOR+ realizuje funkcnost UNARNEHO OPERATOR+.
   6. OPERATOR- realizuje funkcnost UNARNEHO OPERATOR-.
   7. OPERATOR+ realizuje funkcnost UNARNEHO OPERATOR+.
   8. OPERATOR- realizuje funkcnost UNARNEHO OPERATOR-.
   9. OPERATOR++ realizuje funkcnost UNARNEHO OPERATOR++.
   10. OPERATOR-- realizuje funkcnost UNARNEHO OPERATOR--.
   11. OPERATOR+ realizuje funkcnost BINARNEHO OPERATOR+. OPERATOR je mozne aplikovat IBA medzi 2 instanciami DURATION, ktore mozu mat ODLISNE RATIO.
   12. OPERATOR- realizuje funkcnost BINARNEHO OPERATOR-. OPERATOR je mozne aplikovat IBA medzi 2 instanciami DURATION, ktore mozu mat ODLISNE RATIO.
   !!! 13. OPERATOR* realizuje funkcnost BINARNEHO OPERATOR*. OPERATOR je mozne aplikovat IBA medzi DURATION a NUMERIC TYPE.
   !!! 14. OPERATOR/ realizuje funkcnost BINARNEHO OPERATOR/. OPERATOR je mozne aplikovat iba medzi DURATION a NUMERIC TYPE, alebo medzi 2 DURATIONS, kedy je vysledkom NUMERIC TYPE reprezentujuci pocet TICKS.
   15. OPERATOR% realizuje funkcnost BINARNEHO OPERATOR%. OPERATOR je mozne aplikovat medzi ROZLICNYMI typmi DURATIONS a medzi DURATION a NUMERIC TYPE reprezentujucim pocet TICKS.
   16. OPERATOR+= realizuje funkcnost BINARNEHO OPERATOR+=. OPERATOR je mozne aplikovat IBA medzi 2 instanciami DURATION, ktore mozu mat ODLISNE RATIO.
   17. OPERATOR-= realizuje funkcnost BINARNEHO OPERATOR-=. OPERATOR je mozne aplikovat IBA medzi 2 instanciami DURATION, ktore mozu mat ODLISNE RATIO.
   !!! 18. OPERATOR*= realizuje funkcnost BINARNEHO OPERATOR*=. OPERATOR je mozne aplikovat IBA medzi DURATION a NUMERIC TYPE.
   !!! 19. OPERATOR/= realizuje funkcnost BINARNEHO OPERATOR/=. OPERATOR je mozne aplikovat iba medzi DURATION a NUMERIC TYPE, alebo medzi 2 DURATIONS, kedy je vysledkom NUMERIC TYPE reprezentujuci pocet TICKS.
   20. OPERATOR%= realizuje funkcnost BINARNEHO OPERATOR%=. OPERATOR je mozne aplikovat medzi ROZLICNYMI typmi DURATIONS a medzi DURATION a NUMERIC TYPE reprezentujucim pocet TICKS.
   21. OPERATOR== realizuje funkcnost BINARNEHO OPERATOR==. OPERATOR je mozne aplikovat medzi ROZLICNYMI typmi DURATIONS.
   22. OPERATOR!= realizuje funkcnost BINARNEHO OPERATOR!=. OPERATOR je mozne aplikovat medzi ROZLICNYMI typmi DURATIONS.
   23. OPERATOR< realizuje funkcnost BINARNEHO OPERATOR<. OPERATOR je mozne aplikovat medzi ROZLICNYMI typmi DURATIONS.
   24. OPERATOR<= realizuje funkcnost BINARNEHO OPERATOR<=. OPERATOR je mozne aplikovat medzi ROZLICNYMI typmi DURATIONS.
   25. OPERATOR> realizuje funkcnost BINARNEHO OPERATOR>. OPERATOR je mozne aplikovat medzi ROZLICNYMI typmi DURATIONS.
   26. OPERATOR>= realizuje funkcnost BINARNEHO OPERATOR>=. OPERATOR je mozne aplikovat medzi ROZLICNYMI typmi DURATIONS.
   !!! 27. METHOD count() vracia pocet TICKS.
   28. STATIC METHOD min() vracia minimalnu hodnotu, ktoru je moznu pomocou CLASS [duration<TType,TPeriod>] vyjadrit.
   29. STATIC METHOD max() vracia maximalnu hodnotu, ktoru je moznu pomocou CLASS [duration<TType,TPeriod>] vyjadrit.
   30. STATIC METHOD zero() vracia nulovu DURATION.
   !!! 31. TEMPLATE FUNCTION duration_cast<duration<TType2,TPeriod2>>(duration<TType1,TPeriod1>) realizuje STRATOVU KONVERZIU z DURATION TYPU [duration<TType1,TPeriod1>] na DURATION TYPU [duration<TType2,TPeriod2>]. Konverzia je STRATOVA, co znaci, ze ak hodnota, ktoru nie je mozne po konverzii vyjadrit TYPE [duration<TType2,TPeriod2>] je odseknuta.
!!! 78. CLASS [duration<TType,TPeriod>] umoznuje vykonavat MATEMATICKE OPERACIE medzi ROZNYMI TYPMI DURATIONS. Vysledkom tychto operacii je DURATION, ktory je NAJVACSIM SPOLOCNYM DELITELOM oboch DURATIONS nad ktorymi bola vykonana matematicka operacia.
!!! 79. CLASS [duration<TType,TPeriod>] umoznuje aplikovat POROVNAVACIE OPERATORS medzi ROZNYMI TYPMI DURATIONS.
!!! 80. CLASS [duration<TType,TPeriod>] umoznuje vykonavat IMPLICITNE KONVERZIE medzi ROZNYMI TYPMI DURATIONS ak NEDOCHADZA k strate presnosti. Pri strate presnosti je KONVERZIU NUTNE vykonat pomocou FUNCTION TEMPLATE duration_cast<duration<TType2,TPeriod2>>(duration<TType1,TPeriod1>).
81. C++ definuje nasledujuce ALIASES pre CLASS [duration<TType,TPeriod>].
   A. TYPE [nanoseconds] reprezentuje DURATION v nanosekundach.
   B. TYPE [microseconds] reprezentuje DURATION v mikrosekundach.
   C. TYPE [miliseconds] reprezentuje DURATION v milisekundach.
   D. TYPE [seconds] reprezentuje DURATION v sekundach.
   E. TYPE [minutes] reprezentuje DURATION v minutach.
   F. TYPE [hours] reprezentuje DURATION v hodinach.
82. CLOCK je CONCEPT, ktory definuje ake MEMBERS ma CLASS definovat, aby mohla byt povazovana za CLOCK. CONCEPT CLOCK vyzaduje, aby CLASS definovala nasledujuce MEMBERS.
   A. TYPE [CLOCK::duration] musi vratit DURATION TYPE. Spravidla vracia TYPE [duration<TType,TPeriod>].
   B. TYPE [CLOCK::rep] musi vratit TYPE reprezentujuci TICKS. TYPE by mal byt ekvivalentny s TYPE [CLOCK::duration::rep].
   C. TYPE [CLOCK::period] musi vratit TYPE reprezentujuci periodu TICK. TYPE by mal byt ekvivalentny s TYPE [CLOCK::duration::period]. Spravidla je to TYPE [ratio<N,D>].
   D. TYPE [CLOCK::timepoint] musi vratit TYPE reprezentujuci TIMEPOINT. Spravidla sa jedna o TYPE [time_point<TClock,TDuration>].
   E. STATIC FIELD [CLOCK::is_steady] by mal vratit TRUE, ak je CLOCK STEADY. STEADY CLOCK je CLOCK, ktoreho hodnota je NEZAVISLA na zmene systemoveho casu. To znaci, ze jeho hodnota neustale narasta, bez ohladu na zmenu DAYLIGHT SAVING TIME ci zmenu casu systemovych hodin.
   F. STATIC METHOD [CLOCK::now()] vracia instanciu [CLOCK::timepoint] obsahujucu aktualny cas.
83. C++ definuje 3 typy CLOCKS.
   A. CLASS [system_clock] reprezentuje hodiny systemoveho casu. Systemovy cas sa NIE JE STEADY a teda sa moze skokovito menit zmenou DAYLIGHT SAVING TIME, alebo pri zmene casu systemovych hodin. CLASS obsahuje METHODS system_clock::to_time_t() a system_clock::from_time_t() umoznujuce konverzie z C TIME TYPE [time_t] pouzivaneho v C TIME FUNCTIONS.
   B. CLASS [high_resolution_clock] reprezentuje hodiny s vysokou presnostou. Spravidla NIE JE STEADY, aj ked moze byt. Zavisi to od platformy.
   C. CLASS [steady_clock] reprezentuje STEADY CLOCK. STEADY CLOCK je CLOCK, ktoreho hodnota je NEZAVISLA na zmene systemoveho casu. To znaci, ze jeho hodnota neustale narasta, bez ohladu na zmenu DAYLIGHT SAVING TIME ci zmenu casu systemovych hodin.
84. CLASS [time_point<TClock,TDuration>] reprezentuje TIME POINT. Ma nasledujuce MEMBERS.
   A. TYPE [clock] vracia TYPE CLOCK z ktoreho bol TIME POINT vytvoreny.
   B. TYPE [duration] vracia TYPE DURATION, ktory pouziva CLOCK z ktoreho bol TIME POINT vytvoreny.
   C. TYPE [rep] vracia TYPE reprezentujuci TICKS, ktory pouziva CLOCK z ktoreho bol TIME POINT vytvoreny.
   D. TYPE [period] vracia TYPE reprezentujuci periodu TICK, ktory pouziva CLOCK z ktoreho bol TIME POINT vytvoreny.
   E. CONSTRUCTOR inicializuje instanciu CLASS [time_point<TClock,TDuration>]. CLASS definuje aj COPY CONSTRUCTOR.
   F. OPERATOR+ realizuje funkcnost BINARNEHO OPERATOR+. OPERATOR je mozne aplikovat medzi TIME POINT a DURATION.
   G. OPERATOR- realizuje funkcnost BINARNEHO OPERATOR-. OPERATOR je mozne aplikovat medzi 2 instanciami TIME POINT ako aj medzi TIME POINT a DURATION.
   H. OPERATOR+= realizuje funkcnost BINARNEHO OPERATOR+=. OPERATOR je mozne aplikovat TIME POINT a DURATION.
   I. OPERATOR-= realizuje funkcnost BINARNEHO OPERATOR-=. OPERATOR je mozne aplikovat TIME POINT a DURATION.
   J. OPERATOR== realizuje funkcnost BINARNEHO OPERATOR==.
   K. OPERATOR!= realizuje funkcnost BINARNEHO OPERATOR!=.
   L. OPERATOR< realizuje funkcnost BINARNEHO OPERATOR<.
   M. OPERATOR<= realizuje funkcnost BINARNEHO OPERATOR<=.
   N. OPERATOR> realizuje funkcnost BINARNEHO OPERATOR>.
   O. OPERATOR>= realizuje funkcnost BINARNEHO OPERATOR>=.
   P. METHOD time_since_epoch() vracia DURATION od EPOCH daneho CLOCK.
   Q. STATIC METHOD min() vracia minimalnu hodnotu, ktoru je moznu pomocou CLASS [time_point<TClock,TDuration>] vyjadrit.
   R. STATIC METHOD max() vracia maximalnu hodnotu, ktoru je moznu pomocou CLASS [time_point<TClock,TDuration>] vyjadrit.
   !!! S. TEMPLATE FUNCTION time_point_cast<duration<TType,TPeriod>>(time_point<TClock,TDuration>) realizuje STRATOVU KONVERZIU z DURATION TYPU [time_point<TClock1,TDuration1>] na DURATION TYPU [time_point<TClock2,TDuration2>]. Konverzia je STRATOVA, co znaci, ze ak hodnota, ktoru nie je mozne po konverzii vyjadrit TYPE [time_point<TClock2,TDuration2>] je odseknuta.
!!! 85. CLASS [time_point<TClock,TDuration>] umoznuje vykonavat IMPLICITNE KONVERZIE medzi ROZNYMI TYPMI TIME POINTS ak NEDOCHADZA k strate presnosti. Pri strate presnosti je KONVERZIU NUTNE vykonat pomocou FUNCTION TEMPLATE time_point_cast<duration<TType,TPeriod>>(time_point<TClock,TDuration>).
!!!!! 86. CHRONO LIBRARY NIE JE DATE-TIME LIBRARY. Jej hlavnym cielom je praca s CASOVYMI ROZDIELMI. Aj preto NEOBSAHUJE operacie na pracu s casom ako napriklad pricitanie mesiacov ci rokov. Pre tieto operacie je nutne vykona CUSTOM IMPLEMENTATION.
87. C++ LIBRARY <ctime> obsahuje nasledujuce MEMBERS definovane v NAMESPACE [std].
   A. TYPE [clock_t] je numericky TYPE reprezentujuci CLOCK TICK.
   B. TYPE [time_t] je numericky TYPE reprezentujuci TIMEPOINT. Spravidla je reprezentovany v SEKUNDACH, aj ked to STANDARD nepredpisuje.
   C. TYPE [size_t] je numericky TYPE reprezentujuci velkost v BYTES. Pouziva sa vo FUNCTION strftime().
   D. TYPE [tm] je STRUCTURE, ktora reprezentuje kalendarovy cas.
   E. CONSTANT [CLOCKS_PER_SECONDS] vyjadruje pocet CLOCK TICKS za sekundu.
   F. FUNCTION clock() vracia aktualny cas v pocte CLOCK TICKS. Ako EPOCH sa spravidla, aj ked to nie je definovane v STANDARDE pouziva start PROGRAMU.
   G. FUNCTION time() vracia aktualny TIMEPOINT. Ako EPOCH sa spravidla, aj ked to nie je definovane v STANDARDE pouziva datum 1.1.1970. 00:00:00.
   H. FUNCTION difftime() vypocitava rozdiel medzi dvoma instancia STRUCTURE [tm]. Rozdiel je v sekundach vrateny ako [double] VALUE.
   I. FUNCTION localtime() konvertuje hodnotu [time_t] na hodnotu [tm], pricom BERIE do uvahy TIME ZONE a DAYLIGHT SAVING TIME.
   J. FUNCTION gmtime() konvertuje hodnotu [time_t] na hodnotu [tm], pricom NEBERIE do uvahy TIME ZONE a DAYLIGHT SAVING TIME. Pouziva sa UTC TIME.
   K. FUNCTION asctime() konvertuje hodnotu [tm] na STRING reprezentujuci CALENDAR TIME.
   L. FUNCTION strftime() konvertuje hodnotu [tm] na STRING reprezentujuci CALENDAR TIME, pricom umoznuje definovat CUSTOM FORMAT.
   M. FUNCTION ctime() konvertuje hodnotu [time_t] na STRING reprezentujuci CALENDAR TIME. Interne vola CODE [asctime(localtime(T))].
   N. FUNCTION konvertuje hodnotu [tm] na hodnotu [time_t].
88. C++ definuje sadu FUNCTIONS a METHODS, ktore je mozne pouzit na THREAD BLOCKING.
   A. FUNCTION this_thread::sleep_for() definovana v NAMESPACE [std::this_thread] zabokuje CURRENT THREAD na stanoveny DURATION. Kedze FUNCTION pouziva STEADY CLOCK, je cas NEZAVISLY na zmene SYSTEM TIME ci DAYLIGHT SAVING TIME.
   B. FUNCTION this_thread::sleep_until() definovana v NAMESPACE [std::this_thread] zabokuje CURRENT THREAD az po stanoveny TIMEPOINT. Kedze FUNCTION NEPOUZIVA STEADY CLOCK, je cas ZAVISLY na zmene SYSTEM TIME ci DAYLIGHT SAVING TIME.
   C. METHOD timed_mutex::try_lock_for() zablokuje CURRENT THREAD na stanoveny DURATION, alebo pokym nie je MUTEX SIGNALIZED. Kedze FUNCTION pouziva STEADY CLOCK, je cas NEZAVISLY na zmene SYSTEM TIME ci DAYLIGHT SAVING TIME.
   D. METHOD timed_mutex::try_lock_until() zablokuje CURRENT THREAD az po stanoveny TIMEPOINT, alebo pokym nie je MUTEX SIGNALIZED. Kedze FUNCTION NEPOUZIVA STEADY CLOCK, je cas ZAVISLY na zmene SYSTEM TIME ci DAYLIGHT SAVING TIME.
   E. METHOD condition_variable::wait_for() zablokuje CURRENT THREAD na stanoveny DURATION, alebo pokym nie je CONDITION VARIABLE SIGNALIZED. Kedze FUNCTION pouziva STEADY CLOCK, je cas NEZAVISLY na zmene SYSTEM TIME ci DAYLIGHT SAVING TIME.
   F. METHOD condition_variable::wait_until() zablokuje CURRENT THREAD az po stanoveny TIMEPOINT, alebo pokym nie je CONDITION VARIABLE SIGNALIZED. Kedze FUNCTION NEPOUZIVA STEADY CLOCK, je cas ZAVISLY na zmene SYSTEM TIME ci DAYLIGHT SAVING TIME.
89. LIBRARY <cstddef> obsahuje nasledujuce MEMBERS.
   A. CONSTANT [NULL] reprezentuje NULL POINTER.
   B. TYPE [nullptr_t] reprezentuje TYPE, ktory vyjadruje NULL POINTER od C++ 11.
   C. TYPE [size_t] je UNSIGNED NUMBERIC TYPE, ktory sluzi na vyjadrovanie velkosti ci poctu ELEMENTS.
   D. TYPE [ptrdiff_t] je SIGNED NUMBERIC TYPE, v ktorom sa urcuje vysledok POINTER ARITHMETIC.
   E. TYPE [max_align_t] je TYPE, ktory ma velkost v BYTES rovnajucu sa maximalnemu ALIGNMENT, aky je v C++ mozny.
   F. MACRO OFFSET(TYPE,MEMBER) vracia OFFSET TYPE MEMBER 'MEMBER' v TYPE 'TYPE'.
90. LIBRARY <cstdlib> obsahuje nasledujuce MEMBERS.
   A. CONSTANT [EXIT_SUCCESS] sluzi na indikaciu, ze PROGRAM skoncil korektne. Pouziva sa ako RETURN VALUE main().
   B. CONSTANT [EXIT_FAILURE] sluzi na indikaciu, ze PROGRAM skoncil v ERROR. Pouziva sa ako RETURN VALUE main().
   !!! C. FUNCTION atexit() zaregistruje CALLBACK FUNCTION, ktora sa pri ukonceni PROGRAMU. PROGRAM moze zaregistrovat aj VIACERO CALLBACK FUNCTIONS, ktore sa budu volat v OPACNOM PORADI v akom boli zaregistrovane.
   !!! D. FUNCTION at_quick_exit() zaregistruje CALLBACK FUNCTION, ktora sa pri ukonceni PROGRAMU pomocou volania FUNCTION quick_exit(). PROGRAM moze zaregistrovat aj VIACERO CALLBACK FUNCTIONS, ktore sa budu volat v OPACNOM PORADI v akom boli zaregistrovane.
   !!! F. FUNCTION exit() OKAMZITE ukonci PROGRAM, pricom zavola CALLBACK FUNCTIONS zaregistrovane volanim FUNCTION atexit() a nasledne zavola DESTRUCTORS pre STATIC a GLOBAL OBJECTS.
   !!! G. FUNCTION quick_exit() OKAMZITE ukonci PROGRAM, pricom zavola CALLBACK FUNCTIONS zaregistrovane volanim FUNCTION at_quick_exit(). DESTRUCTORS pre STATIC a GLOBAL OBJECTS sa NEVOLAJU.
   !!! H. FUNCTION _Exit() OKAMZITE ukonci PROGRAM, pricom NEVOLA ZIADNE CALLBACK FUNCTIONS a ani NEVOLA DESTRUCTORS pre STATIC a GLOBAL OBJECTS.
   !!! I. FUNCTION abort() OKAMZITE ukonci PROGRAM, pricom NEVOLA ZIADNE CALLBACK FUNCTIONS a ani NEVOLA DESTRUCTORS pre STATIC a GLOBAL OBJECTS. V operanom systeme volanie FUNCTION sa rovna PADU PROGRAMU. Vo WINDOWS sa vyhodi chybove okno.
91. LIBRARY <cstring> obsahuje nasledujuce MEMBERS.
   A. FUNCTION memchar() hlada znak v prvych 'N' BYTES v zadanej MEMORY.
   B. FUNCTION memcmp() porovnava 2 bloky MEMORY o dlzke 'N' BYTES.
   C. FUNCTION memcpy() kopiruje 'N' BYTES MEMORY z jednej pozicie na inu.
   D. FUNCTION memmove() presuva 'N' BYTES MEMORY z jednej pozicie na inu, pricom pozicie sa mozu vzajomne prekryvat.
   E. FUNCTION memset() nastavuje znak na prvych 'N' BYTES v zadanej MEMORY.
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
THREAD SAFE CLASS CLASS [shared_ptr<T>].

!!! 1. CLASS [shared_ptr<T>] NIE JE THREAD SAFE, ale C++ poskytuje nasledujuce FUNCTIONS pre THREAD SAFE pracu s POINTER, ktory instancia CLASS [shared_ptr<T>] obaluje.
   A. FUNCTION atomic_is_lock_free() vracia TRUE, ak atomicke opracie nad CLASS [shared_ptr<T>] su LOCK FREE.
   B. FUNCTION atomic_load() vracia novu instanciu CLASS [shared_ptr<T>] z instancie CLASS [shared_ptr<T>] THREAD SAFE sposobom.
   C. FUNCTION atomic_store() nastavuje instanciu CLASS [shared_ptr<T>] na POINTER ulozeny v instancii CLASS [shared_ptr<T>] na novy POINTER THREAD SAFE sposobom.
   D. FUNCTION atomic_exchange() vymiena POINTERS ulozene v dvoch instanciach CLASS [shared_ptr<T>] THREAD SAFE sposobom.
!!!!! 2. Aj ked CLASS [shared_ptr<T>] NIE JE THREAD SAFE, tak operacie nad ROZNYMI INSTANCIAMI CLASS [shared_ptr<T>], ktore referuju na TEN ISTY OBJECT z ROZNYCH THREADS SU THREAD SAFE. THREAD UNSAFE je IBA pristup k TEJ ISTE instancii CLASS [shared_ptr<T>] z ROZLICNYCH THREADS.
!!!!! 3. C++ DOCUMENTATION ku CLASS [shared_ptr<T>] uvadza nasledujuce informacie k THREAD SAFE.
   A.  If multiple threads of execution access the same [shared_ptr<T>] without synchronization and any of those accesses uses a non-const member function of [shared_ptr<T>] then a data race will occur. The [shared_ptr<T>] overloads of atomic functions can be used to prevent the data race.
   !!!!! B. All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of [shared_ptr<T>] without additional synchronization EVEN IF these instances are copies and SHARE OWNERSHIP of the SAME OBJECT.
//-------------------------------------------------------------------------------------------------------