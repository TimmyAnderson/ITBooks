//------------------------------------------------------------------------------
1. Program demonstruje pouzitie Monitors v .NET ako analogie CS z Native prostredia.
2. K Monitors mozem pristupovat bud pomocou statickych metod triedy Monitor, alebo pomocou klucoveho slova 'lock'.
!!! 3. Monitors na pozadi pouzivaju Win32 Events. Tie sa vsak alokuju IBA VTEDY, ked su nevyhnutne nutne - teda ked sa nad nimi realizuje WAIT. Az vtedy sa alokuje AutoResetEvent a ulozi sa do tzv. SYNC BLOCK co je blok pamete asociovany lubovolnym objektom, ktory je pouzity na LOCKING. SYNC BLOCK sa alokuje a dealokuje DYNAMICKY podla toho, ci dany objekt je louzity v LOCKING, alebo NIE.
!!! 4. Aj ked je mozne pouzit aj [MethodImpl], tak tento atribut je DEPRECATED, pretoze pri lockingu member metod pouziva 'this' a pri lockingu statickych metod zas Type danej triedy. Obe pouzitia su MAXIMALNE RISKATNE, kedze su pristupne aj pouzivatelom triedy a polahky mozu viest k DEADLOCK.
!!! 5. Metoda Monitor.TryEnter() umoznuje definovat SPIN TIME, teda cas pocas ktoreho sa realizuje SPINING. Po jeho skonceni VSAK NENASTAVA WAIT, ale VRATI SA HODNOTA ci LOCK BOL GRANTED, alebo NIE.
!!!!! 6. .NET interne POUZIVA SPINING. Ma implementovany specialny algritmus, ktory v zavislosti na pocte CPU pouziva SPINING pri implementacii Monitors. Je to vsak interna optimalizacia s ktorou aplikacny programator v .NET nepride do styku.
!!! 7. Struktury sa NESMU pouzivat v Monitors, kedze museli by byt EXPLICITNE BOXED, pocas ktoreho sa VZDY vytvori nova instancia objektu a tym padom NEMAM ZIADNU CRITICAL SECTION - data NIE SU CHRANENE.
!!! 8. Lock nad public objektom je NEBEZPECNY, kedze moze viest k tomu, ze pouzivatel objektu nad nim taktiez aplikuje lock a vysledkom je DEADLOCK.
!!!!! 9. EXTREMNE NEBEZPECNY je lock na triedou Type, string, MemberInfo (a dalsimi triedami Reflection). Ak totizto nad tymito objektami aplikujem LOCK a v programe pouzivam VIACERO APP DOMAINS, pricom je nastavene, aby SHARED ASSEMBLIES nahravalo ako DOMAIN NEUTRAL, potom mam IBA JEDNU INSTANCIU Type, string, MemberInfo vyslekom coho je, ze ak na nu aplikujem LOCK, tak mam CROSS APP DOMAIN LOCK a samozrejme mozem spravit aj DEADLOCK. ZAKLADNYM PROBLEMOM je PORUSENIE NEZAVISLOSTI APP DOMAINS.
!!!!! 10. VAZNYM PROBLEMOM su ASYNCHRONNE EXCEPTION (ako napriklad ThreadAbortException). Ak sa takato Exception vyskytne HNED PO Monitor.Enter(), ale PREDTYM AKO VOJDEM do 'try' bloku, stane sa, ze sa 'finaly', kde je Monitor.Leave() NEVYKONA a lock bude ORPHANED. STAVA SA TO AJ KED MEDZI Monitor.Enter() a 'try' NEDAM ZIADEN KOD, lebo C# kompilator, ale aj JIT MOZEM TAM PICHNUT operaciu NOP. (Ta sa pouziva pre lahsiu identifikaciu TRY blokov.) Vyslekom su spominane problemy s neuvolnenim Monitoru. NASTASTIE TENTO PROBLEM (aj ked IBA pre RELASE BUILD) BOL VYRIESENY v .NET 3.5..
//------------------------------------------------------------------------------